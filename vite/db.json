{"index":"<h1>Vite</h1><p>Next Generation Frontend Tooling</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/\" class=\"_attribution-link\">https://vite.dev/</a>\n  </p>\n</div>\n","config/index":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /config/index.md for this page in Markdown format</div>\n<h1 id=\"configuring-vite\" tabindex=\"-1\">Configuring Vite </h1>\n<p>When running <code>vite</code> from the command line, Vite will automatically try to resolve a config file named <code>vite.config.js</code> inside <a href=\"../guide/index#index-html-and-project-root\">project root</a> (other JS and TS extensions are also supported).</p>\n<p>The most basic config file looks like this:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default {\n  // config options\n}</pre>\n</div>\n</div>\n<p>Note Vite supports using ES modules syntax in the config file even if the project is not using native Node ESM, e.g. <code>\"type\": \"module\"</code> in <code>package.json</code>. In this case, the config file is auto pre-processed before load.</p>\n<p>You can also explicitly specify a config file to use with the <code>--config</code> CLI option (resolved relative to <code>cwd</code>):</p>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">vite --config my-config.js</pre>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">CONFIG LOADING</strong><p>By default, Vite uses <code>esbuild</code> to bundle the config into a temporary file and load it. This may cause issues when importing TypeScript files in a monorepo. If you encounter any issues with this approach, you can specify <code>--configLoader runner</code> to use the <a href=\"../guide/api-environment-runtimes#modulerunner\">module runner</a> instead, which will not create a temporary config and will transform any files on the fly. Note that module runner doesn't support CJS in config files, but external CJS packages should work as usual.</p>\n<p>Alternatively, if you're using an environment that supports TypeScript (e.g. <code>node --experimental-strip-types</code>), or if you're only writing plain JavaScript, you can specify <code>--configLoader native</code> to use the environment's native runtime to load the config file. Note that updates to modules imported by the config file are not detected and hence would not auto-restart the Vite server.</p>\n</div>\n<h2 id=\"config-intellisense\" tabindex=\"-1\">Config Intellisense </h2>\n<p>Since Vite ships with TypeScript typings, you can leverage your IDE's intellisense with jsdoc type hints:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">/** @type {import('vite').UserConfig} */\nexport default {\n  // ...\n}</pre>\n</div>\n<p>Alternatively, you can use the <code>defineConfig</code> helper which should provide intellisense without the need for jsdoc annotations:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { defineConfig } from 'vite'\n\nexport default defineConfig({\n  // ...\n})</pre>\n</div>\n<p>Vite also supports TypeScript config files. You can use <code>vite.config.ts</code> with the <code>defineConfig</code> helper function above, or with the <code>satisfies</code> operator:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import type { UserConfig } from 'vite'\n\nexport default {\n  // ...\n} satisfies UserConfig</pre>\n</div>\n<h2 id=\"conditional-config\" tabindex=\"-1\">Conditional Config </h2>\n<p>If the config needs to conditionally determine options based on the command (<code>serve</code> or <code>build</code>), the <a href=\"../guide/env-and-mode#modes\">mode</a> being used, if it's an SSR build (<code>isSsrBuild</code>), or is previewing the build (<code>isPreview</code>), it can export a function instead:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig(({ command, mode, isSsrBuild, isPreview }) =&gt; {\n  if (command === 'serve') {\n    return {\n      // dev specific config\n    }\n  } else {\n    // command === 'build'\n    return {\n      // build specific config\n    }\n  }\n})</pre>\n</div>\n<p>It is important to note that in Vite's API the <code>command</code> value is <code>serve</code> during dev (in the cli <a href=\"../guide/cli#vite\"><code>vite</code></a>, <code>vite dev</code>, and <code>vite serve</code> are aliases), and <code>build</code> when building for production (<a href=\"../guide/cli#vite-build\"><code>vite build</code></a>).</p>\n<p><code>isSsrBuild</code> and <code>isPreview</code> are additional optional flags to differentiate the kind of <code>build</code> and <code>serve</code> commands respectively. Some tools that load the Vite config may not support these flags and will pass <code>undefined</code> instead. Hence, it's recommended to use explicit comparison against <code>true</code> and <code>false</code>.</p>\n<h2 id=\"async-config\" tabindex=\"-1\">Async Config </h2>\n<p>If the config needs to call async functions, it can export an async function instead. And this async function can also be passed through <code>defineConfig</code> for improved intellisense support:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig(async ({ command, mode }) =&gt; {\n  const data = await asyncFunction()\n  return {\n    // vite config\n  }\n})</pre>\n</div>\n<h2 id=\"using-environment-variables-in-config\" tabindex=\"-1\">Using Environment Variables in Config </h2>\n<p>Environmental Variables can be obtained from <code>process.env</code> as usual.</p>\n<p>Note that Vite doesn't load <code>.env</code> files by default as the files to load can only be determined after evaluating the Vite config, for example, the <code>root</code> and <code>envDir</code> options affect the loading behaviour. However, you can use the exported <code>loadEnv</code> helper to load the specific <code>.env</code> file if needed.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { defineConfig, loadEnv } from 'vite'\n\nexport default defineConfig(({ mode }) =&gt; {\n  // Load env file based on `mode` in the current working directory.\n  // Set the third parameter to '' to load all env regardless of the\n  // `VITE_` prefix.\n  const env = loadEnv(mode, process.cwd(), '')\n  return {\n    // vite config\n    define: {\n      __APP_ENV__: JSON.stringify(env.APP_ENV),\n    },\n  }\n})</pre>\n</div>\n<h2 id=\"debugging-the-config-file-on-vs-code\" tabindex=\"-1\">Debugging the Config File on VS Code </h2>\n<p>With the default <code>--configLoader bundle</code> behavior, Vite writes the generated temporary configuration file to the <code>node_modules/.vite-temp</code> folder and a file not found error will occur when setting breakpoint debugging in the Vite config file. To fix the issue, add the following configuration to <code>.vscode/settings.json</code>:</p>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"debug.javascript.terminalOptions\": {\n    \"resolveSourceMapLocations\": [\n      \"${workspaceFolder}/**\",\n      \"!**/node_modules/**\",\n      \"**/node_modules/.vite-temp/**\"\n    ]\n  }\n}</pre>\n</div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/config/\" class=\"_attribution-link\">https://vite.dev/config/</a>\n  </p>\n</div>\n","releases":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /releases.md for this page in Markdown format</div>\n<h1 id=\"releases\" tabindex=\"-1\">Releases </h1>\n<p>Vite releases follow <a href=\"https://semver.org/\" target=\"_blank\" rel=\"noreferrer\">Semantic Versioning</a>. You can see the latest stable version of Vite in the <a href=\"https://www.npmjs.com/package/vite\" target=\"_blank\" rel=\"noreferrer\">Vite npm package page</a>.</p>\n<p>A full changelog of past releases is <a href=\"https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md\" target=\"_blank\" rel=\"noreferrer\">available on GitHub</a>.</p>\n<h2 id=\"release-cycle\" tabindex=\"-1\">Release Cycle </h2>\n<p>Vite does not have a fixed release cycle.</p>\n<ul>\n<li>\n<strong>Patch</strong> releases are released as needed (usually every week).</li>\n<li>\n<strong>Minor</strong> releases always contain new features and are released as needed. Minor releases always have a beta pre-release phase (usually every two months).</li>\n<li>\n<strong>Major</strong> releases generally align with <a href=\"https://endoflife.date/nodejs\" target=\"_blank\" rel=\"noreferrer\">Node.js EOL schedule</a>, and will be announced ahead of time. These releases will go through long-term discussions with the ecosystem, and have alpha and beta pre-release phases (usually every year).</li>\n</ul>\n<p>The Vite version ranges that are supported by the Vite team are automatically determined by:</p>\n<ul>\n<li>\n<strong>Current Minor</strong> gets regular fixes.</li>\n<li>\n<strong>Previous Major</strong> (only for its latest minor) and <strong>Previous Minor</strong> receives important fixes and security patches.</li>\n<li>\n<strong>Second-to-last Major</strong> (only for its latest minor) and <strong>Second-to-last Minor</strong> receives security patches.</li>\n<li>All versions before these are no longer supported.</li>\n</ul>\n<p>As an example, if the Vite latest is at 5.3.10:</p>\n<ul>\n<li>Regular patches are released for <code>vite@5.3</code>.</li>\n<li>Important fixes and security patches are backported to <code>vite@4</code> and <code>vite@5.2</code>.</li>\n<li>Security patches are also backported to <code>vite@3</code>, and <code>vite@5.1</code>.</li>\n<li>\n<code>vite@2</code> and <code>vite@5.0</code> are no longer supported. Users should upgrade to receive updates.</li>\n</ul>\n<p>We recommend updating Vite regularly. Check out the <a href=\"guide/migration\" rel=\"noreferrer\" target=\"_blank\">Migration Guides</a> when you update to each Major. The Vite team works closely with the main projects in the ecosystem to ensure the quality of new versions. We test new Vite versions before releasing them through the <a href=\"https://github.com/vitejs/vite-ecosystem-ci\" target=\"_blank\" rel=\"noreferrer\">vite-ecosystem-ci project</a>. Most projects using Vite should be able to quickly offer support or migrate to new versions as soon as they are released.</p>\n<h2 id=\"semantic-versioning-edge-cases\" tabindex=\"-1\">Semantic Versioning Edge Cases </h2>\n<h3 id=\"typescript-definitions\" tabindex=\"-1\">TypeScript Definitions </h3>\n<p>We may ship incompatible changes to TypeScript definitions between minor versions. This is because:</p>\n<ul>\n<li>Sometimes TypeScript itself ships incompatible changes between minor versions, and we may have to adjust types to support newer versions of TypeScript.</li>\n<li>Occasionally we may need to adopt features that are only available in a newer version of TypeScript, raising the minimum required version of TypeScript.</li>\n<li>If you are using TypeScript, you can use a semver range that locks the current minor and manually upgrade when a new minor version of Vite is released.</li>\n</ul>\n<h3 id=\"esbuild\" tabindex=\"-1\">esbuild </h3>\n<p><a href=\"https://esbuild.github.io/\" target=\"_blank\" rel=\"noreferrer\">esbuild</a> is pre-1.0.0 and sometimes it has a breaking change we may need to include to have access to newer features and performance improvements. We may bump the esbuild's version in a Vite Minor.</p>\n<h3 id=\"node-js-non-lts-versions\" tabindex=\"-1\">Node.js non-LTS versions </h3>\n<p>Non-LTS Node.js versions (odd-numbered) are not tested as part of Vite's CI, but they should still work before their <a href=\"https://endoflife.date/nodejs\" target=\"_blank\" rel=\"noreferrer\">EOL</a>.</p>\n<h2 id=\"pre-releases\" tabindex=\"-1\">Pre Releases </h2>\n<p>Minor releases typically go through a non-fixed number of beta releases. Major releases will go through an alpha phase and a beta phase.</p>\n<p>Pre-releases allow early adopters and maintainers from the Ecosystem to do integration and stability testing, and provide feedback. Do not use pre-releases in production. All pre-releases are considered unstable and may ship breaking changes in between. Always pin to exact versions when using pre-releases.</p>\n<h2 id=\"deprecations\" tabindex=\"-1\">Deprecations </h2>\n<p>We periodically deprecate features that have been superseded by better alternatives in Minor releases. Deprecated features will continue to work with a type or logged warning. They will be removed in the next major release after entering deprecated status. The <a href=\"guide/migration\" rel=\"noreferrer\" target=\"_blank\">Migration Guide</a> for each major will list these removals and document an upgrade path for them.</p>\n<h2 id=\"experimental-features\" tabindex=\"-1\">Experimental Features </h2>\n<p>Some features are marked as experimental when released in a stable version of Vite. Experimental features allow us to gather real-world experience to influence their final design. The goal is to let users provide feedback by testing them in production. Experimental features themselves are considered unstable, and should only be used in a controlled manner. These features may change between Minors, so users must pin their Vite version when they rely on them. We will create <a href=\"https://github.com/vitejs/vite/discussions/categories/feedback?discussions_q=is%3Aopen+label%3Aexperimental+category%3AFeedback\" target=\"_blank\" rel=\"noreferrer\">a GitHub discussion</a> for each experimental feature.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/releases\" class=\"_attribution-link\">https://vite.dev/releases</a>\n  </p>\n</div>\n","guide/index":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/index.md for this page in Markdown format</div>\n<h1 id=\"getting-started\" tabindex=\"-1\">Getting Started </h1>\n<h2 id=\"overview\" tabindex=\"-1\">Overview </h2>\n<p>Vite (French word for \"quick\", pronounced <code>/vit/</code>, like \"veet\") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:</p>\n<ul>\n<li><p>A dev server that provides <a href=\"features\">rich feature enhancements</a> over <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\" target=\"_blank\" rel=\"noreferrer\">native ES modules</a>, for example extremely fast <a href=\"features#hot-module-replacement\">Hot Module Replacement (HMR)</a>.</p></li>\n<li><p>A build command that bundles your code with <a href=\"https://rollupjs.org\" target=\"_blank\" rel=\"noreferrer\">Rollup</a>, pre-configured to output highly optimized static assets for production.</p></li>\n</ul>\n<p>Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the <a href=\"features\">Features Guide</a>. Support for frameworks or integration with other tools is possible through <a href=\"using-plugins\">Plugins</a>. The <a href=\"../config/index\">Config Section</a> explains how to adapt Vite to your project if needed.</p>\n<p>Vite is also highly extensible via its <a href=\"api-plugin\">Plugin API</a> and <a href=\"api-javascript\">JavaScript API</a> with full typing support.</p>\n<p>You can learn more about the rationale behind the project in the <a href=\"why\">Why Vite</a> section.</p>\n<h2 id=\"browser-support\" tabindex=\"-1\">Browser Support </h2>\n<p>During development, Vite assumes that a modern browser is used. This means the browser supports most of the latest JavaScript and CSS features. For that reason, Vite sets <a href=\"https://esbuild.github.io/api/#target\" target=\"_blank\" rel=\"noreferrer\"><code>esnext</code> as the transform target</a>. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code. Vite injects some runtime code to make the development server work. These code use features included in <a href=\"https://web-platform-dx.github.io/web-features/\" target=\"_blank\" rel=\"noreferrer\">Baseline</a> Newly Available at the time of each major release (2025-05-01 for this major).</p>\n<p>For production builds, Vite by default targets <a href=\"https://web-platform-dx.github.io/web-features/\" target=\"_blank\" rel=\"noreferrer\">Baseline</a> Widely Available browsers. These are browsers that were released at least 2.5 years ago. The target can be lowered via configuration. Additionally, legacy browsers can be supported via the official <a href=\"https://github.com/vitejs/vite/tree/main/packages/plugin-legacy\" target=\"_blank\" rel=\"noreferrer\">@vitejs/plugin-legacy</a>. See the <a href=\"build\">Building for Production</a> section for more details.</p>\n<h2 id=\"trying-vite-online\" tabindex=\"-1\">Trying Vite Online </h2>\n<p>You can try Vite online on <a href=\"https://vite.new/\" target=\"_blank\" rel=\"noreferrer\">StackBlitz</a>. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to <code>vite.new/{template}</code> to select which framework to use.</p>\n<p>The supported template presets are:</p>\n<table tabindex=\"0\">\n<thead><tr>\n<th style=\"text-align:center;\">JavaScript</th>\n<th style=\"text-align:center;\">TypeScript</th>\n</tr></thead>\n<tbody>\n<tr>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/vanilla\" target=\"_blank\" rel=\"noreferrer\">vanilla</a></td>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/vanilla-ts\" target=\"_blank\" rel=\"noreferrer\">vanilla-ts</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/vue\" target=\"_blank\" rel=\"noreferrer\">vue</a></td>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/vue-ts\" target=\"_blank\" rel=\"noreferrer\">vue-ts</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/react\" target=\"_blank\" rel=\"noreferrer\">react</a></td>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/react-ts\" target=\"_blank\" rel=\"noreferrer\">react-ts</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/preact\" target=\"_blank\" rel=\"noreferrer\">preact</a></td>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/preact-ts\" target=\"_blank\" rel=\"noreferrer\">preact-ts</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/lit\" target=\"_blank\" rel=\"noreferrer\">lit</a></td>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/lit-ts\" target=\"_blank\" rel=\"noreferrer\">lit-ts</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/svelte\" target=\"_blank\" rel=\"noreferrer\">svelte</a></td>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/svelte-ts\" target=\"_blank\" rel=\"noreferrer\">svelte-ts</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/solid\" target=\"_blank\" rel=\"noreferrer\">solid</a></td>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/solid-ts\" target=\"_blank\" rel=\"noreferrer\">solid-ts</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/qwik\" target=\"_blank\" rel=\"noreferrer\">qwik</a></td>\n<td style=\"text-align:center;\"><a href=\"https://vite.new/qwik-ts\" target=\"_blank\" rel=\"noreferrer\">qwik-ts</a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"scaffolding-your-first-vite-project\" tabindex=\"-1\">Scaffolding Your First Vite Project </h2>\n<div class=\"vp-code-group\">\n<div class=\"tabs\">\n<input type=\"radio\" name=\"group-131\" id=\"tab-132\" checked><label data-title=\"npm\" for=\"tab-132\">npm</label><input type=\"radio\" name=\"group-131\" id=\"tab-133\"><label data-title=\"Yarn\" for=\"tab-133\">Yarn</label><input type=\"radio\" name=\"group-131\" id=\"tab-134\"><label data-title=\"pnpm\" for=\"tab-134\">pnpm</label><input type=\"radio\" name=\"group-131\" id=\"tab-135\"><label data-title=\"Bun\" for=\"tab-135\">Bun</label><input type=\"radio\" name=\"group-131\" id=\"tab-136\"><label data-title=\"Deno\" for=\"tab-136\">Deno</label>\n</div>\n<div class=\"blocks\">\n<div class=\"language-bash active\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ npm create vite@latest</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ yarn create vite</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ pnpm create vite</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ bun create vite</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ deno init --npm vite</pre>\n</div>\n</div>\n</div>\n<p>Then follow the prompts!</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Compatibility Note</strong><p>Vite requires <a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noreferrer\">Node.js</a> version 20.19+, 22.12+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.</p>\n</div>\n<div class=\"details custom-block\">\n<summary>Using create vite with command line options</summary><p>You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:</p>\n<div class=\"vp-code-group\">\n<div class=\"tabs\">\n<input type=\"radio\" name=\"group-150\" id=\"tab-151\" checked><label data-title=\"npm\" for=\"tab-151\">npm</label><input type=\"radio\" name=\"group-150\" id=\"tab-152\"><label data-title=\"Yarn\" for=\"tab-152\">Yarn</label><input type=\"radio\" name=\"group-150\" id=\"tab-153\"><label data-title=\"pnpm\" for=\"tab-153\">pnpm</label><input type=\"radio\" name=\"group-150\" id=\"tab-154\"><label data-title=\"Bun\" for=\"tab-154\">Bun</label><input type=\"radio\" name=\"group-150\" id=\"tab-155\"><label data-title=\"Deno\" for=\"tab-155\">Deno</label>\n</div>\n<div class=\"blocks\">\n<div class=\"language-bash active\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\"># npm 7+, extra double-dash is needed:\n$ npm create vite@latest my-vue-app -- --template vue</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ yarn create vite my-vue-app --template vue</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ pnpm create vite my-vue-app --template vue</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ bun create vite my-vue-app --template vue</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ deno init --npm vite my-vue-app --template vue</pre>\n</div>\n</div>\n</div>\n<p>See <a href=\"https://github.com/vitejs/vite/tree/main/packages/create-vite\" target=\"_blank\" rel=\"noreferrer\">create-vite</a> for more details on each supported template: <code>vanilla</code>, <code>vanilla-ts</code>, <code>vue</code>, <code>vue-ts</code>, <code>react</code>, <code>react-ts</code>, <code>react-swc</code>, <code>react-swc-ts</code>, <code>preact</code>, <code>preact-ts</code>, <code>lit</code>, <code>lit-ts</code>, <code>svelte</code>, <code>svelte-ts</code>, <code>solid</code>, <code>solid-ts</code>, <code>qwik</code>, <code>qwik-ts</code>.</p>\n<p>You can use <code>.</code> for the project name to scaffold in the current directory.</p>\n</div>\n<h2 id=\"community-templates\" tabindex=\"-1\">Community Templates </h2>\n<p>create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for <a href=\"https://github.com/vitejs/awesome-vite#templates\" target=\"_blank\" rel=\"noreferrer\">community maintained templates</a> that include other tools or target different frameworks.</p>\n<p>For a template at <code>https://github.com/user/project</code>, you can try it out online using <code>https://github.stackblitz.com/user/project</code> (adding <code>.stackblitz</code> after <code>github</code> to the URL of the project).</p>\n<p>You can also use a tool like <a href=\"https://github.com/Rich-Harris/degit\" target=\"_blank\" rel=\"noreferrer\">degit</a> to scaffold your project with one of the templates. Assuming the project is on GitHub and uses <code>main</code> as the default branch, you can create a local copy using:</p>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">npx degit user/project#main my-project\ncd my-project\n\nnpm install\nnpm run dev</pre>\n</div>\n<h2 id=\"manual-installation\" tabindex=\"-1\">Manual Installation </h2>\n<p>In your project, you can install the <code>vite</code> CLI using:</p>\n<div class=\"vp-code-group\">\n<div class=\"tabs\">\n<input type=\"radio\" name=\"group-183\" id=\"tab-184\" checked><label data-title=\"npm\" for=\"tab-184\">npm</label><input type=\"radio\" name=\"group-183\" id=\"tab-185\"><label data-title=\"Yarn\" for=\"tab-185\">Yarn</label><input type=\"radio\" name=\"group-183\" id=\"tab-186\"><label data-title=\"pnpm\" for=\"tab-186\">pnpm</label><input type=\"radio\" name=\"group-183\" id=\"tab-187\"><label data-title=\"Bun\" for=\"tab-187\">Bun</label><input type=\"radio\" name=\"group-183\" id=\"tab-188\"><label data-title=\"Deno\" for=\"tab-188\">Deno</label>\n</div>\n<div class=\"blocks\">\n<div class=\"language-bash active\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ npm install -D vite</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ yarn add -D vite</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ pnpm add -D vite</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ bun add -D vite</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ deno add -D npm:vite</pre>\n</div>\n</div>\n</div>\n<p>And create an <code>index.html</code> file like this:</p>\n<div class=\"language-html\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">&lt;p&gt;Hello Vite!&lt;/p&gt;</pre>\n</div>\n<p>Then run the appropriate CLI command in your terminal:</p>\n<div class=\"vp-code-group\">\n<div class=\"tabs\">\n<input type=\"radio\" name=\"group-197\" id=\"tab-198\" checked><label data-title=\"npm\" for=\"tab-198\">npm</label><input type=\"radio\" name=\"group-197\" id=\"tab-199\"><label data-title=\"Yarn\" for=\"tab-199\">Yarn</label><input type=\"radio\" name=\"group-197\" id=\"tab-200\"><label data-title=\"pnpm\" for=\"tab-200\">pnpm</label><input type=\"radio\" name=\"group-197\" id=\"tab-201\"><label data-title=\"Bun\" for=\"tab-201\">Bun</label><input type=\"radio\" name=\"group-197\" id=\"tab-202\"><label data-title=\"Deno\" for=\"tab-202\">Deno</label>\n</div>\n<div class=\"blocks\">\n<div class=\"language-bash active\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ npx vite</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ yarn vite</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ pnpm vite</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ bunx vite</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ deno run -A npm:vite</pre>\n</div>\n</div>\n</div>\n<p>The <code>index.html</code> will be served on <code>http://localhost:5173</code>.</p>\n<h2 id=\"index-html-and-project-root\" tabindex=\"-1\">\n<code>index.html</code> and Project Root </h2>\n<p>One thing you may have noticed is that in a Vite project, <code>index.html</code> is front-and-central instead of being tucked away inside <code>public</code>. This is intentional: during development Vite is a server, and <code>index.html</code> is the entry point to your application.</p>\n<p>Vite treats <code>index.html</code> as source code and part of the module graph. It resolves <code>&lt;script type=\"module\" src=\"...\"&gt;</code> that references your JavaScript source code. Even inline <code>&lt;script type=\"module\"&gt;</code> and CSS referenced via <code>&lt;link href&gt;</code> also enjoy Vite-specific features. In addition, URLs inside <code>index.html</code> are automatically rebased so there's no need for special <code>%PUBLIC_URL%</code> placeholders.</p>\n<p>Similar to static http servers, Vite has the concept of a \"root directory\" which your files are served from. You will see it referenced as <code>&lt;root&gt;</code> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.</p>\n<p>Vite also supports <a href=\"build#multi-page-app\">multi-page apps</a> with multiple <code>.html</code> entry points.</p>\n<h4 id=\"specifying-alternative-root\" tabindex=\"-1\">Specifying Alternative Root </h4>\n<p>Running <code>vite</code> starts the dev server using the current working directory as root. You can specify an alternative root with <code>vite serve some/sub/dir</code>. Note that Vite will also resolve <a href=\"../config/index#configuring-vite\">its config file (i.e. <code>vite.config.js</code>)</a> inside the project root, so you'll need to move it if the root is changed.</p>\n<h2 id=\"command-line-interface\" tabindex=\"-1\">Command Line Interface </h2>\n<p>In a project where Vite is installed, you can use the <code>vite</code> binary in your npm scripts, or run it directly with <code>npx vite</code>. Here are the default npm scripts in a scaffolded Vite project:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"package.json\">package.json</span></div>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"scripts\": {\n    \"dev\": \"vite\", // start dev server, aliases: `vite dev`, `vite serve`\n    \"build\": \"vite build\", // build for production\n    \"preview\": \"vite preview\" // locally preview production build\n  }\n}</pre>\n</div>\n</div>\n<p>You can specify additional CLI options like <code>--port</code> or <code>--open</code>. For a full list of CLI options, run <code>npx vite --help</code> in your project.</p>\n<p>Learn more about the <a href=\"cli\">Command Line Interface</a></p>\n<h2 id=\"using-unreleased-commits\" tabindex=\"-1\">Using Unreleased Commits </h2>\n<p>If you can't wait for a new release to test the latest features, you can install a specific commit of Vite with <a href=\"https://pkg.pr.new\" target=\"_blank\" rel=\"noreferrer\">https://pkg.pr.new</a>:</p>\n<div class=\"vp-code-group\">\n<div class=\"tabs\">\n<input type=\"radio\" name=\"group-248\" id=\"tab-249\" checked><label data-title=\"npm\" for=\"tab-249\">npm</label><input type=\"radio\" name=\"group-248\" id=\"tab-250\"><label data-title=\"Yarn\" for=\"tab-250\">Yarn</label><input type=\"radio\" name=\"group-248\" id=\"tab-251\"><label data-title=\"pnpm\" for=\"tab-251\">pnpm</label><input type=\"radio\" name=\"group-248\" id=\"tab-252\"><label data-title=\"Bun\" for=\"tab-252\">Bun</label>\n</div>\n<div class=\"blocks\">\n<div class=\"language-bash active\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ npm install -D https://pkg.pr.new/vite@SHA</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ yarn add -D https://pkg.pr.new/vite@SHA</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ pnpm add -D https://pkg.pr.new/vite@SHA</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ bun add -D https://pkg.pr.new/vite@SHA</pre>\n</div>\n</div>\n</div>\n<p>Replace <code>SHA</code> with any of <a href=\"https://github.com/vitejs/vite/commits/main/\" target=\"_blank\" rel=\"noreferrer\">Vite's commit SHAs</a>. Note that only commits within the last month will work, as older commit releases are purged.</p>\n<p>Alternatively, you can also clone the <a href=\"https://github.com/vitejs/vite\" target=\"_blank\" rel=\"noreferrer\">vite repo</a> to your local machine and then build and link it yourself (<a href=\"https://pnpm.io/\" target=\"_blank\" rel=\"noreferrer\">pnpm</a> is required):</p>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">git clone https://github.com/vitejs/vite.git\ncd vite\npnpm install\ncd packages/vite\npnpm run build\npnpm link --global # use your preferred package manager for this step</pre>\n</div>\n<p>Then go to your Vite based project and run <code>pnpm link --global vite</code> (or the package manager that you used to link <code>vite</code> globally). Now restart the development server to ride on the bleeding edge!</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Dependencies using Vite</strong><p>To replace the Vite version used by dependencies transitively, you should use <a href=\"https://docs.npmjs.com/cli/v11/configuring-npm/package-json#overrides\" target=\"_blank\" rel=\"noreferrer\">npm overrides</a> or <a href=\"https://pnpm.io/9.x/package_json#pnpmoverrides\" target=\"_blank\" rel=\"noreferrer\">pnpm overrides</a>.</p>\n</div>\n<h2 id=\"community\" tabindex=\"-1\">Community </h2>\n<p>If you have questions or need help, reach out to the community at <a href=\"https://chat.vite.dev\" target=\"_blank\" rel=\"noreferrer\">Discord</a> and <a href=\"https://github.com/vitejs/vite/discussions\" target=\"_blank\" rel=\"noreferrer\">GitHub Discussions</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/\" class=\"_attribution-link\">https://vite.dev/guide/</a>\n  </p>\n</div>\n","guide/cli":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/cli.md for this page in Markdown format</div>\n<h1 id=\"command-line-interface\" tabindex=\"-1\">Command Line Interface </h1>\n<h2 id=\"dev-server\" tabindex=\"-1\">Dev server </h2>\n<h3 id=\"vite\" tabindex=\"-1\">\n<code>vite</code> </h3>\n<p>Start Vite dev server in the current directory. <code>vite dev</code> and <code>vite serve</code> are aliases for <code>vite</code>.</p>\n<h4 id=\"usage\" tabindex=\"-1\">Usage </h4>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">vite [root]</pre>\n</div>\n<h4 id=\"options\" tabindex=\"-1\">Options </h4>\n<table tabindex=\"0\">\n<thead><tr>\n<th>Options</th>\n<th></th>\n</tr></thead>\n<tbody>\n<tr>\n<td><code>--host [host]</code></td>\n<td>Specify hostname (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--port &lt;port&gt;</code></td>\n<td>Specify port (<code>number</code>)</td>\n</tr>\n<tr>\n<td><code>--open [path]</code></td>\n<td>Open browser on startup (<code>boolean | string</code>)</td>\n</tr>\n<tr>\n<td><code>--cors</code></td>\n<td>Enable CORS (<code>boolean</code>)</td>\n</tr>\n<tr>\n<td><code>--strictPort</code></td>\n<td>Exit if specified port is already in use (<code>boolean</code>)</td>\n</tr>\n<tr>\n<td><code>--force</code></td>\n<td>Force the optimizer to ignore the cache and re-bundle (<code>boolean</code>)</td>\n</tr>\n<tr>\n<td><code>-c, --config &lt;file&gt;</code></td>\n<td>Use specified config file (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--base &lt;path&gt;</code></td>\n<td>Public base path (default: <code>/</code>) (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-l, --logLevel &lt;level&gt;</code></td>\n<td>info | warn | error | silent (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--clearScreen</code></td>\n<td>Allow/disable clear screen when logging (<code>boolean</code>)</td>\n</tr>\n<tr>\n<td><code>--configLoader &lt;loader&gt;</code></td>\n<td>Use <code>bundle</code> to bundle the config with esbuild, or <code>runner</code> (experimental) to process it on the fly, or <code>native</code> (experimental) to load using the native runtime (default: <code>bundle</code>)</td>\n</tr>\n<tr>\n<td><code>--profile</code></td>\n<td>Start built-in Node.js inspector (check <a href=\"troubleshooting#performance-bottlenecks\">Performance bottlenecks</a>)</td>\n</tr>\n<tr>\n<td><code>-d, --debug [feat]</code></td>\n<td>Show debug logs (<code>string | boolean</code>)</td>\n</tr>\n<tr>\n<td><code>-f, --filter &lt;filter&gt;</code></td>\n<td>Filter debug logs (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-m, --mode &lt;mode&gt;</code></td>\n<td>Set env mode (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-h, --help</code></td>\n<td>Display available CLI options</td>\n</tr>\n<tr>\n<td><code>-v, --version</code></td>\n<td>Display version number</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"build\" tabindex=\"-1\">Build </h2>\n<h3 id=\"vite-build\" tabindex=\"-1\">\n<code>vite build</code> </h3>\n<p>Build for production.</p>\n<h4 id=\"usage-1\" tabindex=\"-1\">Usage </h4>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">vite build [root]</pre>\n</div>\n<h4 id=\"options-1\" tabindex=\"-1\">Options </h4>\n<table tabindex=\"0\">\n<thead><tr>\n<th>Options</th>\n<th></th>\n</tr></thead>\n<tbody>\n<tr>\n<td><code>--target &lt;target&gt;</code></td>\n<td>Transpile target (default: <code>\"modules\"</code>) (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--outDir &lt;dir&gt;</code></td>\n<td>Output directory (default: <code>dist</code>) (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--assetsDir &lt;dir&gt;</code></td>\n<td>Directory under outDir to place assets in (default: <code>\"assets\"</code>) (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--assetsInlineLimit &lt;number&gt;</code></td>\n<td>Static asset base64 inline threshold in bytes (default: <code>4096</code>) (<code>number</code>)</td>\n</tr>\n<tr>\n<td><code>--ssr [entry]</code></td>\n<td>Build specified entry for server-side rendering (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--sourcemap [output]</code></td>\n<td>Output source maps for build (default: <code>false</code>) (<code>boolean | \"inline\" | \"hidden\"</code>)</td>\n</tr>\n<tr>\n<td><code>--minify [minifier]</code></td>\n<td>Enable/disable minification, or specify minifier to use (default: <code>\"esbuild\"</code>) (<code>boolean | \"terser\" | \"esbuild\"</code>)</td>\n</tr>\n<tr>\n<td><code>--manifest [name]</code></td>\n<td>Emit build manifest json (<code>boolean | string</code>)</td>\n</tr>\n<tr>\n<td><code>--ssrManifest [name]</code></td>\n<td>Emit ssr manifest json (<code>boolean | string</code>)</td>\n</tr>\n<tr>\n<td><code>--emptyOutDir</code></td>\n<td>Force empty outDir when it's outside of root (<code>boolean</code>)</td>\n</tr>\n<tr>\n<td><code>-w, --watch</code></td>\n<td>Rebuilds when modules have changed on disk (<code>boolean</code>)</td>\n</tr>\n<tr>\n<td><code>-c, --config &lt;file&gt;</code></td>\n<td>Use specified config file (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--base &lt;path&gt;</code></td>\n<td>Public base path (default: <code>/</code>) (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-l, --logLevel &lt;level&gt;</code></td>\n<td>Info | warn | error | silent (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--clearScreen</code></td>\n<td>Allow/disable clear screen when logging (<code>boolean</code>)</td>\n</tr>\n<tr>\n<td><code>--configLoader &lt;loader&gt;</code></td>\n<td>Use <code>bundle</code> to bundle the config with esbuild or <code>runner</code> (experimental) to process it on the fly (default: <code>bundle</code>)</td>\n</tr>\n<tr>\n<td><code>--profile</code></td>\n<td>Start built-in Node.js inspector (check <a href=\"troubleshooting#performance-bottlenecks\">Performance bottlenecks</a>)</td>\n</tr>\n<tr>\n<td><code>-d, --debug [feat]</code></td>\n<td>Show debug logs (<code>string | boolean</code>)</td>\n</tr>\n<tr>\n<td><code>-f, --filter &lt;filter&gt;</code></td>\n<td>Filter debug logs (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-m, --mode &lt;mode&gt;</code></td>\n<td>Set env mode (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-h, --help</code></td>\n<td>Display available CLI options</td>\n</tr>\n<tr>\n<td><code>--app</code></td>\n<td>Build all environments, same as <code>builder: {}</code> (<code>boolean</code>, experimental)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"others\" tabindex=\"-1\">Others </h2>\n<h3 id=\"vite-optimize\" tabindex=\"-1\">\n<code>vite optimize</code> </h3>\n<p>Pre-bundle dependencies.</p>\n<p><strong>Deprecated</strong>: the pre-bundle process runs automatically and does not need to be called.</p>\n<h4 id=\"usage-2\" tabindex=\"-1\">Usage </h4>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">vite optimize [root]</pre>\n</div>\n<h4 id=\"options-2\" tabindex=\"-1\">Options </h4>\n<table tabindex=\"0\">\n<thead><tr>\n<th>Options</th>\n<th></th>\n</tr></thead>\n<tbody>\n<tr>\n<td><code>--force</code></td>\n<td>Force the optimizer to ignore the cache and re-bundle (<code>boolean</code>)</td>\n</tr>\n<tr>\n<td><code>-c, --config &lt;file&gt;</code></td>\n<td>Use specified config file (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--base &lt;path&gt;</code></td>\n<td>Public base path (default: <code>/</code>) (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-l, --logLevel &lt;level&gt;</code></td>\n<td>Info | warn | error | silent (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--clearScreen</code></td>\n<td>Allow/disable clear screen when logging (<code>boolean</code>)</td>\n</tr>\n<tr>\n<td><code>--configLoader &lt;loader&gt;</code></td>\n<td>Use <code>bundle</code> to bundle the config with esbuild or <code>runner</code> (experimental) to process it on the fly (default: <code>bundle</code>)</td>\n</tr>\n<tr>\n<td><code>-d, --debug [feat]</code></td>\n<td>Show debug logs (<code>string | boolean</code>)</td>\n</tr>\n<tr>\n<td><code>-f, --filter &lt;filter&gt;</code></td>\n<td>Filter debug logs (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-m, --mode &lt;mode&gt;</code></td>\n<td>Set env mode (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-h, --help</code></td>\n<td>Display available CLI options</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"vite-preview\" tabindex=\"-1\">\n<code>vite preview</code> </h3>\n<p>Locally preview the production build. Do not use this as a production server as it's not designed for it.</p>\n<h4 id=\"usage-3\" tabindex=\"-1\">Usage </h4>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">vite preview [root]</pre>\n</div>\n<h4 id=\"options-3\" tabindex=\"-1\">Options </h4>\n<table tabindex=\"0\">\n<thead><tr>\n<th>Options</th>\n<th></th>\n</tr></thead>\n<tbody>\n<tr>\n<td><code>--host [host]</code></td>\n<td>Specify hostname (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--port &lt;port&gt;</code></td>\n<td>Specify port (<code>number</code>)</td>\n</tr>\n<tr>\n<td><code>--strictPort</code></td>\n<td>Exit if specified port is already in use (<code>boolean</code>)</td>\n</tr>\n<tr>\n<td><code>--open [path]</code></td>\n<td>Open browser on startup (<code>boolean | string</code>)</td>\n</tr>\n<tr>\n<td><code>--outDir &lt;dir&gt;</code></td>\n<td>Output directory (default: <code>dist</code>)(<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-c, --config &lt;file&gt;</code></td>\n<td>Use specified config file (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--base &lt;path&gt;</code></td>\n<td>Public base path (default: <code>/</code>) (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-l, --logLevel &lt;level&gt;</code></td>\n<td>Info | warn | error | silent (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>--clearScreen</code></td>\n<td>Allow/disable clear screen when logging (<code>boolean</code>)</td>\n</tr>\n<tr>\n<td><code>--configLoader &lt;loader&gt;</code></td>\n<td>Use <code>bundle</code> to bundle the config with esbuild or <code>runner</code> (experimental) to process it on the fly (default: <code>bundle</code>)</td>\n</tr>\n<tr>\n<td><code>-d, --debug [feat]</code></td>\n<td>Show debug logs (<code>string | boolean</code>)</td>\n</tr>\n<tr>\n<td><code>-f, --filter &lt;filter&gt;</code></td>\n<td>Filter debug logs (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-m, --mode &lt;mode&gt;</code></td>\n<td>Set env mode (<code>string</code>)</td>\n</tr>\n<tr>\n<td><code>-h, --help</code></td>\n<td>Display available CLI options</td>\n</tr>\n</tbody>\n</table><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/cli\" class=\"_attribution-link\">https://vite.dev/guide/cli</a>\n  </p>\n</div>\n","config/preview-options":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /config/preview-options.md for this page in Markdown format</div>\n<h1 id=\"preview-options\" tabindex=\"-1\">Preview Options </h1>\n<p>Unless noted, the options in this section are only applied to preview.</p>\n<h2 id=\"preview-host\" tabindex=\"-1\">preview.host </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string | boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <a href=\"server-options#server-host\"><code>server.host</code></a>\n</li>\n</ul>\n<p>Specify which IP addresses the server should listen on. Set this to <code>0.0.0.0</code> or <code>true</code> to listen on all addresses, including LAN and public addresses.</p>\n<p>This can be set via the CLI using <code>--host 0.0.0.0</code> or <code>--host</code>.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p>There are cases when other servers might respond instead of Vite. See <a href=\"server-options#server-host\"><code>server.host</code></a> for more details.</p>\n</div>\n<h2 id=\"preview-allowedhosts\" tabindex=\"-1\">preview.allowedHosts </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string | true</code>\n</li>\n<li>\n<strong>Default:</strong> <a href=\"server-options#server-allowedhosts\"><code>server.allowedHosts</code></a>\n</li>\n</ul>\n<p>The hostnames that Vite is allowed to respond to.</p>\n<p>See <a href=\"server-options#server-allowedhosts\"><code>server.allowedHosts</code></a> for more details.</p>\n<h2 id=\"preview-port\" tabindex=\"-1\">preview.port </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>number</code>\n</li>\n<li>\n<strong>Default:</strong> <code>4173</code>\n</li>\n</ul>\n<p>Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on.</p>\n<p><strong>Example:</strong></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  server: {\n    port: 3030,\n  },\n  preview: {\n    port: 8080,\n  },\n})</pre>\n</div>\n<h2 id=\"preview-strictport\" tabindex=\"-1\">preview.strictPort </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <a href=\"server-options#server-strictport\"><code>server.strictPort</code></a>\n</li>\n</ul>\n<p>Set to <code>true</code> to exit if port is already in use, instead of automatically trying the next available port.</p>\n<h2 id=\"preview-https\" tabindex=\"-1\">preview.https </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>https.ServerOptions</code>\n</li>\n<li>\n<strong>Default:</strong> <a href=\"server-options#server-https\"><code>server.https</code></a>\n</li>\n</ul>\n<p>Enable TLS + HTTP/2.</p>\n<p>See <a href=\"server-options#server-https\"><code>server.https</code></a> for more details.</p>\n<h2 id=\"preview-open\" tabindex=\"-1\">preview.open </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean | string</code>\n</li>\n<li>\n<strong>Default:</strong> <a href=\"server-options#server-open\"><code>server.open</code></a>\n</li>\n</ul>\n<p>Automatically open the app in the browser on server start. When the value is a string, it will be used as the URL's pathname. If you want to open the server in a specific browser you like, you can set the env <code>process.env.BROWSER</code> (e.g. <code>firefox</code>). You can also set <code>process.env.BROWSER_ARGS</code> to pass additional arguments (e.g. <code>--incognito</code>).</p>\n<p><code>BROWSER</code> and <code>BROWSER_ARGS</code> are also special environment variables you can set in the <code>.env</code> file to configure it. See <a href=\"https://github.com/sindresorhus/open#app\" target=\"_blank\" rel=\"noreferrer\">the <code>open</code> package</a> for more details.</p>\n<h2 id=\"preview-proxy\" tabindex=\"-1\">preview.proxy </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>Record&lt;string, string | ProxyOptions&gt;</code>\n</li>\n<li>\n<strong>Default:</strong> <a href=\"server-options#server-proxy\"><code>server.proxy</code></a>\n</li>\n</ul>\n<p>Configure custom proxy rules for the preview server. Expects an object of <code>{ key: options }</code> pairs. If the key starts with <code>^</code>, it will be interpreted as a <code>RegExp</code>. The <code>configure</code> option can be used to access the proxy instance.</p>\n<p>Uses <a href=\"https://github.com/sagemathinc/http-proxy-3\" target=\"_blank\" rel=\"noreferrer\"><code>http-proxy-3</code></a>. Full options <a href=\"https://github.com/sagemathinc/http-proxy-3#options\" target=\"_blank\" rel=\"noreferrer\">here</a>.</p>\n<h2 id=\"preview-cors\" tabindex=\"-1\">preview.cors </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean | CorsOptions</code>\n</li>\n<li>\n<strong>Default:</strong> <a href=\"server-options#server-cors\"><code>server.cors</code></a>\n</li>\n</ul>\n<p>Configure CORS for the preview server.</p>\n<p>See <a href=\"server-options#server-cors\"><code>server.cors</code></a> for more details.</p>\n<h2 id=\"preview-headers\" tabindex=\"-1\">preview.headers </h2>\n<ul><li>\n<strong>Type:</strong> <code>OutgoingHttpHeaders</code>\n</li></ul>\n<p>Specify server response headers.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/config/preview-options\" class=\"_attribution-link\">https://vite.dev/config/preview-options</a>\n  </p>\n</div>\n","config/dep-optimization-options":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /config/dep-optimization-options.md for this page in Markdown format</div>\n<h1 id=\"dep-optimization-options\" tabindex=\"-1\">Dep Optimization Options </h1>\n<ul><li>\n<strong>Related:</strong> <a href=\"../guide/dep-pre-bundling\">Dependency Pre-Bundling</a>\n</li></ul>\n<p>Unless noted, the options in this section are only applied to the dependency optimizer, which is only used in dev.</p>\n<h2 id=\"optimizedeps-entries\" tabindex=\"-1\">optimizeDeps.entries <a href=\"../guide/api-environment#environments-configuration\" class=\"ignore-header\"><span class=\"VPBadge info\">non-inherit</span></a> </h2>\n<ul><li>\n<strong>Type:</strong> <code>string | string[]</code>\n</li></ul>\n<p>By default, Vite will crawl all your <code>.html</code> files to detect dependencies that need to be pre-bundled (ignoring <code>node_modules</code>, <code>build.outDir</code>, <code>__tests__</code> and <code>coverage</code>). If <code>build.rollupOptions.input</code> is specified, Vite will crawl those entry points instead.</p>\n<p>If neither of these fit your needs, you can specify custom entries using this option - the value should be a <a href=\"https://github.com/SuperchupuDev/tinyglobby\" target=\"_blank\" rel=\"noreferrer\"><code>tinyglobby</code> pattern</a> or array of patterns that are relative from Vite project root. This will overwrite default entries inference. Only <code>node_modules</code> and <code>build.outDir</code> folders will be ignored by default when <code>optimizeDeps.entries</code> is explicitly defined. If other folders need to be ignored, you can use an ignore pattern as part of the entries list, marked with an initial <code>!</code>. <code>node_modules</code> will not be ignored for patterns that explicitly include the string <code>node_modules</code>.</p>\n<h2 id=\"optimizedeps-exclude\" tabindex=\"-1\">optimizeDeps.exclude <a href=\"../guide/api-environment#environments-configuration\" class=\"ignore-header\"><span class=\"VPBadge info\">non-inherit</span></a> </h2>\n<ul><li>\n<strong>Type:</strong> <code>string[]</code>\n</li></ul>\n<p>Dependencies to exclude from pre-bundling.</p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">CommonJS</strong><p>CommonJS dependencies should not be excluded from optimization. If an ESM dependency is excluded from optimization, but has a nested CommonJS dependency, the CommonJS dependency should be added to <code>optimizeDeps.include</code>. Example:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  optimizeDeps: {\n    include: ['esm-dep &gt; cjs-dep'],\n  },\n})</pre>\n</div>\n</div>\n<h2 id=\"optimizedeps-include\" tabindex=\"-1\">optimizeDeps.include <a href=\"../guide/api-environment#environments-configuration\" class=\"ignore-header\"><span class=\"VPBadge info\">non-inherit</span></a> </h2>\n<ul><li>\n<strong>Type:</strong> <code>string[]</code>\n</li></ul>\n<p>By default, linked packages not inside <code>node_modules</code> are not pre-bundled. Use this option to force a linked package to be pre-bundled.</p>\n<p><strong>Experimental:</strong> If you're using a library with many deep imports, you can also specify a trailing glob pattern to pre-bundle all deep imports at once. This will avoid constantly pre-bundling whenever a new deep import is used. <a href=\"https://github.com/vitejs/vite/discussions/15833\" target=\"_blank\" rel=\"noreferrer\">Give Feedback</a>. For example:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  optimizeDeps: {\n    include: ['my-lib/components/**/*.vue'],\n  },\n})</pre>\n</div>\n<h2 id=\"optimizedeps-esbuildoptions\" tabindex=\"-1\">optimizeDeps.esbuildOptions <a href=\"../guide/api-environment#environments-configuration\" class=\"ignore-header\"><span class=\"VPBadge info\">non-inherit</span></a> </h2>\n<ul><li>\n<strong>Type:</strong> <a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys\" target=\"_blank\" rel=\"noreferrer\"><code>Omit</code></a><code>&lt;</code><a href=\"https://esbuild.github.io/api/#general-options\" target=\"_blank\" rel=\"noreferrer\"><code>EsbuildBuildOptions</code></a><code>, | 'bundle' | 'entryPoints' | 'external' | 'write' | 'watch' | 'outdir' | 'outfile' | 'outbase' | 'outExtension' | 'metafile'&gt;</code>\n</li></ul>\n<p>Options to pass to esbuild during the dep scanning and optimization.</p>\n<p>Certain options are omitted since changing them would not be compatible with Vite's dep optimization.</p>\n<ul>\n<li>\n<code>external</code> is also omitted, use Vite's <code>optimizeDeps.exclude</code> option</li>\n<li>\n<code>plugins</code> are merged with Vite's dep plugin</li>\n</ul>\n<h2 id=\"optimizedeps-force\" tabindex=\"-1\">optimizeDeps.force <a href=\"../guide/api-environment#environments-configuration\" class=\"ignore-header\"><span class=\"VPBadge info\">non-inherit</span></a> </h2>\n<ul><li>\n<strong>Type:</strong> <code>boolean</code>\n</li></ul>\n<p>Set to <code>true</code> to force dependency pre-bundling, ignoring previously cached optimized dependencies.</p>\n<h2 id=\"optimizedeps-nodiscovery\" tabindex=\"-1\">optimizeDeps.noDiscovery <a href=\"../guide/api-environment#environments-configuration\" class=\"ignore-header\"><span class=\"VPBadge info\">non-inherit</span></a> </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>false</code>\n</li>\n</ul>\n<p>When set to <code>true</code>, automatic dependency discovery will be disabled and only dependencies listed in <code>optimizeDeps.include</code> will be optimized. CJS-only dependencies must be present in <code>optimizeDeps.include</code> during dev.</p>\n<h2 id=\"optimizedeps-holduntilcrawlend\" tabindex=\"-1\">optimizeDeps.holdUntilCrawlEnd <a href=\"../guide/api-environment#environments-configuration\" class=\"ignore-header\"><span class=\"VPBadge info\">non-inherit</span></a> </h2>\n<ul>\n<li>\n<strong>Experimental:</strong> <a href=\"https://github.com/vitejs/vite/discussions/15834\" target=\"_blank\" rel=\"noreferrer\">Give Feedback</a>\n</li>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>true</code>\n</li>\n</ul>\n<p>When enabled, it will hold the first optimized deps results until all static imports are crawled on cold start. This avoids the need for full-page reloads when new dependencies are discovered and they trigger the generation of new common chunks. If all dependencies are found by the scanner plus the explicitly defined ones in <code>include</code>, it is better to disable this option to let the browser process more requests in parallel.</p>\n<h2 id=\"optimizedeps-disabled\" tabindex=\"-1\">optimizeDeps.disabled <a href=\"../guide/api-environment#environments-configuration\" class=\"ignore-header\"><span class=\"VPBadge info\">non-inherit</span></a> </h2>\n<ul>\n<li><strong>Deprecated</strong></li>\n<li>\n<strong>Experimental:</strong> <a href=\"https://github.com/vitejs/vite/discussions/13839\" target=\"_blank\" rel=\"noreferrer\">Give Feedback</a>\n</li>\n<li>\n<strong>Type:</strong> <code>boolean | 'build' | 'dev'</code>\n</li>\n<li>\n<strong>Default:</strong> <code>'build'</code>\n</li>\n</ul>\n<p>This option is deprecated. As of Vite 5.1, pre-bundling of dependencies during build have been removed. Setting <code>optimizeDeps.disabled</code> to <code>true</code> or <code>'dev'</code> disables the optimizer, and configured to <code>false</code> or <code>'build'</code> leaves the optimizer during dev enabled.</p>\n<p>To disable the optimizer completely, use <code>optimizeDeps.noDiscovery: true</code> to disallow automatic discovery of dependencies and leave <code>optimizeDeps.include</code> undefined or empty.</p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">WARNING</strong><p>Optimizing dependencies during build time was an <strong>experimental</strong> feature. Projects trying out this strategy also removed <code>@rollup/plugin-commonjs</code> using <code>build.commonjsOptions: { include: [] }</code>. If you did so, a warning will guide you to re-enable it to support CJS only packages while bundling.</p>\n</div>\n<h2 id=\"optimizedeps-needsinterop\" tabindex=\"-1\">optimizeDeps.needsInterop <a href=\"../guide/api-environment#environments-configuration\" class=\"ignore-header\"><span class=\"VPBadge info\">non-inherit</span></a> </h2>\n<ul>\n<li><strong>Experimental</strong></li>\n<li>\n<strong>Type:</strong> <code>string[]</code>\n</li>\n</ul>\n<p>Forces ESM interop when importing these dependencies. Vite is able to properly detect when a dependency needs interop, so this option isn't generally needed. However, different combinations of dependencies could cause some of them to be prebundled differently. Adding these packages to <code>needsInterop</code> can speed up cold start by avoiding full-page reloads. You'll receive a warning if this is the case for one of your dependencies, suggesting to add the package name to this array in your config.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/config/dep-optimization-options\" class=\"_attribution-link\">https://vite.dev/config/dep-optimization-options</a>\n  </p>\n</div>\n","guide/assets":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/assets.md for this page in Markdown format</div>\n<h1 id=\"static-asset-handling\" tabindex=\"-1\">Static Asset Handling </h1>\n<ul>\n<li>Related: <a href=\"build#public-base-path\">Public Base Path</a>\n</li>\n<li>Related: <a href=\"../config/shared-options#assetsinclude\"><code>assetsInclude</code> config option</a>\n</li>\n</ul>\n<h2 id=\"importing-asset-as-url\" tabindex=\"-1\">Importing Asset as URL </h2>\n<p>Importing a static asset will return the resolved public URL when it is served:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import imgUrl from './img.png'\ndocument.getElementById('hero-img').src = imgUrl</pre>\n</div>\n<p>For example, <code>imgUrl</code> will be <code>/src/img.png</code> during development, and become <code>/assets/img.2d8efhg.png</code> in the production build.</p>\n<p>The behavior is similar to webpack's <code>file-loader</code>. The difference is that the import can be either using absolute public paths (based on project root during dev) or relative paths.</p>\n<ul>\n<li><p><code>url()</code> references in CSS are handled the same way.</p></li>\n<li><p>If using the Vue plugin, asset references in Vue SFC templates are automatically converted into imports.</p></li>\n<li><p>Common image, media, and font filetypes are detected as assets automatically. You can extend the internal list using the <a href=\"../config/shared-options#assetsinclude\"><code>assetsInclude</code> option</a>.</p></li>\n<li><p>Referenced assets are included as part of the build assets graph, will get hashed file names, and can be processed by plugins for optimization.</p></li>\n<li><p>Assets smaller in bytes than the <a href=\"../config/build-options#build-assetsinlinelimit\"><code>assetsInlineLimit</code> option</a> will be inlined as base64 data URLs.</p></li>\n<li><p>Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent. To get inlining, make sure to download the file contents via Git LFS before building.</p></li>\n<li><p>TypeScript, by default, does not recognize static asset imports as valid modules. To fix this, include <a href=\"features#client-types\"><code>vite/client</code></a>.</p></li>\n</ul>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Inlining SVGs through <code>url()</code></strong><p>When passing a URL of SVG to a manually constructed <code>url()</code> by JS, the variable should be wrapped within double quotes.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import imgUrl from './img.svg'\ndocument.getElementById('hero-img').style.background = `url(\"${imgUrl}\")`</pre>\n</div>\n</div>\n<h3 id=\"explicit-url-imports\" tabindex=\"-1\">Explicit URL Imports </h3>\n<p>Assets that are not included in the internal list or in <code>assetsInclude</code>, can be explicitly imported as a URL using the <code>?url</code> suffix. This is useful, for example, to import <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CSS/paintWorklet_static\" target=\"_blank\" rel=\"noreferrer\">Houdini Paint Worklets</a>.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import workletURL from 'extra-scalloped-border/worklet.js?url'\nCSS.paintWorklet.addModule(workletURL)</pre>\n</div>\n<h3 id=\"explicit-inline-handling\" tabindex=\"-1\">Explicit Inline Handling </h3>\n<p>Assets can be explicitly imported with inlining or no inlining using the <code>?inline</code> or <code>?no-inline</code> suffix respectively.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import imgUrl1 from './img.svg?no-inline'\nimport imgUrl2 from './img.png?inline'</pre>\n</div>\n<h3 id=\"importing-asset-as-string\" tabindex=\"-1\">Importing Asset as String </h3>\n<p>Assets can be imported as strings using the <code>?raw</code> suffix.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import shaderString from './shader.glsl?raw'</pre>\n</div>\n<h3 id=\"importing-script-as-a-worker\" tabindex=\"-1\">Importing Script as a Worker </h3>\n<p>Scripts can be imported as web workers with the <code>?worker</code> or <code>?sharedworker</code> suffix.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// Separate chunk in the production build\nimport Worker from './shader.js?worker'\nconst worker = new Worker()</pre>\n</div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// sharedworker\nimport SharedWorker from './shader.js?sharedworker'\nconst sharedWorker = new SharedWorker()</pre>\n</div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// Inlined as base64 strings\nimport InlineWorker from './shader.js?worker&amp;inline'</pre>\n</div>\n<p>Check out the <a href=\"features#web-workers\">Web Worker section</a> for more details.</p>\n<h2 id=\"the-public-directory\" tabindex=\"-1\">The <code>public</code> Directory </h2>\n<p>If you have assets that are:</p>\n<ul>\n<li>Never referenced in source code (e.g. <code>robots.txt</code>)</li>\n<li>Must retain the exact same file name (without hashing)</li>\n<li>...or you simply don't want to have to import an asset first just to get its URL</li>\n</ul>\n<p>Then you can place the asset in a special <code>public</code> directory under your project root. Assets in this directory will be served at root path <code>/</code> during dev, and copied to the root of the dist directory as-is.</p>\n<p>The directory defaults to <code>&lt;root&gt;/public</code>, but can be configured via the <a href=\"../config/shared-options#publicdir\"><code>publicDir</code> option</a>.</p>\n<p>Note that you should always reference <code>public</code> assets using root absolute path - for example, <code>public/icon.png</code> should be referenced in source code as <code>/icon.png</code>.</p>\n<h2 id=\"new-url-url-import-meta-url\" tabindex=\"-1\">new URL(url, import.meta.url) </h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta\" target=\"_blank\" rel=\"noreferrer\">import.meta.url</a> is a native ESM feature that exposes the current module's URL. Combining it with the native <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL\" target=\"_blank\" rel=\"noreferrer\">URL constructor</a>, we can obtain the full, resolved URL of a static asset using relative path from a JavaScript module:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const imgUrl = new URL('./img.png', import.meta.url).href\n\ndocument.getElementById('hero-img').src = imgUrl</pre>\n</div>\n<p>This works natively in modern browsers - in fact, Vite doesn't need to process this code at all during development!</p>\n<p>This pattern also supports dynamic URLs via template literals:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function getImageUrl(name) {\n  // note that this does not include files in subdirectories\n  return new URL(`./dir/${name}.png`, import.meta.url).href\n}</pre>\n</div>\n<p>During the production build, Vite will perform necessary transforms so that the URLs still point to the correct location even after bundling and asset hashing. However, the URL string must be static so it can be analyzed, otherwise the code will be left as is, which can cause runtime errors if <code>build.target</code> does not support <code>import.meta.url</code></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// Vite will not transform this\nconst imgUrl = new URL(imagePath, import.meta.url).href</pre>\n</div>\n<div class=\"details custom-block\">\n<summary>How it works</summary><p>Vite will transform the <code>getImageUrl</code> function to:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import __img0png from './dir/img0.png'\nimport __img1png from './dir/img1.png'\n\nfunction getImageUrl(name) {\n  const modules = {\n    './dir/img0.png': __img0png,\n    './dir/img1.png': __img1png,\n  }\n  return new URL(modules[`./dir/${name}.png`], import.meta.url).href\n}</pre>\n</div>\n</div>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Does not work with SSR</strong><p>This pattern does not work if you are using Vite for Server-Side Rendering, because <code>import.meta.url</code> have different semantics in browsers vs. Node.js. The server bundle also cannot determine the client host URL ahead of time.</p>\n</div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/assets\" class=\"_attribution-link\">https://vite.dev/guide/assets</a>\n  </p>\n</div>\n","guide/env-and-mode":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/env-and-mode.md for this page in Markdown format</div>\n<h1 id=\"env-variables-and-modes\" tabindex=\"-1\">Env Variables and Modes </h1>\n<p>Vite exposes certain constants under the special <code>import.meta.env</code> object. These constants are defined as global variables during dev and statically replaced at build time to make tree-shaking effective.</p>\n<h2 id=\"built-in-constants\" tabindex=\"-1\">Built-in Constants </h2>\n<p>Some built-in constants are available in all cases:</p>\n<ul>\n<li><p><strong><code>import.meta.env.MODE</code></strong>: {string} the <a href=\"#modes\">mode</a> the app is running in.</p></li>\n<li><p><strong><code>import.meta.env.BASE_URL</code></strong>: {string} the base url the app is being served from. This is determined by the <a href=\"../config/shared-options#base\"><code>base</code> config option</a>.</p></li>\n<li><p><strong><code>import.meta.env.PROD</code></strong>: {boolean} whether the app is running in production (running the dev server with <code>NODE_ENV='production'</code> or running an app built with <code>NODE_ENV='production'</code>).</p></li>\n<li><p><strong><code>import.meta.env.DEV</code></strong>: {boolean} whether the app is running in development (always the opposite of <code>import.meta.env.PROD</code>)</p></li>\n<li><p><strong><code>import.meta.env.SSR</code></strong>: {boolean} whether the app is running in the <a href=\"ssr#conditional-logic\">server</a>.</p></li>\n</ul>\n<h2 id=\"env-variables\" tabindex=\"-1\">Env Variables </h2>\n<p>Vite exposes env variables under <code>import.meta.env</code> object as strings automatically.</p>\n<p>To prevent accidentally leaking env variables to the client, only variables prefixed with <code>VITE_</code> are exposed to your Vite-processed code. e.g. for the following env variables:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\".env\">.env</span></div>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">VITE_SOME_KEY=123\nDB_PASSWORD=foobar</pre>\n</div>\n</div>\n<p>Only <code>VITE_SOME_KEY</code> will be exposed as <code>import.meta.env.VITE_SOME_KEY</code> to your client source code, but <code>DB_PASSWORD</code> will not.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">console.log(import.meta.env.VITE_SOME_KEY) // \"123\"\nconsole.log(import.meta.env.DB_PASSWORD) // undefined</pre>\n</div>\n<p>If you want to customize the env variables prefix, see the <a href=\"../config/shared-options#envprefix\">envPrefix</a> option.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Env parsing</strong><p>As shown above, <code>VITE_SOME_KEY</code> is a number but returns a string when parsed. The same would also happen for boolean env variables. Make sure to convert to the desired type when using it in your code.</p>\n</div>\n<h3 id=\"env-files\" tabindex=\"-1\">\n<code>.env</code> Files </h3>\n<p>Vite uses <a href=\"https://github.com/motdotla/dotenv\" target=\"_blank\" rel=\"noreferrer\">dotenv</a> to load additional environment variables from the following files in your <a href=\"../config/shared-options#envdir\">environment directory</a>:</p>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">.env                # loaded in all cases\n.env.local          # loaded in all cases, ignored by git\n.env.[mode]         # only loaded in specified mode\n.env.[mode].local   # only loaded in specified mode, ignored by git</pre>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Env Loading Priorities</strong><p>An env file for a specific mode (e.g. <code>.env.production</code>) will take higher priority than a generic one (e.g. <code>.env</code>).</p>\n<p>Vite will always load <code>.env</code> and <code>.env.local</code> in addition to the mode-specific <code>.env.[mode]</code> file. Variables declared in mode-specific files will take precedence over those in generic files, but variables defined only in <code>.env</code> or <code>.env.local</code> will still be available in the environment.</p>\n<p>In addition, environment variables that already exist when Vite is executed have the highest priority and will not be overwritten by <code>.env</code> files. For example, when running <code>VITE_SOME_KEY=123 vite build</code>.</p>\n<p><code>.env</code> files are loaded at the start of Vite. Restart the server after making changes.</p>\n</div>\n<p>Also, Vite uses <a href=\"https://github.com/motdotla/dotenv-expand\" target=\"_blank\" rel=\"noreferrer\">dotenv-expand</a> to expand variables written in env files out of the box. To learn more about the syntax, check out <a href=\"https://github.com/motdotla/dotenv-expand#what-rules-does-the-expansion-engine-follow\" target=\"_blank\" rel=\"noreferrer\">their docs</a>.</p>\n<p>Note that if you want to use <code>$</code> inside your environment value, you have to escape it with <code>\\</code>.</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\".env\">.env</span></div>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">KEY=123\nNEW_KEY1=test$foo   # test\nNEW_KEY2=test\\$foo  # test$foo\nNEW_KEY3=test$KEY   # test123</pre>\n</div>\n</div>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">SECURITY NOTES</strong><ul>\n<li><p><code>.env.*.local</code> files are local-only and can contain sensitive variables. You should add <code>*.local</code> to your <code>.gitignore</code> to avoid them being checked into git.</p></li>\n<li><p>Since any variables exposed to your Vite source code will end up in your client bundle, <code>VITE_*</code> variables should <em>not</em> contain any sensitive information.</p></li>\n</ul>\n</div>\n<div class=\"details custom-block\">\n<summary>Expanding variables in reverse order</summary><p>Vite supports expanding variables in reverse order. For example, the <code>.env</code> below will be evaluated as <code>VITE_FOO=foobar</code>, <code>VITE_BAR=bar</code>.</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\".env\">.env</span></div>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">VITE_FOO=foo${VITE_BAR}\nVITE_BAR=bar</pre>\n</div>\n</div>\n<p>This does not work in shell scripts and other tools like <code>docker-compose</code>. That said, Vite supports this behavior as this has been supported by <code>dotenv-expand</code> for a long time and other tools in JavaScript ecosystem uses older versions that supports this behavior.</p>\n<p>To avoid interop issues, it is recommended to avoid relying on this behavior. Vite may start emitting warnings for this behavior in the future.</p>\n</div>\n<h2 id=\"intellisense-for-typescript\" tabindex=\"-1\">IntelliSense for TypeScript </h2>\n<p>By default, Vite provides type definitions for <code>import.meta.env</code> in <a href=\"https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts\" target=\"_blank\" rel=\"noreferrer\"><code>vite/client.d.ts</code></a>. While you can define more custom env variables in <code>.env.[mode]</code> files, you may want to get TypeScript IntelliSense for user-defined env variables that are prefixed with <code>VITE_</code>.</p>\n<p>To achieve this, you can create an <code>vite-env.d.ts</code> in <code>src</code> directory, then augment <code>ImportMetaEnv</code> like this:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite-env.d.ts\">vite-env.d.ts</span></div>\n<div class=\"language-typescript\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">/// &lt;reference types=\"vite/client\" /&gt;\n\ninterface ViteTypeOptions {\n  // By adding this line, you can make the type of ImportMetaEnv strict\n  // to disallow unknown keys.\n  // strictImportMetaEnv: unknown\n}\n\ninterface ImportMetaEnv {\n  readonly VITE_APP_TITLE: string\n  // more env variables...\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}</pre>\n</div>\n</div>\n<p>If your code relies on types from browser environments such as <a href=\"https://github.com/microsoft/TypeScript/blob/main/src/lib/dom.generated.d.ts\" target=\"_blank\" rel=\"noreferrer\">DOM</a> and <a href=\"https://github.com/microsoft/TypeScript/blob/main/src/lib/webworker.generated.d.ts\" target=\"_blank\" rel=\"noreferrer\">WebWorker</a>, you can update the <a href=\"https://www.typescriptlang.org/tsconfig#lib\" target=\"_blank\" rel=\"noreferrer\">lib</a> field in <code>tsconfig.json</code>.</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"tsconfig.json\">tsconfig.json</span></div>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"lib\": [\"WebWorker\"]\n}</pre>\n</div>\n</div>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Imports will break type augmentation</strong><p>If the <code>ImportMetaEnv</code> augmentation does not work, make sure you do not have any <code>import</code> statements in <code>vite-env.d.ts</code>. See the <a href=\"https://www.typescriptlang.org/docs/handbook/2/modules.html#how-javascript-modules-are-defined\" target=\"_blank\" rel=\"noreferrer\">TypeScript documentation</a> for more information.</p>\n</div>\n<h2 id=\"html-constant-replacement\" tabindex=\"-1\">HTML Constant Replacement </h2>\n<p>Vite also supports replacing constants in HTML files. Any properties in <code>import.meta.env</code> can be used in HTML files with a special <code>%CONST_NAME%</code> syntax:</p>\n<div class=\"language-html\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">&lt;h1&gt;Vite is running in %MODE%&lt;/h1&gt;\n&lt;p&gt;Using data from %VITE_API_URL%&lt;/p&gt;</pre>\n</div>\n<p>If the env doesn't exist in <code>import.meta.env</code>, e.g. <code>%NON_EXISTENT%</code>, it will be ignored and not replaced, unlike <code>import.meta.env.NON_EXISTENT</code> in JS where it's replaced as <code>undefined</code>.</p>\n<p>Given that Vite is used by many frameworks, it is intentionally unopinionated about complex replacements like conditionals. Vite can be extended using <a href=\"https://github.com/vitejs/awesome-vite#transformers\" target=\"_blank\" rel=\"noreferrer\">an existing userland plugin</a> or a custom plugin that implements the <a href=\"api-plugin#transformindexhtml\"><code>transformIndexHtml</code> hook</a>.</p>\n<h2 id=\"modes\" tabindex=\"-1\">Modes </h2>\n<p>By default, the dev server (<code>dev</code> command) runs in <code>development</code> mode and the <code>build</code> command runs in <code>production</code> mode.</p>\n<p>This means when running <code>vite build</code>, it will load the env variables from <code>.env.production</code> if there is one:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\".env.production\">.env.production</span></div>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">VITE_APP_TITLE=My App</pre>\n</div>\n</div>\n<p>In your app, you can render the title using <code>import.meta.env.VITE_APP_TITLE</code>.</p>\n<p>In some cases, you may want to run <code>vite build</code> with a different mode to render a different title. You can overwrite the default mode used for a command by passing the <code>--mode</code> option flag. For example, if you want to build your app for a staging mode:</p>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">vite build --mode staging</pre>\n</div>\n<p>And create a <code>.env.staging</code> file:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\".env.staging\">.env.staging</span></div>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">VITE_APP_TITLE=My App (staging)</pre>\n</div>\n</div>\n<p>As <code>vite build</code> runs a production build by default, you can also change this and run a development build by using a different mode and <code>.env</code> file configuration:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\".env.testing\">.env.testing</span></div>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">NODE_ENV=development</pre>\n</div>\n</div>\n<h3 id=\"node-env-and-modes\" tabindex=\"-1\">NODE_ENV and Modes </h3>\n<p>It's important to note that <code>NODE_ENV</code> (<code>process.env.NODE_ENV</code>) and modes are two different concepts. Here's how different commands affect the <code>NODE_ENV</code> and mode:</p>\n<table tabindex=\"0\">\n<thead><tr>\n<th>Command</th>\n<th>NODE_ENV</th>\n<th>Mode</th>\n</tr></thead>\n<tbody>\n<tr>\n<td><code>vite build</code></td>\n<td><code>\"production\"</code></td>\n<td><code>\"production\"</code></td>\n</tr>\n<tr>\n<td><code>vite build --mode development</code></td>\n<td><code>\"production\"</code></td>\n<td><code>\"development\"</code></td>\n</tr>\n<tr>\n<td><code>NODE_ENV=development vite build</code></td>\n<td><code>\"development\"</code></td>\n<td><code>\"production\"</code></td>\n</tr>\n<tr>\n<td><code>NODE_ENV=development vite build --mode development</code></td>\n<td><code>\"development\"</code></td>\n<td><code>\"development\"</code></td>\n</tr>\n</tbody>\n</table>\n<p>The different values of <code>NODE_ENV</code> and mode also reflect on its corresponding <code>import.meta.env</code> properties:</p>\n<table tabindex=\"0\">\n<thead><tr>\n<th>Command</th>\n<th><code>import.meta.env.PROD</code></th>\n<th><code>import.meta.env.DEV</code></th>\n</tr></thead>\n<tbody>\n<tr>\n<td><code>NODE_ENV=production</code></td>\n<td><code>true</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td><code>NODE_ENV=development</code></td>\n<td><code>false</code></td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td><code>NODE_ENV=other</code></td>\n<td><code>false</code></td>\n<td><code>true</code></td>\n</tr>\n</tbody>\n</table>\n<table tabindex=\"0\">\n<thead><tr>\n<th>Command</th>\n<th><code>import.meta.env.MODE</code></th>\n</tr></thead>\n<tbody>\n<tr>\n<td><code>--mode production</code></td>\n<td><code>\"production\"</code></td>\n</tr>\n<tr>\n<td><code>--mode development</code></td>\n<td><code>\"development\"</code></td>\n</tr>\n<tr>\n<td><code>--mode staging</code></td>\n<td><code>\"staging\"</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\"><code>NODE_ENV</code> in <code>.env</code> files</strong><p><code>NODE_ENV=...</code> can be set in the command, and also in your <code>.env</code> file. If <code>NODE_ENV</code> is specified in a <code>.env.[mode]</code> file, the mode can be used to control its value. However, both <code>NODE_ENV</code> and modes remain as two different concepts.</p>\n<p>The main benefit with <code>NODE_ENV=...</code> in the command is that it allows Vite to detect the value early. It also allows you to read <code>process.env.NODE_ENV</code> in your Vite config as Vite can only load the env files once the config is evaluated.</p>\n</div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/env-and-mode\" class=\"_attribution-link\">https://vite.dev/guide/env-and-mode</a>\n  </p>\n</div>\n","config/ssr-options":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /config/ssr-options.md for this page in Markdown format</div>\n<h1 id=\"ssr-options\" tabindex=\"-1\">SSR Options </h1>\n<p>Unless noted, the options in this section are applied to both dev and build.</p>\n<h2 id=\"ssr-external\" tabindex=\"-1\">ssr.external </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string[] | true</code>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"../guide/ssr#ssr-externals\">SSR Externals</a>\n</li>\n</ul>\n<p>Externalize the given dependencies and their transitive dependencies for SSR. By default, all dependencies are externalized except for linked dependencies (for HMR). If you prefer to externalize the linked dependency, you can pass its name to this option.</p>\n<p>If <code>true</code>, all dependencies including linked dependencies are externalized.</p>\n<p>Note that the explicitly listed dependencies (using <code>string[]</code> type) will always take priority if they're also listed in <code>ssr.noExternal</code> (using any type).</p>\n<h2 id=\"ssr-noexternal\" tabindex=\"-1\">ssr.noExternal </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string | RegExp | (string | RegExp)[] | true</code>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"../guide/ssr#ssr-externals\">SSR Externals</a>\n</li>\n</ul>\n<p>Prevent listed dependencies from being externalized for SSR, which they will get bundled in build. By default, only linked dependencies are not externalized (for HMR). If you prefer to externalize the linked dependency, you can pass its name to the <code>ssr.external</code> option.</p>\n<p>If <code>true</code>, no dependencies are externalized. However, dependencies explicitly listed in <code>ssr.external</code> (using <code>string[]</code> type) can take priority and still be externalized. If <code>ssr.target: 'node'</code> is set, Node.js built-ins will also be externalized by default.</p>\n<p>Note that if both <code>ssr.noExternal: true</code> and <code>ssr.external: true</code> are configured, <code>ssr.noExternal</code> takes priority and no dependencies are externalized.</p>\n<h2 id=\"ssr-target\" tabindex=\"-1\">ssr.target </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>'node' | 'webworker'</code>\n</li>\n<li>\n<strong>Default:</strong> <code>node</code>\n</li>\n</ul>\n<p>Build target for the SSR server.</p>\n<h2 id=\"ssr-resolve-conditions\" tabindex=\"-1\">ssr.resolve.conditions </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string[]</code>\n</li>\n<li>\n<strong>Default:</strong> <code>['module', 'node', 'development|production']</code> (<code>defaultServerConditions</code>) (<code>['module', 'browser', 'development|production']</code> (<code>defaultClientConditions</code>) for <code>ssr.target === 'webworker'</code>)</li>\n<li>\n<strong>Related:</strong> <a href=\"shared-options#resolve-conditions\">Resolve Conditions</a>\n</li>\n</ul>\n<p>These conditions are used in the plugin pipeline, and only affect non-externalized dependencies during the SSR build. Use <code>ssr.resolve.externalConditions</code> to affect externalized imports.</p>\n<h2 id=\"ssr-resolve-externalconditions\" tabindex=\"-1\">ssr.resolve.externalConditions </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string[]</code>\n</li>\n<li>\n<strong>Default:</strong> <code>['node']</code>\n</li>\n</ul>\n<p>Conditions that are used during ssr import (including <code>ssrLoadModule</code>) of externalized direct dependencies (external dependencies imported by Vite).</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">TIP</strong><p>When using this option, make sure to run Node with <a href=\"https://nodejs.org/docs/latest/api/cli.html#-c-condition---conditionscondition\" target=\"_blank\" rel=\"noreferrer\"><code>--conditions</code> flag</a> with the same values in both dev and build to get a consistent behavior.</p>\n<p>For example, when setting <code>['node', 'custom']</code>, you should run <code>NODE_OPTIONS='--conditions custom' vite</code> in dev and <code>NODE_OPTIONS=\"--conditions custom\" node ./dist/server.js</code> after build.</p>\n</div>\n<h2 id=\"ssr-resolve-mainfields\" tabindex=\"-1\">ssr.resolve.mainFields </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string[]</code>\n</li>\n<li>\n<strong>Default:</strong> <code>['module', 'jsnext:main', 'jsnext']</code>\n</li>\n</ul>\n<p>List of fields in <code>package.json</code> to try when resolving a package's entry point. Note this takes lower precedence than conditional exports resolved from the <code>exports</code> field: if an entry point is successfully resolved from <code>exports</code>, the main field will be ignored. This setting only affects non-externalized dependencies.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/config/ssr-options\" class=\"_attribution-link\">https://vite.dev/config/ssr-options</a>\n  </p>\n</div>\n","guide/migration":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/migration.md for this page in Markdown format</div>\n<h1 id=\"migration-from-v6\" tabindex=\"-1\">Migration from v6 </h1>\n<h2 id=\"node-js-support\" tabindex=\"-1\">Node.js Support </h2>\n<p>Vite no longer supports Node.js 18, which reached its EOL. Node.js 20.19+ / 22.12+ is now required.</p>\n<h2 id=\"default-browser-target-change\" tabindex=\"-1\">Default Browser Target change </h2>\n<p>The default browser value of <code>build.target</code> is updated to a newer browser.</p>\n<ul>\n<li>Chrome 87 → 107</li>\n<li>Edge 88 → 107</li>\n<li>Firefox 78 → 104</li>\n<li>Safari 14.0 → 16.0</li>\n</ul>\n<p>These browser versions align with <a href=\"https://web-platform-dx.github.io/web-features/\" target=\"_blank\" rel=\"noreferrer\">Baseline</a> Widely Available feature sets as of 2025-05-01. In other words, they were all released before 2022-11-01.</p>\n<p>In Vite 5, the default target was named <code>'modules'</code>, but this is no longer available. Instead, a new default target <code>'baseline-widely-available'</code> is introduced.</p>\n<h2 id=\"general-changes\" tabindex=\"-1\">General Changes </h2>\n<h3 id=\"removed-sass-legacy-api-support\" tabindex=\"-1\">Removed Sass legacy API support </h3>\n<p>As planned, support for the Sass legacy API is removed. Vite now only supports the modern API. You can remove the <code>css.preprocessorOptions.sass.api</code> / <code>css.preprocessorOptions.scss.api</code> option.</p>\n<h2 id=\"removed-deprecated-features\" tabindex=\"-1\">Removed deprecated features </h2>\n<ul>\n<li>\n<code>splitVendorChunkPlugin</code> (deprecated in v5.2.7) <ul>\n<li>This plugin was originally provided to ease migration to Vite v2.9.</li>\n<li>The <code>build.rollupOptions.output.manualChunks</code> option can be used to control the chunking behavior if needed.</li>\n</ul>\n</li>\n<li>Hook-level <code>enforce</code> / <code>transform</code> for <code>transformIndexHtml</code> (deprecated in v4.0.0) <ul>\n<li>It was changed to align the interface with <a href=\"https://rollupjs.org/plugin-development/#build-hooks:~:text=Instead%20of%20a%20function%2C%20hooks%20can%20also%20be%20objects.\" target=\"_blank\" rel=\"noreferrer\">Rollup's object hooks</a>.</li>\n<li>\n<code>order</code> should be used instead of <code>enforce</code>, and <code>handler</code> should be used instead of <code>transform</code>.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"advanced\" tabindex=\"-1\">Advanced </h2>\n<p>There are other breaking changes which only affect few users.</p>\n<ul>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/19979\" target=\"_blank\" rel=\"noreferrer\">[#19979] chore: declare version range for peer dependencies</a><ul><li>Specified the peer dependencies version range for CSS preprocessors.</li></ul>\n</li>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/20013\" target=\"_blank\" rel=\"noreferrer\">[#20013] refactor: remove no-op <code>legacy.proxySsrExternalModules</code></a><ul><li>\n<code>legacy.proxySsrExternalModules</code> property had no effect since Vite 6. It is now removed.</li></ul>\n</li>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/19985\" target=\"_blank\" rel=\"noreferrer\">[#19985] refactor!: remove deprecated no-op type only properties</a><ul><li>The following unused properties are now removed: <code>ModuleRunnerOptions.root</code>, <code>ViteDevServer._importGlobMap</code>, <code>ResolvePluginOptions.isFromTsImporter</code>, <code>ResolvePluginOptions.getDepsOptimizer</code>, <code>ResolvePluginOptions.shouldExternalize</code>, <code>ResolvePluginOptions.ssrConfig</code>\n</li></ul>\n</li>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/19986\" target=\"_blank\" rel=\"noreferrer\">[#19986] refactor: remove deprecated env api properties</a><ul><li>These properties were deprecated from the beginning. It is now removed.</li></ul>\n</li>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/19987\" target=\"_blank\" rel=\"noreferrer\">[#19987] refactor!: remove deprecated <code>HotBroadcaster</code> related types</a><ul><li>These types were introduced as part of the now-deprecated Runtime API. It is now removed: <code>HMRBroadcaster</code>, <code>HMRBroadcasterClient</code>, <code>ServerHMRChannel</code>, <code>HMRChannel</code>\n</li></ul>\n</li>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/19996\" target=\"_blank\" rel=\"noreferrer\">[#19996] fix(ssr)!: don't access <code>Object</code> variable in ssr transformed code</a><ul><li>\n<code>__vite_ssr_exportName__</code> is now required for the module runner runtime context.</li></ul>\n</li>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/20045\" target=\"_blank\" rel=\"noreferrer\">[#20045] fix: treat all <code>optimizeDeps.entries</code> values as globs</a><ul><li>\n<code>optimizeDeps.entries</code> now does not receive literal string paths. Instead, it always receives globs.</li></ul>\n</li>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/20222\" target=\"_blank\" rel=\"noreferrer\">[#20222] feat: apply some middlewares before <code>configureServer</code> hook</a>, <a href=\"https://github.com/vitejs/vite/pull/20224\" target=\"_blank\" rel=\"noreferrer\">[#20224] feat: apply some middlewares before <code>configurePreviewServer</code> hook</a><ul><li>Some middlewares are now applied before the <code>configureServer</code> / <code>configurePreviewServer</code> hook. Note that if you don't expect a certain route to apply the <a href=\"../config/server-options#server-cors\"><code>server.cors</code></a> / <a href=\"../config/preview-options#preview-cors\"><code>preview.cors</code></a> option, make sure to remove the related headers from the response.</li></ul>\n</li>\n</ul>\n<h2 id=\"migration-from-v5\" tabindex=\"-1\">Migration from v5 </h2>\n<p>Check the <a href=\"https://v6.vite.dev/guide/migration\" rel=\"noreferrer\" target=\"_blank\">Migration from v5 Guide</a> in the Vite v6 docs first to see the needed changes to port your app to Vite 6, and then proceed with the changes on this page.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/migration\" class=\"_attribution-link\">https://vite.dev/guide/migration</a>\n  </p>\n</div>\n","guide/philosophy":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/philosophy.md for this page in Markdown format</div>\n<h1 id=\"project-philosophy\" tabindex=\"-1\">Project Philosophy </h1>\n<h2 id=\"lean-extendable-core\" tabindex=\"-1\">Lean Extendable Core </h2>\n<p>Vite doesn't intend to cover every use case for every user. Vite aims to support the most common patterns to build Web apps out-of-the-box, but <a href=\"https://github.com/vitejs/vite\" target=\"_blank\" rel=\"noreferrer\">Vite core</a> must remain lean with a small API surface to keep the project maintainable long-term. This goal is possible thanks to <a href=\"api-plugin\">Vite's rollup-based plugin system</a>. Features that can be implemented as external plugins will generally not be added to Vite core. <a href=\"https://vite-pwa-org.netlify.app/\" target=\"_blank\" rel=\"noreferrer\">vite-plugin-pwa</a> is a great example of what can be achieved out of Vite core, and there are a lot of <a href=\"https://github.com/vitejs/awesome-vite#plugins\" target=\"_blank\" rel=\"noreferrer\">well maintained plugins</a> to cover your needs. Vite works closely with the Rollup project to ensure that plugins can be used in both plain-rollup and Vite projects as much as possible, trying to push needed extensions to the Plugin API upstream when possible.</p>\n<h2 id=\"pushing-the-modern-web\" tabindex=\"-1\">Pushing the Modern Web </h2>\n<p>Vite provides opinionated features that push writing modern code. For example:</p>\n<ul>\n<li>The source code can only be written in ESM, where non-ESM dependencies need to be <a href=\"dep-pre-bundling\">pre-bundled as ESM</a> in order to work.</li>\n<li>Web workers are encouraged to be written with the <a href=\"features#web-workers\"><code>new Worker</code> syntax</a> to follow modern standards.</li>\n<li>Node.js modules cannot be used in the browser.</li>\n</ul>\n<p>When adding new features, these patterns are followed to create a future-proof API, which may not always be compatible with other build tools.</p>\n<h2 id=\"a-pragmatic-approach-to-performance\" tabindex=\"-1\">A Pragmatic Approach to Performance </h2>\n<p>Vite has been focused on performance since its <a href=\"why\">origins</a>. Its dev server architecture allows HMR that stays fast as projects scale. Vite uses native tools like <a href=\"https://esbuild.github.io/\" target=\"_blank\" rel=\"noreferrer\">esbuild</a> and <a href=\"https://github.com/vitejs/vite-plugin-react-swc\" target=\"_blank\" rel=\"noreferrer\">SWC</a> to implement intensive tasks but keeps the rest of the code in JS to balance speed with flexibility. When needed, framework plugins will tap into <a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noreferrer\">Babel</a> to compile user code. And during build time Vite currently uses <a href=\"https://rollupjs.org/\" target=\"_blank\" rel=\"noreferrer\">Rollup</a> where bundling size and having access to a wide ecosystem of plugins are more important than raw speed. Vite will continue to evolve internally, using new libraries as they appear to improve DX while keeping its API stable.</p>\n<h2 id=\"building-frameworks-on-top-of-vite\" tabindex=\"-1\">Building Frameworks on Top of Vite </h2>\n<p>Although Vite can be used by users directly, it shines as a tool to create frameworks. Vite core is framework agnostic, but there are polished plugins for each UI framework. Its <a href=\"api-javascript\">JS API</a> allows App Framework authors to use Vite features to create tailored experiences for their users. Vite includes support for <a href=\"ssr\">SSR primitives</a>, usually present in higher-level tools but fundamental to building modern web frameworks. And Vite plugins complete the picture by offering a way to share between frameworks. Vite is also a great fit when paired with <a href=\"backend-integration\">Backend frameworks</a> like <a href=\"https://vite-ruby.netlify.app/\" target=\"_blank\" rel=\"noreferrer\">Ruby</a> and <a href=\"https://laravel.com/docs/10.x/vite\" target=\"_blank\" rel=\"noreferrer\">Laravel</a>.</p>\n<h2 id=\"an-active-ecosystem\" tabindex=\"-1\">An Active Ecosystem </h2>\n<p>Vite evolution is a cooperation between framework and plugin maintainers, users, and the Vite team. We encourage active participation in Vite's Core development once a project adopts Vite. We work closely with the main projects in the ecosystem to minimize regressions on each release, aided by tools like <a href=\"https://github.com/vitejs/vite-ecosystem-ci\" target=\"_blank\" rel=\"noreferrer\">vite-ecosystem-ci</a>. It allows us to run the CI of major projects using Vite on selected PRs and gives us a clear status of how the Ecosystem would react to a release. We strive to fix regressions before they hit users and allow projects to update to the next versions as soon as they are released. If you are working with Vite, we invite you to join <a href=\"https://chat.vite.dev\" target=\"_blank\" rel=\"noreferrer\">Vite's Discord</a> and get involved in the project too.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/philosophy\" class=\"_attribution-link\">https://vite.dev/guide/philosophy</a>\n  </p>\n</div>\n","config/shared-options":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /config/shared-options.md for this page in Markdown format</div>\n<h1 id=\"shared-options\" tabindex=\"-1\">Shared Options </h1>\n<p>Unless noted, the options in this section are applied to all dev, build, and preview.</p>\n<h2 id=\"root\" tabindex=\"-1\">root </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string</code>\n</li>\n<li>\n<strong>Default:</strong> <code>process.cwd()</code>\n</li>\n</ul>\n<p>Project root directory (where <code>index.html</code> is located). Can be an absolute path, or a path relative to the current working directory.</p>\n<p>See <a href=\"../guide/index#index-html-and-project-root\">Project Root</a> for more details.</p>\n<h2 id=\"base\" tabindex=\"-1\">base </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string</code>\n</li>\n<li>\n<strong>Default:</strong> <code>/</code>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"server-options#server-origin\"><code>server.origin</code></a>\n</li>\n</ul>\n<p>Base public path when served in development or production. Valid values include:</p>\n<ul>\n<li>Absolute URL pathname, e.g. <code>/foo/</code>\n</li>\n<li>Full URL, e.g. <code>https://bar.com/foo/</code> (The origin part won't be used in development so the value is the same as <code>/foo/</code>)</li>\n<li>Empty string or <code>./</code> (for embedded deployment)</li>\n</ul>\n<p>See <a href=\"../guide/build#public-base-path\">Public Base Path</a> for more details.</p>\n<h2 id=\"mode\" tabindex=\"-1\">mode </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string</code>\n</li>\n<li>\n<strong>Default:</strong> <code>'development'</code> for serve, <code>'production'</code> for build</li>\n</ul>\n<p>Specifying this in config will override the default mode for <strong>both serve and build</strong>. This value can also be overridden via the command line <code>--mode</code> option.</p>\n<p>See <a href=\"../guide/env-and-mode\">Env Variables and Modes</a> for more details.</p>\n<h2 id=\"define\" tabindex=\"-1\">define </h2>\n<ul><li>\n<strong>Type:</strong> <code>Record&lt;string, any&gt;</code>\n</li></ul>\n<p>Define global constant replacements. Entries will be defined as globals during dev and statically replaced during build.</p>\n<p>Vite uses <a href=\"https://esbuild.github.io/api/#define\" target=\"_blank\" rel=\"noreferrer\">esbuild defines</a> to perform replacements, so value expressions must be a string that contains a JSON-serializable value (null, boolean, number, string, array, or object) or a single identifier. For non-string values, Vite will automatically convert it to a string with <code>JSON.stringify</code>.</p>\n<p><strong>Example:</strong></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  define: {\n    __APP_VERSION__: JSON.stringify('v1.0.0'),\n    __API_URL__: 'window.__backend_api_url',\n  },\n})</pre>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p>For TypeScript users, make sure to add the type declarations in the <code>vite-env.d.ts</code> file to get type checks and Intellisense.</p>\n<p>Example:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// vite-env.d.ts\ndeclare const __APP_VERSION__: string</pre>\n</div>\n</div>\n<h2 id=\"plugins\" tabindex=\"-1\">plugins </h2>\n<ul><li>\n<strong>Type:</strong> <code>(Plugin | Plugin[] | Promise&lt;Plugin | Plugin[]&gt;)[]</code>\n</li></ul>\n<p>Array of plugins to use. Falsy plugins are ignored and arrays of plugins are flattened. If a promise is returned, it would be resolved before running. See <a href=\"../guide/api-plugin\">Plugin API</a> for more details on Vite plugins.</p>\n<h2 id=\"publicdir\" tabindex=\"-1\">publicDir </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string | false</code>\n</li>\n<li>\n<strong>Default:</strong> <code>\"public\"</code>\n</li>\n</ul>\n<p>Directory to serve as plain static assets. Files in this directory are served at <code>/</code> during dev and copied to the root of <code>outDir</code> during build, and are always served or copied as-is without transform. The value can be either an absolute file system path or a path relative to project root.</p>\n<p>Defining <code>publicDir</code> as <code>false</code> disables this feature.</p>\n<p>See <a href=\"../guide/assets#the-public-directory\">The <code>public</code> Directory</a> for more details.</p>\n<h2 id=\"cachedir\" tabindex=\"-1\">cacheDir </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string</code>\n</li>\n<li>\n<strong>Default:</strong> <code>\"node_modules/.vite\"</code>\n</li>\n</ul>\n<p>Directory to save cache files. Files in this directory are pre-bundled deps or some other cache files generated by vite, which can improve the performance. You can use <code>--force</code> flag or manually delete the directory to regenerate the cache files. The value can be either an absolute file system path or a path relative to project root. Default to <code>.vite</code> when no package.json is detected.</p>\n<h2 id=\"resolve-alias\" tabindex=\"-1\">resolve.alias </h2>\n<ul><li>\n<strong>Type:</strong><code>Record&lt;string, string&gt; | Array&lt;{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }&gt;</code>\n</li></ul>\n<p>Will be passed to <code>@rollup/plugin-alias</code> as its <a href=\"https://github.com/rollup/plugins/tree/master/packages/alias#entries\" target=\"_blank\" rel=\"noreferrer\">entries option</a>. Can either be an object, or an array of <code>{ find, replacement, customResolver }</code> pairs.</p>\n<p>When aliasing to file system paths, always use absolute paths. Relative alias values will be used as-is and will not be resolved into file system paths.</p>\n<p>More advanced custom resolution can be achieved through <a href=\"../guide/api-plugin\">plugins</a>.</p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Using with SSR</strong><p>If you have configured aliases for <a href=\"../guide/ssr#ssr-externals\">SSR externalized dependencies</a>, you may want to alias the actual <code>node_modules</code> packages. Both <a href=\"https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias\" target=\"_blank\" rel=\"noreferrer\">Yarn</a> and <a href=\"https://pnpm.io/aliases/\" target=\"_blank\" rel=\"noreferrer\">pnpm</a> support aliasing via the <code>npm:</code> prefix.</p>\n</div>\n<h2 id=\"resolve-dedupe\" tabindex=\"-1\">resolve.dedupe </h2>\n<ul><li>\n<strong>Type:</strong> <code>string[]</code>\n</li></ul>\n<p>If you have duplicated copies of the same dependency in your app (likely due to hoisting or linked packages in monorepos), use this option to force Vite to always resolve listed dependencies to the same copy (from project root).</p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">SSR + ESM</strong><p>For SSR builds, deduplication does not work for ESM build outputs configured from <code>build.rollupOptions.output</code>. A workaround is to use CJS build outputs until ESM has better plugin support for module loading.</p>\n</div>\n<h2 id=\"resolve-conditions\" tabindex=\"-1\">resolve.conditions <a href=\"../guide/api-environment#environments-configuration\" class=\"ignore-header\"><span class=\"VPBadge info\">non-inherit</span></a> </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string[]</code>\n</li>\n<li>\n<strong>Default:</strong> <code>['module', 'browser', 'development|production']</code> (<code>defaultClientConditions</code>)</li>\n</ul>\n<p>Additional allowed conditions when resolving <a href=\"https://nodejs.org/api/packages.html#packages_conditional_exports\" target=\"_blank\" rel=\"noreferrer\">Conditional Exports</a> from a package.</p>\n<p>A package with conditional exports may have the following <code>exports</code> field in its <code>package.json</code>:</p>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"exports\": {\n    \".\": {\n      \"import\": \"./index.mjs\",\n      \"require\": \"./index.js\"\n    }\n  }\n}</pre>\n</div>\n<p>Here, <code>import</code> and <code>require</code> are \"conditions\". Conditions can be nested and should be specified from most specific to least specific.</p>\n<p><code>development|production</code> is a special value that is replaced with <code>production</code> or <code>development</code> depending on the value of <code>process.env.NODE_ENV</code>. It is replaced with <code>production</code> when <code>process.env.NODE_ENV === 'production'</code> and <code>development</code> otherwise.</p>\n<p>Note that <code>import</code>, <code>require</code>, <code>default</code> conditions are always applied if the requirements are met.</p>\n<h2 id=\"resolve-mainfields\" tabindex=\"-1\">resolve.mainFields <a href=\"../guide/api-environment#environments-configuration\" class=\"ignore-header\"><span class=\"VPBadge info\">non-inherit</span></a> </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string[]</code>\n</li>\n<li>\n<strong>Default:</strong> <code>['browser', 'module', 'jsnext:main', 'jsnext']</code> (<code>defaultClientMainFields</code>)</li>\n</ul>\n<p>List of fields in <code>package.json</code> to try when resolving a package's entry point. Note this takes lower precedence than conditional exports resolved from the <code>exports</code> field: if an entry point is successfully resolved from <code>exports</code>, the main field will be ignored.</p>\n<h2 id=\"resolve-extensions\" tabindex=\"-1\">resolve.extensions </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string[]</code>\n</li>\n<li>\n<strong>Default:</strong> <code>['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']</code>\n</li>\n</ul>\n<p>List of file extensions to try for imports that omit extensions. Note it is <strong>NOT</strong> recommended to omit extensions for custom import types (e.g. <code>.vue</code>) since it can interfere with IDE and type support.</p>\n<h2 id=\"resolve-preservesymlinks\" tabindex=\"-1\">resolve.preserveSymlinks </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>false</code>\n</li>\n</ul>\n<p>Enabling this setting causes vite to determine file identity by the original file path (i.e. the path without following symlinks) instead of the real file path (i.e. the path after following symlinks).</p>\n<ul><li>\n<strong>Related:</strong> <a href=\"https://esbuild.github.io/api/#preserve-symlinks\" target=\"_blank\" rel=\"noreferrer\">esbuild#preserve-symlinks</a>, <a href=\"https://webpack.js.org/configuration/resolve/#resolvesymlinks\" target=\"_blank\" rel=\"noreferrer\">webpack#resolve.symlinks </a>\n</li></ul>\n<h2 id=\"html-cspnonce\" tabindex=\"-1\">html.cspNonce </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string</code>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"../guide/features#content-security-policy-csp\">Content Security Policy (CSP)</a>\n</li>\n</ul>\n<p>A nonce value placeholder that will be used when generating script / style tags. Setting this value will also generate a meta tag with nonce value.</p>\n<h2 id=\"css-modules\" tabindex=\"-1\">css.modules </h2>\n<ul><li>\n<strong>Type:</strong><div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface CSSModulesOptions {\n  getJSON?: (\n    cssFileName: string,\n    json: Record&lt;string, string&gt;,\n    outputFileName: string,\n  ) =&gt; void\n  scopeBehaviour?: 'global' | 'local'\n  globalModulePaths?: RegExp[]\n  exportGlobals?: boolean\n  generateScopedName?:\n    | string\n    | ((name: string, filename: string, css: string) =&gt; string)\n  hashPrefix?: string\n  /**\n   * default: undefined\n   */\n  localsConvention?:\n    | 'camelCase'\n    | 'camelCaseOnly'\n    | 'dashes'\n    | 'dashesOnly'\n    | ((\n        originalClassName: string,\n        generatedClassName: string,\n        inputFile: string,\n      ) =&gt; string)\n}</pre>\n</div>\n</li></ul>\n<p>Configure CSS modules behavior. The options are passed on to <a href=\"https://github.com/css-modules/postcss-modules\" target=\"_blank\" rel=\"noreferrer\">postcss-modules</a>.</p>\n<p>This option doesn't have any effect when using <a href=\"../guide/features#lightning-css\">Lightning CSS</a>. If enabled, <a href=\"https://lightningcss.dev/css-modules.html\" target=\"_blank\" rel=\"noreferrer\"><code>css.lightningcss.cssModules</code></a> should be used instead.</p>\n<h2 id=\"css-postcss\" tabindex=\"-1\">css.postcss </h2>\n<ul><li>\n<strong>Type:</strong> <code>string | (postcss.ProcessOptions &amp; { plugins?: postcss.AcceptedPlugin[] })</code>\n</li></ul>\n<p>Inline PostCSS config or a custom directory to search PostCSS config from (default is project root).</p>\n<p>For inline PostCSS config, it expects the same format as <code>postcss.config.js</code>. But for <code>plugins</code> property, only <a href=\"https://github.com/postcss/postcss-load-config/blob/main/README.md#array\" target=\"_blank\" rel=\"noreferrer\">array format</a> can be used.</p>\n<p>The search is done using <a href=\"https://github.com/postcss/postcss-load-config\" target=\"_blank\" rel=\"noreferrer\">postcss-load-config</a> and only the supported config file names are loaded. Config files outside the workspace root (or the <a href=\"../guide/index#index-html-and-project-root\">project root</a> if no workspace is found) are not searched by default. You can specify a custom path outside of the root to load the specific config file instead if needed.</p>\n<p>Note if an inline config is provided, Vite will not search for other PostCSS config sources.</p>\n<h2 id=\"css-preprocessoroptions\" tabindex=\"-1\">css.preprocessorOptions </h2>\n<ul><li>\n<strong>Type:</strong> <code>Record&lt;string, object&gt;</code>\n</li></ul>\n<p>Specify options to pass to CSS pre-processors. The file extensions are used as keys for the options. The supported options for each preprocessor can be found in their respective documentation:</p>\n<ul>\n<li>\n<code>sass</code>/<code>scss</code>: <ul>\n<li>Uses <code>sass-embedded</code> if installed, otherwise uses <code>sass</code>. For the best performance, it's recommended to install the <code>sass-embedded</code> package.</li>\n<li><a href=\"https://sass-lang.com/documentation/js-api/interfaces/stringoptions/\" target=\"_blank\" rel=\"noreferrer\">Options</a></li>\n</ul>\n</li>\n<li>\n<code>less</code>: <a href=\"https://lesscss.org/usage/#less-options\" target=\"_blank\" rel=\"noreferrer\">Options</a>.</li>\n<li>\n<code>styl</code>/<code>stylus</code>: Only <a href=\"https://stylus-lang.com/docs/js.html#define-name-node\" target=\"_blank\" rel=\"noreferrer\"><code>define</code></a> is supported, which can be passed as an object.</li>\n</ul>\n<p><strong>Example:</strong></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  css: {\n    preprocessorOptions: {\n      less: {\n        math: 'parens-division',\n      },\n      styl: {\n        define: {\n          $specialColor: new stylus.nodes.RGBA(51, 197, 255, 1),\n        },\n      },\n      scss: {\n        importers: [\n          // ...\n        ],\n      },\n    },\n  },\n})</pre>\n</div>\n<h3 id=\"css-preprocessoroptions-extension-additionaldata\" tabindex=\"-1\">css.preprocessorOptions[extension].additionalData </h3>\n<ul><li>\n<strong>Type:</strong> <code>string | ((source: string, filename: string) =&gt; (string | { content: string; map?: SourceMap }))</code>\n</li></ul>\n<p>This option can be used to inject extra code for each style content. Note that if you include actual styles and not just variables, those styles will be duplicated in the final bundle.</p>\n<p><strong>Example:</strong></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  css: {\n    preprocessorOptions: {\n      scss: {\n        additionalData: `$injectedColor: orange;`,\n      },\n    },\n  },\n})</pre>\n</div>\n<h2 id=\"css-preprocessormaxworkers\" tabindex=\"-1\">css.preprocessorMaxWorkers </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>number | true</code>\n</li>\n<li>\n<strong>Default:</strong> <code>true</code>\n</li>\n</ul>\n<p>Specifies the maximum number of threads CSS preprocessors can use. <code>true</code> means up to the number of CPUs minus 1. When set to <code>0</code>, Vite will not create any workers and will run the preprocessors in the main thread.</p>\n<p>Depending on the preprocessor options, Vite may run the preprocessors on the main thread even if this option is not set to <code>0</code>.</p>\n<h2 id=\"css-devsourcemap\" tabindex=\"-1\">css.devSourcemap </h2>\n<ul>\n<li>\n<strong>Experimental:</strong> <a href=\"https://github.com/vitejs/vite/discussions/13845\" target=\"_blank\" rel=\"noreferrer\">Give Feedback</a>\n</li>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>false</code>\n</li>\n</ul>\n<p>Whether to enable sourcemaps during dev.</p>\n<h2 id=\"css-transformer\" tabindex=\"-1\">css.transformer </h2>\n<ul>\n<li>\n<strong>Experimental:</strong> <a href=\"https://github.com/vitejs/vite/discussions/13835\" target=\"_blank\" rel=\"noreferrer\">Give Feedback</a>\n</li>\n<li>\n<strong>Type:</strong> <code>'postcss' | 'lightningcss'</code>\n</li>\n<li>\n<strong>Default:</strong> <code>'postcss'</code>\n</li>\n</ul>\n<p>Selects the engine used for CSS processing. Check out <a href=\"../guide/features#lightning-css\">Lightning CSS</a> for more information.</p>\n<div class=\"info custom-block\">\n<strong class=\"custom-block-title\">Duplicate <code>@import</code>s</strong><p>Note that postcss (postcss-import) has a different behavior with duplicated <code>@import</code> from browsers. See <a href=\"https://github.com/postcss/postcss-import/issues/462\" target=\"_blank\" rel=\"noreferrer\">postcss/postcss-import#462</a>.</p>\n</div>\n<h2 id=\"css-lightningcss\" tabindex=\"-1\">css.lightningcss </h2>\n<ul>\n<li>\n<strong>Experimental:</strong> <a href=\"https://github.com/vitejs/vite/discussions/13835\" target=\"_blank\" rel=\"noreferrer\">Give Feedback</a>\n</li>\n<li><strong>Type:</strong></li>\n</ul>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import type {\n  CSSModulesConfig,\n  Drafts,\n  Features,\n  NonStandard,\n  PseudoClasses,\n  Targets,\n} from 'lightningcss'</pre>\n</div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  targets?: Targets\n  include?: Features\n  exclude?: Features\n  drafts?: Drafts\n  nonStandard?: NonStandard\n  pseudoClasses?: PseudoClasses\n  unusedSymbols?: string[]\n  cssModules?: CSSModulesConfig,\n  // ...\n}</pre>\n</div>\n<p>Configures Lightning CSS. Full transform options can be found in <a href=\"https://github.com/parcel-bundler/lightningcss/blob/master/node/index.d.ts\" target=\"_blank\" rel=\"noreferrer\">the Lightning CSS repo</a>.</p>\n<h2 id=\"json-namedexports\" tabindex=\"-1\">json.namedExports </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>true</code>\n</li>\n</ul>\n<p>Whether to support named imports from <code>.json</code> files.</p>\n<h2 id=\"json-stringify\" tabindex=\"-1\">json.stringify </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean | 'auto'</code>\n</li>\n<li>\n<strong>Default:</strong> <code>'auto'</code>\n</li>\n</ul>\n<p>If set to <code>true</code>, imported JSON will be transformed into <code>export default JSON.parse(\"...\")</code> which is significantly more performant than Object literals, especially when the JSON file is large.</p>\n<p>If set to <code>'auto'</code>, the data will be stringified only if <a href=\"https://v8.dev/blog/cost-of-javascript-2019#json:~:text=A%20good%20rule%20of%20thumb%20is%20to%20apply%20this%20technique%20for%20objects%20of%2010%20kB%20or%20larger\" target=\"_blank\" rel=\"noreferrer\">the data is bigger than 10kB</a>.</p>\n<h2 id=\"esbuild\" tabindex=\"-1\">esbuild </h2>\n<ul><li>\n<strong>Type:</strong> <code>ESBuildOptions | false</code>\n</li></ul>\n<p><code>ESBuildOptions</code> extends <a href=\"https://esbuild.github.io/api/#transform\" target=\"_blank\" rel=\"noreferrer\">esbuild's own transform options</a>. The most common use case is customizing JSX:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n  },\n})</pre>\n</div>\n<p>By default, esbuild is applied to <code>ts</code>, <code>jsx</code> and <code>tsx</code> files. You can customize this with <code>esbuild.include</code> and <code>esbuild.exclude</code>, which can be a regex, a <a href=\"https://github.com/micromatch/picomatch#globbing-features\" target=\"_blank\" rel=\"noreferrer\">picomatch</a> pattern, or an array of either.</p>\n<p>In addition, you can also use <code>esbuild.jsxInject</code> to automatically inject JSX helper imports for every file transformed by esbuild:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  esbuild: {\n    jsxInject: `import React from 'react'`,\n  },\n})</pre>\n</div>\n<p>When <a href=\"build-options#build-minify\"><code>build.minify</code></a> is <code>true</code>, all minify optimizations are applied by default. To disable <a href=\"https://esbuild.github.io/api/#minify\" target=\"_blank\" rel=\"noreferrer\">certain aspects</a> of it, set any of <code>esbuild.minifyIdentifiers</code>, <code>esbuild.minifySyntax</code>, or <code>esbuild.minifyWhitespace</code> options to <code>false</code>. Note the <code>esbuild.minify</code> option can't be used to override <code>build.minify</code>.</p>\n<p>Set to <code>false</code> to disable esbuild transforms.</p>\n<h2 id=\"assetsinclude\" tabindex=\"-1\">assetsInclude </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string | RegExp | (string | RegExp)[]</code>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"../guide/assets\">Static Asset Handling</a>\n</li>\n</ul>\n<p>Specify additional <a href=\"https://github.com/micromatch/picomatch#globbing-features\" target=\"_blank\" rel=\"noreferrer\">picomatch patterns</a> to be treated as static assets so that:</p>\n<ul>\n<li><p>They will be excluded from the plugin transform pipeline when referenced from HTML or directly requested over <code>fetch</code> or XHR.</p></li>\n<li><p>Importing them from JS will return their resolved URL string (this can be overwritten if you have a <code>enforce: 'pre'</code> plugin to handle the asset type differently).</p></li>\n</ul>\n<p>The built-in asset type list can be found <a href=\"https://github.com/vitejs/vite/blob/main/packages/vite/src/node/constants.ts\" target=\"_blank\" rel=\"noreferrer\">here</a>.</p>\n<p><strong>Example:</strong></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  assetsInclude: ['**/*.gltf'],\n})</pre>\n</div>\n<h2 id=\"loglevel\" tabindex=\"-1\">logLevel </h2>\n<ul><li>\n<strong>Type:</strong> <code>'info' | 'warn' | 'error' | 'silent'</code>\n</li></ul>\n<p>Adjust console output verbosity. Default is <code>'info'</code>.</p>\n<h2 id=\"customlogger\" tabindex=\"-1\">customLogger </h2>\n<ul><li>\n<strong>Type:</strong><div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface Logger {\n  info(msg: string, options?: LogOptions): void\n  warn(msg: string, options?: LogOptions): void\n  warnOnce(msg: string, options?: LogOptions): void\n  error(msg: string, options?: LogErrorOptions): void\n  clearScreen(type: LogType): void\n  hasErrorLogged(error: Error | RollupError): boolean\n  hasWarned: boolean\n}</pre>\n</div>\n</li></ul>\n<p>Use a custom logger to log messages. You can use Vite's <code>createLogger</code> API to get the default logger and customize it to, for example, change the message or filter out certain warnings.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { createLogger, defineConfig } from 'vite'\n\nconst logger = createLogger()\nconst loggerWarn = logger.warn\n\nlogger.warn = (msg, options) =&gt; {\n  // Ignore empty CSS files warning\n  if (msg.includes('vite:css') &amp;&amp; msg.includes(' is empty')) return\n  loggerWarn(msg, options)\n}\n\nexport default defineConfig({\n  customLogger: logger,\n})</pre>\n</div>\n<h2 id=\"clearscreen\" tabindex=\"-1\">clearScreen </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>true</code>\n</li>\n</ul>\n<p>Set to <code>false</code> to prevent Vite from clearing the terminal screen when logging certain messages. Via command line, use <code>--clearScreen false</code>.</p>\n<h2 id=\"envdir\" tabindex=\"-1\">envDir </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string | false</code>\n</li>\n<li>\n<strong>Default:</strong> <code>root</code>\n</li>\n</ul>\n<p>The directory from which <code>.env</code> files are loaded. Can be an absolute path, or a path relative to the project root. <code>false</code> will disable the <code>.env</code> file loading.</p>\n<p>See <a href=\"../guide/env-and-mode#env-files\">here</a> for more about environment files.</p>\n<h2 id=\"envprefix\" tabindex=\"-1\">envPrefix </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string | string[]</code>\n</li>\n<li>\n<strong>Default:</strong> <code>VITE_</code>\n</li>\n</ul>\n<p>Env variables starting with <code>envPrefix</code> will be exposed to your client source code via <code>import.meta.env</code>.</p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">SECURITY NOTES</strong><p><code>envPrefix</code> should not be set as <code>''</code>, which will expose all your env variables and cause unexpected leaking of sensitive information. Vite will throw an error when detecting <code>''</code>.</p>\n<p>If you would like to expose an unprefixed variable, you can use <a href=\"#define\">define</a> to expose it:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">define: {\n  'import.meta.env.ENV_VARIABLE': JSON.stringify(process.env.ENV_VARIABLE)\n}</pre>\n</div>\n</div>\n<h2 id=\"apptype\" tabindex=\"-1\">appType </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>'spa' | 'mpa' | 'custom'</code>\n</li>\n<li>\n<strong>Default:</strong> <code>'spa'</code>\n</li>\n</ul>\n<p>Whether your application is a Single Page Application (SPA), a <a href=\"../guide/build#multi-page-app\">Multi Page Application (MPA)</a>, or Custom Application (SSR and frameworks with custom HTML handling):</p>\n<ul>\n<li>\n<code>'spa'</code>: include HTML middlewares and use SPA fallback. Configure <a href=\"https://github.com/lukeed/sirv\" target=\"_blank\" rel=\"noreferrer\">sirv</a> with <code>single: true</code> in preview</li>\n<li>\n<code>'mpa'</code>: include HTML middlewares</li>\n<li>\n<code>'custom'</code>: don't include HTML middlewares</li>\n</ul>\n<p>Learn more in Vite's <a href=\"../guide/ssr#vite-cli\">SSR guide</a>. Related: <a href=\"server-options#server-middlewaremode\"><code>server.middlewareMode</code></a>.</p>\n<h2 id=\"future\" tabindex=\"-1\">future </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>Record&lt;string, 'warn' | undefined&gt;</code>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"../changes/index\">Breaking Changes</a>\n</li>\n</ul>\n<p>Enable future breaking changes to prepare for a smooth migration to the next major version of Vite. The list may be updated, added, or removed at any time as new features are developed.</p>\n<p>See the <a href=\"../changes/index\">Breaking Changes</a> page for details of the possible options.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/config/shared-options\" class=\"_attribution-link\">https://vite.dev/config/shared-options</a>\n  </p>\n</div>\n","config/worker-options":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /config/worker-options.md for this page in Markdown format</div>\n<h1 id=\"worker-options\" tabindex=\"-1\">Worker Options </h1>\n<p>Unless noted, the options in this section are applied to all dev, build, and preview.</p>\n<h2 id=\"worker-format\" tabindex=\"-1\">worker.format </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>'es' | 'iife'</code>\n</li>\n<li>\n<strong>Default:</strong> <code>'iife'</code>\n</li>\n</ul>\n<p>Output format for worker bundle.</p>\n<h2 id=\"worker-plugins\" tabindex=\"-1\">worker.plugins </h2>\n<ul><li>\n<strong>Type:</strong> <a href=\"shared-options#plugins\"><code>() =&gt; (Plugin | Plugin[])[]</code></a>\n</li></ul>\n<p>Vite plugins that apply to the worker bundles. Note that <a href=\"shared-options#plugins\">config.plugins</a> only applies to workers in dev, it should be configured here instead for build. The function should return new plugin instances as they are used in parallel rollup worker builds. As such, modifying <code>config.worker</code> options in the <code>config</code> hook will be ignored.</p>\n<h2 id=\"worker-rollupoptions\" tabindex=\"-1\">worker.rollupOptions </h2>\n<ul><li>\n<strong>Type:</strong> <a href=\"https://rollupjs.org/configuration-options/\" target=\"_blank\" rel=\"noreferrer\"><code>RollupOptions</code></a>\n</li></ul>\n<p>Rollup options to build worker bundle.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/config/worker-options\" class=\"_attribution-link\">https://vite.dev/config/worker-options</a>\n  </p>\n</div>\n","config/server-options":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /config/server-options.md for this page in Markdown format</div>\n<h1 id=\"server-options\" tabindex=\"-1\">Server Options </h1>\n<p>Unless noted, the options in this section are only applied to dev.</p>\n<h2 id=\"server-host\" tabindex=\"-1\">server.host </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string | boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>'localhost'</code>\n</li>\n</ul>\n<p>Specify which IP addresses the server should listen on. Set this to <code>0.0.0.0</code> or <code>true</code> to listen on all addresses, including LAN and public addresses.</p>\n<p>This can be set via the CLI using <code>--host 0.0.0.0</code> or <code>--host</code>.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p>There are cases when other servers might respond instead of Vite.</p>\n<p>The first case is when <code>localhost</code> is used. Node.js under v17 reorders the result of DNS-resolved addresses by default. When accessing <code>localhost</code>, browsers use DNS to resolve the address and that address might differ from the address which Vite is listening to. Vite prints the resolved address when it differs.</p>\n<p>You can set <a href=\"https://nodejs.org/api/dns.html#dns_dns_setdefaultresultorder_order\" target=\"_blank\" rel=\"noreferrer\"><code>dns.setDefaultResultOrder('verbatim')</code></a> to disable the reordering behavior. Vite will then print the address as <code>localhost</code>.</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { defineConfig } from 'vite'\nimport dns from 'node:dns'\n\ndns.setDefaultResultOrder('verbatim')\n\nexport default defineConfig({\n  // omit\n})</pre>\n</div>\n</div>\n<p>The second case is when wildcard hosts (e.g. <code>0.0.0.0</code>) are used. This is because servers listening on non-wildcard hosts take priority over those listening on wildcard hosts.</p>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Accessing the server on WSL2 from your LAN</strong><p>When running Vite on WSL2, it is not sufficient to set <code>host: true</code> to access the server from your LAN. See <a href=\"https://learn.microsoft.com/en-us/windows/wsl/networking#accessing-a-wsl-2-distribution-from-your-local-area-network-lan\" target=\"_blank\" rel=\"noreferrer\">the WSL document</a> for more details.</p>\n</div>\n<h2 id=\"server-allowedhosts\" tabindex=\"-1\">server.allowedHosts </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string[] | true</code>\n</li>\n<li>\n<strong>Default:</strong> <code>[]</code>\n</li>\n</ul>\n<p>The hostnames that Vite is allowed to respond to. <code>localhost</code> and domains under <code>.localhost</code> and all IP addresses are allowed by default. When using HTTPS, this check is skipped.</p>\n<p>If a string starts with <code>.</code>, it will allow that hostname without the <code>.</code> and all subdomains under the hostname. For example, <code>.example.com</code> will allow <code>example.com</code>, <code>foo.example.com</code>, and <code>foo.bar.example.com</code>. If set to <code>true</code>, the server is allowed to respond to requests for any hosts.</p>\n<div class=\"details custom-block\">\n<summary>What hosts are safe to be added?</summary><p>Hosts that you have control over which IP addresses they resolve to are safe to add to the list of allowed hosts.</p>\n<p>For example, if you own a domain <code>vite.dev</code>, you can add <code>vite.dev</code> and <code>.vite.dev</code> to the list. If you don't own that domain and you cannot trust the owner of that domain, you should not add it.</p>\n<p>Especially, you should never add Top-Level Domains like <code>.com</code> to the list. This is because anyone can purchase a domain like <code>example.com</code> and control the IP address it resolves to.</p>\n</div>\n<div class=\"danger custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">DANGER</strong><p>Setting <code>server.allowedHosts</code> to <code>true</code> allows any website to send requests to your dev server through DNS rebinding attacks, allowing them to download your source code and content. We recommend always using an explicit list of allowed hosts. See <a href=\"https://github.com/vitejs/vite/security/advisories/GHSA-vg6x-rcgg-rjx6\" target=\"_blank\" rel=\"noreferrer\">GHSA-vg6x-rcgg-rjx6</a> for more details.</p>\n</div>\n<div class=\"details custom-block\">\n<summary>Configure via environment variable</summary><p>You can set the environment variable <code>__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS</code> to add an additional allowed host.</p>\n</div>\n<h2 id=\"server-port\" tabindex=\"-1\">server.port </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>number</code>\n</li>\n<li>\n<strong>Default:</strong> <code>5173</code>\n</li>\n</ul>\n<p>Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on.</p>\n<h2 id=\"server-strictport\" tabindex=\"-1\">server.strictPort </h2>\n<ul><li>\n<strong>Type:</strong> <code>boolean</code>\n</li></ul>\n<p>Set to <code>true</code> to exit if port is already in use, instead of automatically trying the next available port.</p>\n<h2 id=\"server-https\" tabindex=\"-1\">server.https </h2>\n<ul><li>\n<strong>Type:</strong> <code>https.ServerOptions</code>\n</li></ul>\n<p>Enable TLS + HTTP/2. The value is an <a href=\"https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener\" target=\"_blank\" rel=\"noreferrer\">options object</a> passed to <code>https.createServer()</code>.</p>\n<p>Note that this downgrades to TLS only when the <a href=\"#server-proxy\"><code>server.proxy</code> option</a> is also used.</p>\n<p>A valid certificate is needed. For a basic setup, you can add <a href=\"https://github.com/vitejs/vite-plugin-basic-ssl\" target=\"_blank\" rel=\"noreferrer\">@vitejs/plugin-basic-ssl</a> to the project plugins, which will automatically create and cache a self-signed certificate. But we recommend creating your own certificates.</p>\n<h2 id=\"server-open\" tabindex=\"-1\">server.open </h2>\n<ul><li>\n<strong>Type:</strong> <code>boolean | string</code>\n</li></ul>\n<p>Automatically open the app in the browser on server start. When the value is a string, it will be used as the URL's pathname. If you want to open the server in a specific browser you like, you can set the env <code>process.env.BROWSER</code> (e.g. <code>firefox</code>). You can also set <code>process.env.BROWSER_ARGS</code> to pass additional arguments (e.g. <code>--incognito</code>).</p>\n<p><code>BROWSER</code> and <code>BROWSER_ARGS</code> are also special environment variables you can set in the <code>.env</code> file to configure it. See <a href=\"https://github.com/sindresorhus/open#app\" target=\"_blank\" rel=\"noreferrer\">the <code>open</code> package</a> for more details.</p>\n<p><strong>Example:</strong></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  server: {\n    open: '/docs/index.html',\n  },\n})</pre>\n</div>\n<h2 id=\"server-proxy\" tabindex=\"-1\">server.proxy </h2>\n<ul><li>\n<strong>Type:</strong> <code>Record&lt;string, string | ProxyOptions&gt;</code>\n</li></ul>\n<p>Configure custom proxy rules for the dev server. Expects an object of <code>{ key: options }</code> pairs. Any requests that request path starts with that key will be proxied to that specified target. If the key starts with <code>^</code>, it will be interpreted as a <code>RegExp</code>. The <code>configure</code> option can be used to access the proxy instance. If a request matches any of the configured proxy rules, the request won't be transformed by Vite.</p>\n<p>Note that if you are using non-relative <a href=\"shared-options#base\"><code>base</code></a>, you must prefix each key with that <code>base</code>.</p>\n<p>Extends <a href=\"https://github.com/sagemathinc/http-proxy-3#options\" target=\"_blank\" rel=\"noreferrer\"><code>http-proxy-3</code></a>. Additional options are <a href=\"https://github.com/vitejs/vite/blob/main/packages/vite/src/node/server/middlewares/proxy.ts#L13\" target=\"_blank\" rel=\"noreferrer\">here</a>.</p>\n<p>In some cases, you might also want to configure the underlying dev server (e.g. to add custom middlewares to the internal <a href=\"https://github.com/senchalabs/connect\" target=\"_blank\" rel=\"noreferrer\">connect</a> app). In order to do that, you need to write your own <a href=\"../guide/using-plugins\">plugin</a> and use <a href=\"../guide/api-plugin#configureserver\">configureServer</a> function.</p>\n<p><strong>Example:</strong></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  server: {\n    proxy: {\n      // string shorthand:\n      // http://localhost:5173/foo\n      //   -&gt; http://localhost:4567/foo\n      '/foo': 'http://localhost:4567',\n      // with options:\n      // http://localhost:5173/api/bar\n      //   -&gt; http://jsonplaceholder.typicode.com/bar\n      '/api': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        rewrite: (path) =&gt; path.replace(/^\\/api/, ''),\n      },\n      // with RegExp:\n      // http://localhost:5173/fallback/\n      //   -&gt; http://jsonplaceholder.typicode.com/\n      '^/fallback/.*': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        rewrite: (path) =&gt; path.replace(/^\\/fallback/, ''),\n      },\n      // Using the proxy instance\n      '/api': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        configure: (proxy, options) =&gt; {\n          // proxy will be an instance of 'http-proxy'\n        },\n      },\n      // Proxying websockets or socket.io:\n      // ws://localhost:5173/socket.io\n      //   -&gt; ws://localhost:5174/socket.io\n      // Exercise caution using `rewriteWsOrigin` as it can leave the\n      // proxying open to CSRF attacks.\n      '/socket.io': {\n        target: 'ws://localhost:5174',\n        ws: true,\n        rewriteWsOrigin: true,\n      },\n    },\n  },\n})</pre>\n</div>\n<h2 id=\"server-cors\" tabindex=\"-1\">server.cors </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean | CorsOptions</code>\n</li>\n<li>\n<strong>Default:</strong> <code>{ origin: /^https?:\\/\\/(?:(?:[^:]+\\.)?localhost|127\\.0\\.0\\.1|\\[::1\\])(?::\\d+)?$/ }</code> (allows localhost, <code>127.0.0.1</code> and <code>::1</code>)</li>\n</ul>\n<p>Configure CORS for the dev server. Pass an <a href=\"https://github.com/expressjs/cors#configuration-options\" target=\"_blank\" rel=\"noreferrer\">options object</a> to fine tune the behavior or <code>true</code> to allow any origin.</p>\n<div class=\"danger custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">DANGER</strong><p>Setting <code>server.cors</code> to <code>true</code> allows any website to send requests to your dev server and download your source code and content. We recommend always using an explicit list of allowed origins.</p>\n</div>\n<h2 id=\"server-headers\" tabindex=\"-1\">server.headers </h2>\n<ul><li>\n<strong>Type:</strong> <code>OutgoingHttpHeaders</code>\n</li></ul>\n<p>Specify server response headers.</p>\n<h2 id=\"server-hmr\" tabindex=\"-1\">server.hmr </h2>\n<ul><li>\n<strong>Type:</strong> <code>boolean | { protocol?: string, host?: string, port?: number, path?: string, timeout?: number, overlay?: boolean, clientPort?: number, server?: Server }</code>\n</li></ul>\n<p>Disable or configure HMR connection (in cases where the HMR websocket must use a different address from the http server).</p>\n<p>Set <code>server.hmr.overlay</code> to <code>false</code> to disable the server error overlay.</p>\n<p><code>protocol</code> sets the WebSocket protocol used for the HMR connection: <code>ws</code> (WebSocket) or <code>wss</code> (WebSocket Secure).</p>\n<p><code>clientPort</code> is an advanced option that overrides the port only on the client side, allowing you to serve the websocket on a different port than the client code looks for it on.</p>\n<p>When <code>server.hmr.server</code> is defined, Vite will process the HMR connection requests through the provided server. If not in middleware mode, Vite will attempt to process HMR connection requests through the existing server. This can be helpful when using self-signed certificates or when you want to expose Vite over a network on a single port.</p>\n<p>Check out <a href=\"https://github.com/sapphi-red/vite-setup-catalogue\" target=\"_blank\" rel=\"noreferrer\"><code>vite-setup-catalogue</code></a> for some examples.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p>With the default configuration, reverse proxies in front of Vite are expected to support proxying WebSocket. If the Vite HMR client fails to connect WebSocket, the client will fall back to connecting the WebSocket directly to the Vite HMR server bypassing the reverse proxies:</p>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.</pre>\n</div>\n<p>The error that appears in the Browser when the fallback happens can be ignored. To avoid the error by directly bypassing reverse proxies, you could either:</p>\n<ul>\n<li>configure the reverse proxy to proxy WebSocket too</li>\n<li>set <a href=\"#server-strictport\"><code>server.strictPort = true</code></a> and set <code>server.hmr.clientPort</code> to the same value with <code>server.port</code>\n</li>\n<li>set <code>server.hmr.port</code> to a different value from <a href=\"#server-port\"><code>server.port</code></a>\n</li>\n</ul>\n</div>\n<h2 id=\"server-warmup\" tabindex=\"-1\">server.warmup </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>{ clientFiles?: string[], ssrFiles?: string[] }</code>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"../guide/performance#warm-up-frequently-used-files\">Warm Up Frequently Used Files</a>\n</li>\n</ul>\n<p>Warm up files to transform and cache the results in advance. This improves the initial page load during server starts and prevents transform waterfalls.</p>\n<p><code>clientFiles</code> are files that are used in the client only, while <code>ssrFiles</code> are files that are used in SSR only. They accept an array of file paths or <a href=\"https://github.com/SuperchupuDev/tinyglobby\" target=\"_blank\" rel=\"noreferrer\"><code>tinyglobby</code></a> patterns relative to the <code>root</code>.</p>\n<p>Make sure to only add files that are frequently used to not overload the Vite dev server on startup.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  server: {\n    warmup: {\n      clientFiles: ['./src/components/*.vue', './src/utils/big-utils.js'],\n      ssrFiles: ['./src/server/modules/*.js'],\n    },\n  },\n})</pre>\n</div>\n<h2 id=\"server-watch\" tabindex=\"-1\">server.watch </h2>\n<ul><li>\n<strong>Type:</strong> <code>object | null</code>\n</li></ul>\n<p>File system watcher options to pass on to <a href=\"https://github.com/paulmillr/chokidar/tree/3.6.0#api\" target=\"_blank\" rel=\"noreferrer\">chokidar</a>.</p>\n<p>The Vite server watcher watches the <code>root</code> and skips the <code>.git/</code>, <code>node_modules/</code>, <code>test-results/</code>, and Vite's <code>cacheDir</code> and <code>build.outDir</code> directories by default. When updating a watched file, Vite will apply HMR and update the page only if needed.</p>\n<p>If set to <code>null</code>, no files will be watched. <code>server.watcher</code> will provide a compatible event emitter, but calling <code>add</code> or <code>unwatch</code> will have no effect.</p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Watching files in <code>node_modules</code></strong><p>It's currently not possible to watch files and packages in <code>node_modules</code>. For further progress and workarounds, you can follow <a href=\"https://github.com/vitejs/vite/issues/8619\" target=\"_blank\" rel=\"noreferrer\">issue #8619</a>.</p>\n</div>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Using Vite on Windows Subsystem for Linux (WSL) 2</strong><p>When running Vite on WSL2, file system watching does not work when a file is edited by Windows applications (non-WSL2 process). This is due to <a href=\"https://github.com/microsoft/WSL/issues/4739\" target=\"_blank\" rel=\"noreferrer\">a WSL2 limitation</a>. This also applies to running on Docker with a WSL2 backend.</p>\n<p>To fix it, you could either:</p>\n<ul>\n<li>\n<strong>Recommended</strong>: Use WSL2 applications to edit your files. <ul><li>It is also recommended to move the project folder outside of a Windows filesystem. Accessing Windows filesystem from WSL2 is slow. Removing that overhead will improve performance.</li></ul>\n</li>\n<li>Set <code>{ usePolling: true }</code>. <ul><li>Note that <a href=\"https://github.com/paulmillr/chokidar/tree/3.6.0#performance\" target=\"_blank\" rel=\"noreferrer\"><code>usePolling</code> leads to high CPU utilization</a>.</li></ul>\n</li>\n</ul>\n</div>\n<h2 id=\"server-middlewaremode\" tabindex=\"-1\">server.middlewareMode </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>false</code>\n</li>\n</ul>\n<p>Create Vite server in middleware mode.</p>\n<ul>\n<li><p><strong>Related:</strong> <a href=\"shared-options#apptype\">appType</a>, <a href=\"../guide/ssr#setting-up-the-dev-server\">SSR - Setting Up the Dev Server</a></p></li>\n<li><p><strong>Example:</strong></p></li>\n</ul>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import express from 'express'\nimport { createServer as createViteServer } from 'vite'\n\nasync function createServer() {\n  const app = express()\n\n  // Create Vite server in middleware mode\n  const vite = await createViteServer({\n    server: { middlewareMode: true },\n    // don't include Vite's default HTML handling middlewares\n    appType: 'custom',\n  })\n  // Use vite's connect instance as middleware\n  app.use(vite.middlewares)\n\n  app.use('*', async (req, res) =&gt; {\n    // Since `appType` is `'custom'`, should serve response here.\n    // Note: if `appType` is `'spa'` or `'mpa'`, Vite includes middlewares\n    // to handle HTML requests and 404s so user middlewares should be added\n    // before Vite's middlewares to take effect instead\n  })\n}\n\ncreateServer()</pre>\n</div>\n<h2 id=\"server-fs-strict\" tabindex=\"-1\">server.fs.strict </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>true</code> (enabled by default since Vite 2.7)</li>\n</ul>\n<p>Restrict serving files outside of workspace root.</p>\n<h2 id=\"server-fs-allow\" tabindex=\"-1\">server.fs.allow </h2>\n<ul><li>\n<strong>Type:</strong> <code>string[]</code>\n</li></ul>\n<p>Restrict files that could be served via <code>/@fs/</code>. When <code>server.fs.strict</code> is set to <code>true</code>, accessing files outside this directory list that aren't imported from an allowed file will result in a 403.</p>\n<p>Both directories and files can be provided.</p>\n<p>Vite will search for the root of the potential workspace and use it as default. A valid workspace met the following conditions, otherwise will fall back to the <a href=\"../guide/index#index-html-and-project-root\">project root</a>.</p>\n<ul>\n<li>contains <code>workspaces</code> field in <code>package.json</code>\n</li>\n<li>contains one of the following file <ul>\n<li><code>lerna.json</code></li>\n<li><code>pnpm-workspace.yaml</code></li>\n</ul>\n</li>\n</ul>\n<p>Accepts a path to specify the custom workspace root. Could be a absolute path or a path relative to <a href=\"../guide/index#index-html-and-project-root\">project root</a>. For example:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  server: {\n    fs: {\n      // Allow serving files from one level up to the project root\n      allow: ['..'],\n    },\n  },\n})</pre>\n</div>\n<p>When <code>server.fs.allow</code> is specified, the auto workspace root detection will be disabled. To extend the original behavior, a utility <code>searchForWorkspaceRoot</code> is exposed:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { defineConfig, searchForWorkspaceRoot } from 'vite'\n\nexport default defineConfig({\n  server: {\n    fs: {\n      allow: [\n        // search up for workspace root\n        searchForWorkspaceRoot(process.cwd()),\n        // your custom rules\n        '/path/to/custom/allow_directory',\n        '/path/to/custom/allow_file.demo',\n      ],\n    },\n  },\n})</pre>\n</div>\n<h2 id=\"server-fs-deny\" tabindex=\"-1\">server.fs.deny </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string[]</code>\n</li>\n<li>\n<strong>Default:</strong> <code>['.env', '.env.*', '*.{crt,pem}', '**/.git/**']</code>\n</li>\n</ul>\n<p>Blocklist for sensitive files being restricted to be served by Vite dev server. This will have higher priority than <a href=\"#server-fs-allow\"><code>server.fs.allow</code></a>. <a href=\"https://github.com/micromatch/picomatch#globbing-features\" target=\"_blank\" rel=\"noreferrer\">picomatch patterns</a> are supported.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p>This blocklist does not apply to <a href=\"../guide/assets#the-public-directory\">the public directory</a>. All files in the public directory are served without any filtering, since they are copied directly to the output directory during build.</p>\n</div>\n<h2 id=\"server-origin\" tabindex=\"-1\">server.origin </h2>\n<ul><li>\n<strong>Type:</strong> <code>string</code>\n</li></ul>\n<p>Defines the origin of the generated asset URLs during development.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  server: {\n    origin: 'http://127.0.0.1:8080',\n  },\n})</pre>\n</div>\n<h2 id=\"server-sourcemapignorelist\" tabindex=\"-1\">server.sourcemapIgnoreList </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>false | (sourcePath: string, sourcemapPath: string) =&gt; boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>(sourcePath) =&gt; sourcePath.includes('node_modules')</code>\n</li>\n</ul>\n<p>Whether or not to ignore source files in the server sourcemap, used to populate the <a href=\"https://developer.chrome.com/articles/x-google-ignore-list/\" target=\"_blank\" rel=\"noreferrer\"><code>x_google_ignoreList</code> source map extension</a>.</p>\n<p><code>server.sourcemapIgnoreList</code> is the equivalent of <a href=\"https://rollupjs.org/configuration-options/#output-sourcemapignorelist\" target=\"_blank\" rel=\"noreferrer\"><code>build.rollupOptions.output.sourcemapIgnoreList</code></a> for the dev server. A difference between the two config options is that the rollup function is called with a relative path for <code>sourcePath</code> while <code>server.sourcemapIgnoreList</code> is called with an absolute path. During dev, most modules have the map and the source in the same folder, so the relative path for <code>sourcePath</code> is the file name itself. In these cases, absolute paths makes it convenient to be used instead.</p>\n<p>By default, it excludes all paths containing <code>node_modules</code>. You can pass <code>false</code> to disable this behavior, or, for full control, a function that takes the source path and sourcemap path and returns whether to ignore the source path.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  server: {\n    // This is the default value, and will add all files with node_modules\n    // in their paths to the ignore list.\n    sourcemapIgnoreList(sourcePath, sourcemapPath) {\n      return sourcePath.includes('node_modules')\n    },\n  },\n})</pre>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Note</strong><p><a href=\"#server-sourcemapignorelist\"><code>server.sourcemapIgnoreList</code></a> and <a href=\"https://rollupjs.org/configuration-options/#output-sourcemapignorelist\" target=\"_blank\" rel=\"noreferrer\"><code>build.rollupOptions.output.sourcemapIgnoreList</code></a> need to be set independently. <code>server.sourcemapIgnoreList</code> is a server only config and doesn't get its default value from the defined rollup options.</p>\n</div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/config/server-options\" class=\"_attribution-link\">https://vite.dev/config/server-options</a>\n  </p>\n</div>\n","guide/build":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/build.md for this page in Markdown format</div>\n<h1 id=\"building-for-production\" tabindex=\"-1\">Building for Production </h1>\n<p>When it is time to deploy your app for production, simply run the <code>vite build</code> command. By default, it uses <code>&lt;root&gt;/index.html</code> as the build entry point, and produces an application bundle that is suitable to be served over a static hosting service. Check out the <a href=\"static-deploy\">Deploying a Static Site</a> for guides about popular services.</p>\n<h2 id=\"browser-compatibility\" tabindex=\"-1\">Browser Compatibility </h2>\n<p>By default, the production bundle assumes a modern browser that is included in the <a href=\"https://web-platform-dx.github.io/web-features/\" target=\"_blank\" rel=\"noreferrer\">Baseline</a> Widely Available targets. The default browser support range is:</p>\n<ul>\n<li>Chrome &gt;=107</li>\n<li>Edge &gt;=107</li>\n<li>Firefox &gt;=104</li>\n<li>Safari &gt;=16</li>\n</ul>\n<p>You can specify custom targets via the <a href=\"../config/build-options#build-target\"><code>build.target</code> config option</a>, where the lowest target is <code>es2015</code>. If a lower target is set, Vite will still require these minimum browser support ranges as it relies on <a href=\"https://caniuse.com/es6-module-dynamic-import\" target=\"_blank\" rel=\"noreferrer\">native ESM dynamic import</a>, and <a href=\"https://caniuse.com/mdn-javascript_operators_import_meta\" target=\"_blank\" rel=\"noreferrer\"><code>import.meta</code></a>:</p>\n<ul>\n<li>Chrome &gt;=64</li>\n<li>Firefox &gt;=67</li>\n<li>Safari &gt;=11.1</li>\n<li>Edge &gt;=79</li>\n</ul>\n<p>Note that by default, Vite only handles syntax transforms and <strong>does not cover polyfills</strong>. You can check out <a href=\"https://cdnjs.cloudflare.com/polyfill/\" target=\"_blank\" rel=\"noreferrer\">https://cdnjs.cloudflare.com/polyfill/</a> which automatically generates polyfill bundles based on the user's browser UserAgent string.</p>\n<p>Legacy browsers can be supported via <a href=\"https://github.com/vitejs/vite/tree/main/packages/plugin-legacy\" target=\"_blank\" rel=\"noreferrer\">@vitejs/plugin-legacy</a>, which will automatically generate legacy chunks and corresponding ES language feature polyfills. The legacy chunks are conditionally loaded only in browsers that do not have native ESM support.</p>\n<h2 id=\"public-base-path\" tabindex=\"-1\">Public Base Path </h2>\n<ul><li>Related: <a href=\"assets\">Asset Handling</a>\n</li></ul>\n<p>If you are deploying your project under a nested public path, simply specify the <a href=\"../config/shared-options#base\"><code>base</code> config option</a> and all asset paths will be rewritten accordingly. This option can also be specified as a command line flag, e.g. <code>vite build --base=/my/public/path/</code>.</p>\n<p>JS-imported asset URLs, CSS <code>url()</code> references, and asset references in your <code>.html</code> files are all automatically adjusted to respect this option during build.</p>\n<p>The exception is when you need to dynamically concatenate URLs on the fly. In this case, you can use the globally injected <code>import.meta.env.BASE_URL</code> variable which will be the public base path. Note this variable is statically replaced during build so it must appear exactly as-is (i.e. <code>import.meta.env['BASE_URL']</code> won't work).</p>\n<p>For advanced base path control, check out <a href=\"#advanced-base-options\">Advanced Base Options</a>.</p>\n<h3 id=\"relative-base\" tabindex=\"-1\">Relative base </h3>\n<p>If you don't know the base path in advance, you may set a relative base path with <code>\"base\": \"./\"</code> or <code>\"base\": \"\"</code>. This will make all generated URLs to be relative to each file.</p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Support for older browsers when using relative bases</strong><p><code>import.meta</code> support is required for relative bases. If you need to support <a href=\"https://caniuse.com/mdn-javascript_operators_import_meta\" target=\"_blank\" rel=\"noreferrer\">browsers that do not support <code>import.meta</code></a>, you can use <a href=\"https://github.com/vitejs/vite/tree/main/packages/plugin-legacy\" target=\"_blank\" rel=\"noreferrer\">the <code>legacy</code> plugin</a>.</p>\n</div>\n<h2 id=\"customizing-the-build\" tabindex=\"-1\">Customizing the Build </h2>\n<p>The build can be customized via various <a href=\"../config/build-options\">build config options</a>. Specifically, you can directly adjust the underlying <a href=\"https://rollupjs.org/configuration-options/\" target=\"_blank\" rel=\"noreferrer\">Rollup options</a> via <code>build.rollupOptions</code>:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  build: {\n    rollupOptions: {\n      // https://rollupjs.org/configuration-options/\n    },\n  },\n})</pre>\n</div>\n</div>\n<p>For example, you can specify multiple Rollup outputs with plugins that are only applied during build.</p>\n<h2 id=\"chunking-strategy\" tabindex=\"-1\">Chunking Strategy </h2>\n<p>You can configure how chunks are split using <code>build.rollupOptions.output.manualChunks</code> (see <a href=\"https://rollupjs.org/configuration-options/#output-manualchunks\" target=\"_blank\" rel=\"noreferrer\">Rollup docs</a>). If you use a framework, refer to their documentation for configuring how chunks are split.</p>\n<h2 id=\"load-error-handling\" tabindex=\"-1\">Load Error Handling </h2>\n<p>Vite emits <code>vite:preloadError</code> event when it fails to load dynamic imports. <code>event.payload</code> contains the original import error. If you call <code>event.preventDefault()</code>, the error will not be thrown.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">window.addEventListener('vite:preloadError', (event) =&gt; {\n  window.location.reload() // for example, refresh the page\n})</pre>\n</div>\n<p>When a new deployment occurs, the hosting service may delete the assets from previous deployments. As a result, a user who visited your site before the new deployment might encounter an import error. This error happens because the assets running on that user's device are outdated and it tries to import the corresponding old chunk, which is deleted. This event is useful for addressing this situation.</p>\n<h2 id=\"rebuild-on-files-changes\" tabindex=\"-1\">Rebuild on Files Changes </h2>\n<p>You can enable rollup watcher with <code>vite build --watch</code>. Or, you can directly adjust the underlying <a href=\"https://rollupjs.org/configuration-options/#watch\" target=\"_blank\" rel=\"noreferrer\"><code>WatcherOptions</code></a> via <code>build.watch</code>:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  build: {\n    watch: {\n      // https://rollupjs.org/configuration-options/#watch\n    },\n  },\n})</pre>\n</div>\n</div>\n<p>With the <code>--watch</code> flag enabled, changes to the <code>vite.config.js</code>, as well as any files to be bundled, will trigger a rebuild.</p>\n<h2 id=\"multi-page-app\" tabindex=\"-1\">Multi-Page App </h2>\n<p>Suppose you have the following source code structure:</p>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">├── package.json\n├── vite.config.js\n├── index.html\n├── main.js\n└── nested\n    ├── index.html\n    └── nested.js</pre>\n</div>\n<p>During dev, simply navigate or link to <code>/nested/</code> - it works as expected, just like for a normal static file server.</p>\n<p>During build, all you need to do is to specify multiple <code>.html</code> files as entry points:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { dirname, resolve } from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { defineConfig } from 'vite'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\n\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      input: {\n        main: resolve(__dirname, 'index.html'),\n        nested: resolve(__dirname, 'nested/index.html'),\n      },\n    },\n  },\n})</pre>\n</div>\n</div>\n<p>If you specify a different root, remember that <code>__dirname</code> will still be the folder of your vite.config.js file when resolving the input paths. Therefore, you will need to add your <code>root</code> entry to the arguments for <code>resolve</code>.</p>\n<p>Note that for HTML files, Vite ignores the name given to the entry in the <code>rollupOptions.input</code> object and instead respects the resolved id of the file when generating the HTML asset in the dist folder. This ensures a consistent structure with the way the dev server works.</p>\n<h2 id=\"library-mode\" tabindex=\"-1\">Library Mode </h2>\n<p>When you are developing a browser-oriented library, you are likely spending most of the time on a test/demo page that imports your actual library. With Vite, you can use your <code>index.html</code> for that purpose to get the smooth development experience.</p>\n<p>When it is time to bundle your library for distribution, use the <a href=\"../config/build-options#build-lib\"><code>build.lib</code> config option</a>. Make sure to also externalize any dependencies that you do not want to bundle into your library, e.g. <code>vue</code> or <code>react</code>:</p>\n<div class=\"vp-code-group\">\n<div class=\"tabs\">\n<input type=\"radio\" name=\"group-166\" id=\"tab-167\" checked><label data-title=\"vite.config.js (single entry)\" for=\"tab-167\">vite.config.js (single entry)</label><input type=\"radio\" name=\"group-166\" id=\"tab-168\"><label data-title=\"vite.config.js (multiple entries)\" for=\"tab-168\">vite.config.js (multiple entries)</label>\n</div>\n<div class=\"blocks\">\n<div class=\"language-js active\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { dirname, resolve } from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { defineConfig } from 'vite'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\n\nexport default defineConfig({\n  build: {\n    lib: {\n      entry: resolve(__dirname, 'lib/main.js'),\n      name: 'MyLib',\n      // the proper extensions will be added\n      fileName: 'my-lib',\n    },\n    rollupOptions: {\n      // make sure to externalize deps that shouldn't be bundled\n      // into your library\n      external: ['vue'],\n      output: {\n        // Provide global variables to use in the UMD build\n        // for externalized deps\n        globals: {\n          vue: 'Vue',\n        },\n      },\n    },\n  },\n})</pre>\n</div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { dirname, resolve } from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { defineConfig } from 'vite'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\n\nexport default defineConfig({\n  build: {\n    lib: {\n      entry: {\n        'my-lib': resolve(__dirname, 'lib/main.js'),\n        secondary: resolve(__dirname, 'lib/secondary.js'),\n      },\n      name: 'MyLib',\n    },\n    rollupOptions: {\n      // make sure to externalize deps that shouldn't be bundled\n      // into your library\n      external: ['vue'],\n      output: {\n        // Provide global variables to use in the UMD build\n        // for externalized deps\n        globals: {\n          vue: 'Vue',\n        },\n      },\n    },\n  },\n})</pre>\n</div>\n</div>\n</div>\n<p>The entry file would contain exports that can be imported by users of your package:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"lib/main.js\">lib/main.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import Foo from './Foo.vue'\nimport Bar from './Bar.vue'\nexport { Foo, Bar }</pre>\n</div>\n</div>\n<p>Running <code>vite build</code> with this config uses a Rollup preset that is oriented towards shipping libraries and produces two bundle formats:</p>\n<ul>\n<li>\n<code>es</code> and <code>umd</code> (for single entry)</li>\n<li>\n<code>es</code> and <code>cjs</code> (for multiple entries)</li>\n</ul>\n<p>The formats can be configured with the <a href=\"../config/build-options#build-lib\"><code>build.lib.formats</code></a> option.</p>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ vite build\nbuilding for production...\ndist/my-lib.js      0.08 kB / gzip: 0.07 kB\ndist/my-lib.umd.cjs 0.30 kB / gzip: 0.16 kB</pre>\n</div>\n<p>Recommended <code>package.json</code> for your lib:</p>\n<div class=\"vp-code-group\">\n<div class=\"tabs\">\n<input type=\"radio\" name=\"group-196\" id=\"tab-197\" checked><label data-title=\"package.json (single entry)\" for=\"tab-197\">package.json (single entry)</label><input type=\"radio\" name=\"group-196\" id=\"tab-198\"><label data-title=\"package.json (multiple entries)\" for=\"tab-198\">package.json (multiple entries)</label>\n</div>\n<div class=\"blocks\">\n<div class=\"language-json active\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.umd.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.umd.cjs\"\n    }\n  }\n}</pre>\n</div>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.cjs\"\n    },\n    \"./secondary\": {\n      \"import\": \"./dist/secondary.js\",\n      \"require\": \"./dist/secondary.cjs\"\n    }\n  }\n}</pre>\n</div>\n</div>\n</div>\n<h3 id=\"css-support\" tabindex=\"-1\">CSS support </h3>\n<p>If your library imports any CSS, it will be bundled as a single CSS file besides the built JS files, e.g. <code>dist/my-lib.css</code>. The name defaults to <code>build.lib.fileName</code>, but can also be changed with <a href=\"../config/build-options#build-lib\"><code>build.lib.cssFileName</code></a>.</p>\n<p>You can export the CSS file in your <code>package.json</code> to be imported by users:</p>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.umd.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.umd.cjs\"\n    },\n    \"./style.css\": \"./dist/my-lib.css\"\n  }\n}</pre>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">File Extensions</strong><p>If the <code>package.json</code> does not contain <code>\"type\": \"module\"</code>, Vite will generate different file extensions for Node.js compatibility. <code>.js</code> will become <code>.mjs</code> and <code>.cjs</code> will become <code>.js</code>.</p>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Environment Variables</strong><p>In library mode, all <a href=\"env-and-mode\"><code>import.meta.env.*</code></a> usage are statically replaced when building for production. However, <code>process.env.*</code> usage are not, so that consumers of your library can dynamically change it. If this is undesirable, you can use <code>define: { 'process.env.NODE_ENV': '\"production\"' }</code> for example to statically replace them, or use <a href=\"https://github.com/benmccann/esm-env\" target=\"_blank\" rel=\"noreferrer\"><code>esm-env</code></a> for better compatibility with bundlers and runtimes.</p>\n</div>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Advanced Usage</strong><p>Library mode includes a simple and opinionated configuration for browser-oriented and JS framework libraries. If you are building non-browser libraries, or require advanced build flows, you can use <a href=\"https://rollupjs.org\" target=\"_blank\" rel=\"noreferrer\">Rollup</a> or <a href=\"https://esbuild.github.io\" target=\"_blank\" rel=\"noreferrer\">esbuild</a> directly.</p>\n</div>\n<h2 id=\"advanced-base-options\" tabindex=\"-1\">Advanced Base Options </h2>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">WARNING</strong><p>This feature is experimental. <a href=\"https://github.com/vitejs/vite/discussions/13834\" target=\"_blank\" rel=\"noreferrer\">Give Feedback</a>.</p>\n</div>\n<p>For advanced use cases, the deployed assets and public files may be in different paths, for example to use different cache strategies. A user may choose to deploy in three different paths:</p>\n<ul>\n<li>The generated entry HTML files (which may be processed during SSR)</li>\n<li>The generated hashed assets (JS, CSS, and other file types like images)</li>\n<li>The copied <a href=\"assets#the-public-directory\">public files</a>\n</li>\n</ul>\n<p>A single static <a href=\"#public-base-path\">base</a> isn't enough in these scenarios. Vite provides experimental support for advanced base options during build, using <code>experimental.renderBuiltUrl</code>.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">experimental: {\n  renderBuiltUrl(filename, { hostType }) {\n    if (hostType === 'js') {\n      return { runtime: `window.__toCdnUrl(${JSON.stringify(filename)})` }\n    } else {\n      return { relative: true }\n    }\n  },\n},</pre>\n</div>\n<p>If the hashed assets and public files aren't deployed together, options for each group can be defined independently using asset <code>type</code> included in the second <code>context</code> param given to the function.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">experimental: {\n  renderBuiltUrl(filename, { hostId, hostType, type }) {\n    if (type === 'public') {\n      return 'https://www.domain.com/' + filename\n    } else if (path.extname(hostId) === '.js') {\n      return {\n        runtime: `window.__assetsPath(${JSON.stringify(filename)})`\n      }\n    } else {\n      return 'https://cdn.domain.com/assets/' + filename\n    }\n  },\n},</pre>\n</div>\n<p>Note that the <code>filename</code> passed is a decoded URL, and if the function returns a URL string, it should also be decoded. Vite will handle the encoding automatically when rendering the URLs. If an object with <code>runtime</code> is returned, encoding should be handled yourself where needed as the runtime code will be rendered as is.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/build\" class=\"_attribution-link\">https://vite.dev/guide/build</a>\n  </p>\n</div>\n","guide/api-environment-runtimes":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/api-environment-runtimes.md for this page in Markdown format</div>\n<h1 id=\"environment-api-for-runtimes\" tabindex=\"-1\">Environment API for Runtimes </h1>\n<div class=\"info custom-block\">\n<strong class=\"custom-block-title\">Release Candidate</strong><p>The Environment API is generally in the release candidate phase. We'll maintain stability in the APIs between major releases to allow the ecosystem to experiment and build upon them. However, note that <a href=\"../changes/index#considering\">some specific APIs</a> are still considered experimental.</p>\n<p>We plan to stabilize these new APIs (with potential breaking changes) in a future major release once downstream projects have had time to experiment with the new features and validate them.</p>\n<p>Resources:</p>\n<ul>\n<li>\n<a href=\"https://github.com/vitejs/vite/discussions/16358\" target=\"_blank\" rel=\"noreferrer\">Feedback discussion</a> where we are gathering feedback about the new APIs.</li>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/16471\" target=\"_blank\" rel=\"noreferrer\">Environment API PR</a> where the new API were implemented and reviewed.</li>\n</ul>\n<p>Please share your feedback with us.</p>\n</div>\n<h2 id=\"environment-factories\" tabindex=\"-1\">Environment Factories </h2>\n<p>Environments factories are intended to be implemented by Environment providers like Cloudflare, and not by end users. Environment factories return a <code>EnvironmentOptions</code> for the most common case of using the target runtime for both dev and build environments. The default environment options can also be set so the user doesn't need to do it.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function createWorkerdEnvironment(\n  userConfig: EnvironmentOptions,\n): EnvironmentOptions {\n  return mergeConfig(\n    {\n      resolve: {\n        conditions: [\n          /*...*/\n        ],\n      },\n      dev: {\n        createEnvironment(name, config) {\n          return createWorkerdDevEnvironment(name, config, {\n            hot: true,\n            transport: customHotChannel(),\n          })\n        },\n      },\n      build: {\n        createEnvironment(name, config) {\n          return createWorkerdBuildEnvironment(name, config)\n        },\n      },\n    },\n    userConfig,\n  )\n}</pre>\n</div>\n<p>Then the config file can be written as:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { createWorkerdEnvironment } from 'vite-environment-workerd'\n\nexport default {\n  environments: {\n    ssr: createWorkerdEnvironment({\n      build: {\n        outDir: '/dist/ssr',\n      },\n    }),\n    rsc: createWorkerdEnvironment({\n      build: {\n        outDir: '/dist/rsc',\n      },\n    }),\n  },\n}</pre>\n</div>\n<p>and frameworks can use an environment with the workerd runtime to do SSR using:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const ssrEnvironment = server.environments.ssr</pre>\n</div>\n<h2 id=\"creating-a-new-environment-factory\" tabindex=\"-1\">Creating a New Environment Factory </h2>\n<p>A Vite dev server exposes two environments by default: a <code>client</code> environment and an <code>ssr</code> environment. The client environment is a browser environment by default, and the module runner is implemented by importing the virtual module <code>/@vite/client</code> to client apps. The SSR environment runs in the same Node runtime as the Vite server by default and allows application servers to be used to render requests during dev with full HMR support.</p>\n<p>The transformed source code is called a module, and the relationships between the modules processed in each environment are kept in a module graph. The transformed code for these modules is sent to the runtimes associated with each environment to be executed. When a module is evaluated in the runtime, its imported modules will be requested triggering the processing of a section of the module graph.</p>\n<p>A Vite Module Runner allows running any code by processing it with Vite plugins first. It is different from <code>server.ssrLoadModule</code> because the runner implementation is decoupled from the server. This allows library and framework authors to implement their layer of communication between the Vite server and the runner. The browser communicates with its corresponding environment using the server Web Socket and through HTTP requests. The Node Module runner can directly do function calls to process modules as it is running in the same process. Other environments could run modules connecting to a JS runtime like workerd, or a Worker Thread as Vitest does.</p>\n<p>One of the goals of this feature is to provide a customizable API to process and run code. Users can create new environment factories using the exposed primitives.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { DevEnvironment, HotChannel } from 'vite'\n\nfunction createWorkerdDevEnvironment(\n  name: string,\n  config: ResolvedConfig,\n  context: DevEnvironmentContext\n) {\n  const connection = /* ... */\n  const transport: HotChannel = {\n    on: (listener) =&gt; { connection.on('message', listener) },\n    send: (data) =&gt; connection.send(data),\n  }\n\n  const workerdDevEnvironment = new DevEnvironment(name, config, {\n    options: {\n      resolve: { conditions: ['custom'] },\n      ...context.options,\n    },\n    hot: true,\n    transport,\n  })\n  return workerdDevEnvironment\n}</pre>\n</div>\n<p>There are <a href=\"api-environment-frameworks#devenvironment-communication-levels\">multiple communication levels for the <code>DevEnvironment</code></a>. To make it easier for frameworks to write runtime agnostic code, we recommend to implement the most flexible communication level possible.</p>\n<h2 id=\"modulerunner\" tabindex=\"-1\">\n<code>ModuleRunner</code> </h2>\n<p>A module runner is instantiated in the target runtime. All APIs in the next section are imported from <code>vite/module-runner</code> unless stated otherwise. This export entry point is kept as lightweight as possible, only exporting the minimal needed to create module runners.</p>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export class ModuleRunner {\n  constructor(\n    public options: ModuleRunnerOptions,\n    public evaluator: ModuleEvaluator = new ESModulesEvaluator(),\n    private debug?: ModuleRunnerDebugger,\n  ) {}\n  /**\n   * URL to execute.\n   * Accepts file path, server path, or id relative to the root.\n   */\n  public async import&lt;T = any&gt;(url: string): Promise&lt;T&gt;\n  /**\n   * Clear all caches including HMR listeners.\n   */\n  public clearCache(): void\n  /**\n   * Clear all caches, remove all HMR listeners, reset sourcemap support.\n   * This method doesn't stop the HMR connection.\n   */\n  public async close(): Promise&lt;void&gt;\n  /**\n   * Returns `true` if the runner has been closed by calling `close()`.\n   */\n  public isClosed(): boolean\n}</pre>\n</div>\n<p>The module evaluator in <code>ModuleRunner</code> is responsible for executing the code. Vite exports <code>ESModulesEvaluator</code> out of the box, it uses <code>new AsyncFunction</code> to evaluate the code. You can provide your own implementation if your JavaScript runtime doesn't support unsafe evaluation.</p>\n<p>Module runner exposes <code>import</code> method. When Vite server triggers <code>full-reload</code> HMR event, all affected modules will be re-executed. Be aware that Module Runner doesn't update <code>exports</code> object when this happens (it overrides it), you would need to run <code>import</code> or get the module from <code>evaluatedModules</code> again if you rely on having the latest <code>exports</code> object.</p>\n<p><strong>Example Usage:</strong></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import {\n  ModuleRunner,\n  ESModulesEvaluator,\n  createNodeImportMeta,\n} from 'vite/module-runner'\nimport { transport } from './rpc-implementation.js'\n\nconst moduleRunner = new ModuleRunner(\n  {\n    transport,\n    createImportMeta: createNodeImportMeta, // if the module runner runs in Node.js\n  },\n  new ESModulesEvaluator(),\n)\n\nawait moduleRunner.import('/src/entry-point.js')</pre>\n</div>\n<h2 id=\"modulerunneroptions\" tabindex=\"-1\">\n<code>ModuleRunnerOptions</code> </h2>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface ModuleRunnerOptions {\n  /**\n   * A set of methods to communicate with the server.\n   */\n  transport: ModuleRunnerTransport\n  /**\n   * Configure how source maps are resolved.\n   * Prefers `node` if `process.setSourceMapsEnabled` is available.\n   * Otherwise it will use `prepareStackTrace` by default which overrides\n   * `Error.prepareStackTrace` method.\n   * You can provide an object to configure how file contents and\n   * source maps are resolved for files that were not processed by Vite.\n   */\n  sourcemapInterceptor?:\n    | false\n    | 'node'\n    | 'prepareStackTrace'\n    | InterceptorOptions\n  /**\n   * Disable HMR or configure HMR options.\n   *\n   * @default true\n   */\n  hmr?: boolean | ModuleRunnerHmr\n  /**\n   * Custom module cache. If not provided, it creates a separate module\n   * cache for each module runner instance.\n   */\n  evaluatedModules?: EvaluatedModules\n}</pre>\n</div>\n<h2 id=\"moduleevaluator\" tabindex=\"-1\">\n<code>ModuleEvaluator</code> </h2>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export interface ModuleEvaluator {\n  /**\n   * Number of prefixed lines in the transformed code.\n   */\n  startOffset?: number\n  /**\n   * Evaluate code that was transformed by Vite.\n   * @param context Function context\n   * @param code Transformed code\n   * @param id ID that was used to fetch the module\n   */\n  runInlinedModule(\n    context: ModuleRunnerContext,\n    code: string,\n    id: string,\n  ): Promise&lt;any&gt;\n  /**\n   * evaluate externalized module.\n   * @param file File URL to the external module\n   */\n  runExternalModule(file: string): Promise&lt;any&gt;\n}</pre>\n</div>\n<p>Vite exports <code>ESModulesEvaluator</code> that implements this interface by default. It uses <code>new AsyncFunction</code> to evaluate code, so if the code has inlined source map it should contain an <a href=\"https://tc39.es/ecma262/#sec-createdynamicfunction\" target=\"_blank\" rel=\"noreferrer\">offset of 2 lines</a> to accommodate for new lines added. This is done automatically by the <code>ESModulesEvaluator</code>. Custom evaluators will not add additional lines.</p>\n<h2 id=\"modulerunnertransport\" tabindex=\"-1\">\n<code>ModuleRunnerTransport</code> </h2>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface ModuleRunnerTransport {\n  connect?(handlers: ModuleRunnerTransportHandlers): Promise&lt;void&gt; | void\n  disconnect?(): Promise&lt;void&gt; | void\n  send?(data: HotPayload): Promise&lt;void&gt; | void\n  invoke?(data: HotPayload): Promise&lt;{ result: any } | { error: any }&gt;\n  timeout?: number\n}</pre>\n</div>\n<p>Transport object that communicates with the environment via an RPC or by directly calling the function. When <code>invoke</code> method is not implemented, the <code>send</code> method and <code>connect</code> method is required to be implemented. Vite will construct the <code>invoke</code> internally.</p>\n<p>You need to couple it with the <code>HotChannel</code> instance on the server like in this example where module runner is created in the worker thread:</p>\n<div class=\"vp-code-group\">\n<div class=\"tabs\">\n<input type=\"radio\" name=\"group-111\" id=\"tab-112\" checked><label data-title=\"worker.js\" for=\"tab-112\">worker.js</label><input type=\"radio\" name=\"group-111\" id=\"tab-113\"><label data-title=\"server.js\" for=\"tab-113\">server.js</label>\n</div>\n<div class=\"blocks\">\n<div class=\"language-js active\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { parentPort } from 'node:worker_threads'\nimport { fileURLToPath } from 'node:url'\nimport {\n  ESModulesEvaluator,\n  ModuleRunner,\n  createNodeImportMeta,\n} from 'vite/module-runner'\n\n/** @type {import('vite/module-runner').ModuleRunnerTransport} */\nconst transport = {\n  connect({ onMessage, onDisconnection }) {\n    parentPort.on('message', onMessage)\n    parentPort.on('close', onDisconnection)\n  },\n  send(data) {\n    parentPort.postMessage(data)\n  },\n}\n\nconst runner = new ModuleRunner(\n  {\n    transport,\n    createImportMeta: createNodeImportMeta,\n  },\n  new ESModulesEvaluator(),\n)</pre>\n</div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { BroadcastChannel } from 'node:worker_threads'\nimport { createServer, RemoteEnvironmentTransport, DevEnvironment } from 'vite'\n\nfunction createWorkerEnvironment(name, config, context) {\n  const worker = new Worker('./worker.js')\n  const handlerToWorkerListener = new WeakMap()\n\n  const workerHotChannel = {\n    send: (data) =&gt; worker.postMessage(data),\n    on: (event, handler) =&gt; {\n      if (event === 'connection') return\n\n      const listener = (value) =&gt; {\n        if (value.type === 'custom' &amp;&amp; value.event === event) {\n          const client = {\n            send(payload) {\n              worker.postMessage(payload)\n            },\n          }\n          handler(value.data, client)\n        }\n      }\n      handlerToWorkerListener.set(handler, listener)\n      worker.on('message', listener)\n    },\n    off: (event, handler) =&gt; {\n      if (event === 'connection') return\n      const listener = handlerToWorkerListener.get(handler)\n      if (listener) {\n        worker.off('message', listener)\n        handlerToWorkerListener.delete(handler)\n      }\n    },\n  }\n\n  return new DevEnvironment(name, config, {\n    transport: workerHotChannel,\n  })\n}\n\nawait createServer({\n  environments: {\n    worker: {\n      dev: {\n        createEnvironment: createWorkerEnvironment,\n      },\n    },\n  },\n})</pre>\n</div>\n</div>\n</div>\n<p>A different example using an HTTP request to communicate between the runner and the server:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'\n\nexport const runner = new ModuleRunner(\n  {\n    transport: {\n      async invoke(data) {\n        const response = await fetch(`http://my-vite-server/invoke`, {\n          method: 'POST',\n          body: JSON.stringify(data),\n        })\n        return response.json()\n      },\n    },\n    hmr: false, // disable HMR as HMR requires transport.connect\n  },\n  new ESModulesEvaluator(),\n)\n\nawait runner.import('/entry.js')</pre>\n</div>\n<p>In this case, the <code>handleInvoke</code> method in the <code>NormalizedHotChannel</code> can be used:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const customEnvironment = new DevEnvironment(name, config, context)\n\nserver.onRequest((request: Request) =&gt; {\n  const url = new URL(request.url)\n  if (url.pathname === '/invoke') {\n    const payload = (await request.json()) as HotPayload\n    const result = customEnvironment.hot.handleInvoke(payload)\n    return new Response(JSON.stringify(result))\n  }\n  return Response.error()\n})</pre>\n</div>\n<p>But note that for HMR support, <code>send</code> and <code>connect</code> methods are required. The <code>send</code> method is usually called when the custom event is triggered (like, <code>import.meta.hot.send(\"my-event\")</code>).</p>\n<p>Vite exports <code>createServerHotChannel</code> from the main entry point to support HMR during Vite SSR.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/api-environment-runtimes\" class=\"_attribution-link\">https://vite.dev/guide/api-environment-runtimes</a>\n  </p>\n</div>\n","changes/index":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /changes/index.md for this page in Markdown format</div>\n<h1 id=\"breaking-changes\" tabindex=\"-1\">Breaking Changes </h1>\n<p>List of breaking changes in Vite including API deprecations, removals, and changes. Most of the changes below can be opt-in using the <a href=\"../config/shared-options#future\"><code>future</code> option</a> in your Vite config.</p>\n<h2 id=\"planned\" tabindex=\"-1\">Planned </h2>\n<p>These changes are planned for the next major version of Vite. The deprecation or usage warnings will guide you where possible, and we're reaching out to framework, plugin authors, and users to apply these changes.</p>\n<ul>\n<li><a href=\"this-environment-in-hooks\"><code>this.environment</code> in Hooks</a></li>\n<li><a href=\"hotupdate-hook\">HMR <code>hotUpdate</code> Plugin Hook</a></li>\n<li><a href=\"ssr-using-modulerunner\">SSR Using <code>ModuleRunner</code> API</a></li>\n</ul>\n<h2 id=\"considering\" tabindex=\"-1\">Considering </h2>\n<p>These changes are being considered and are often experimental APIs that intend to improve upon current usage patterns. As not all changes are listed here, please check out the <a href=\"https://github.com/vitejs/vite/discussions/categories/feedback?discussions_q=label%3Aexperimental+category%3AFeedback\" target=\"_blank\" rel=\"noreferrer\">Experimental Label in Vite GitHub Discussions</a> for the full list.</p>\n<p>We don't recommend switching to these APIs yet. They are included in Vite to help us gather feedback. Please check these proposals and let us know how they work in your use case in each's linked GitHub Discussions.</p>\n<ul>\n<li><a href=\"per-environment-apis\">Move to Per-environment APIs</a></li>\n<li><a href=\"shared-plugins-during-build\">Shared Plugins During Build</a></li>\n</ul>\n<h2 id=\"past\" tabindex=\"-1\">Past </h2>\n<p>The changes below have been done or reverted. They are no longer relevant in the current major version.</p>\n<ul><li><em>No past changes yet</em></li></ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/changes/\" class=\"_attribution-link\">https://vite.dev/changes/</a>\n  </p>\n</div>\n","guide/why":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/why.md for this page in Markdown format</div>\n<h1 id=\"why-vite\" tabindex=\"-1\">Why Vite </h1>\n<h2 id=\"the-problems\" tabindex=\"-1\">The Problems </h2>\n<p>Before ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion. This is why we are all familiar with the concept of \"bundling\": using tools that crawl, process and concatenate our source modules into files that can run in the browser.</p>\n<p>Over time we have seen tools like <a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noreferrer\">webpack</a>, <a href=\"https://rollupjs.org\" target=\"_blank\" rel=\"noreferrer\">Rollup</a> and <a href=\"https://parceljs.org/\" target=\"_blank\" rel=\"noreferrer\">Parcel</a>, which greatly improved the development experience for frontend developers.</p>\n<p>However, as we build more and more ambitious applications, the amount of JavaScript we are dealing with is also increasing dramatically. It is not uncommon for large scale projects to contain thousands of modules. We are starting to hit a performance bottleneck for JavaScript based tooling: it can often take an unreasonably long wait (sometimes up to minutes!) to spin up a dev server, and even with Hot Module Replacement (HMR), file edits can take a couple of seconds to be reflected in the browser. The slow feedback loop can greatly affect developers' productivity and happiness.</p>\n<p>Vite aims to address these issues by leveraging new advancements in the ecosystem: the availability of native ES modules in the browser, and the rise of JavaScript tools written in compile-to-native languages.</p>\n<h3 id=\"slow-server-start\" tabindex=\"-1\">Slow Server Start </h3>\n<p>When cold-starting the dev server, a bundler-based build setup has to eagerly crawl and build your entire application before it can be served.</p>\n<p>Vite improves the dev server start time by first dividing the modules in an application into two categories: <strong>dependencies</strong> and <strong>source code</strong>.</p>\n<ul>\n<li>\n<p><strong>Dependencies</strong> are mostly plain JavaScript that do not change often during development. Some large dependencies (e.g. component libraries with hundreds of modules) are also quite expensive to process. Dependencies may also be shipped in various module formats (e.g. ESM or CommonJS).</p>\n<p>Vite <a href=\"dep-pre-bundling\">pre-bundles dependencies</a> using <a href=\"https://esbuild.github.io/\" target=\"_blank\" rel=\"noreferrer\">esbuild</a>. esbuild is written in Go and pre-bundles dependencies 10-100x faster than JavaScript-based bundlers.</p>\n</li>\n<li>\n<p><strong>Source code</strong> often contains non-plain JavaScript that needs transforming (e.g. JSX, CSS or Vue/Svelte components), and will be edited very often. Also, not all source code needs to be loaded at the same time (e.g. with route-based code-splitting).</p>\n<p>Vite serves source code over <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\" target=\"_blank\" rel=\"noreferrer\">native ESM</a>. This is essentially letting the browser take over part of the job of a bundler: Vite only needs to transform and serve source code on demand, as the browser requests it. Code behind conditional dynamic imports is only processed if actually used on the current screen.</p>\n</li>\n</ul>\n<figure class=\"svg-image-root\"><svg viewbox=\"0 0 1896 1071\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"> <text fill=\"#FFAA3E\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"80\" letter-spacing=\"0em\"><tspan x=\"46\" y=\"132.344\">Bundle based dev server</tspan></text>   <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"170\" y=\"631.488\">entry</tspan></text>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0.33em\"><tspan x=\"552.5\" y=\"768.988\">···</tspan></text>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"537\" y=\"494.988\">route</tspan></text>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"534\" y=\"632.988\">route</tspan></text>           <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"864\" y=\"344.988\">module</tspan></text>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"864\" y=\"491.488\">module</tspan></text>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"862\" y=\"627.988\">module</tspan></text>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"864\" y=\"774.488\">module</tspan></text>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0.33em\"><tspan x=\"898.5\" y=\"920.988\">···</tspan></text>    <text fill=\"white\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"1306.5\" y=\"629.988\">Bundle</tspan></text>  <text fill=\"white\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"1667.71\" y=\"604.988\">Server </tspan><tspan x=\"1675.76\" y=\"649.988\">ready</tspan></text> </svg> </figure><figure class=\"svg-image-root\"><svg viewbox=\"0 0 1896 1071\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"> <text fill=\"#FFAA3E\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"80\" letter-spacing=\"0em\"><tspan x=\"45\" y=\"129.344\">Native ESM based dev server</tspan></text>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"724.5\" y=\"591.988\">entry</tspan></text>  <g filter=\"url(#filter0_d_5_61)\"> <text fill=\"#CCCCCB\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0.33em\"><tspan x=\"1213.5\" y=\"768.988\">···</tspan></text> </g>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"1198\" y=\"415.488\">route</tspan></text>  <text fill=\"#CCCCCB\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"1193.5\" y=\"593.988\">route</tspan></text>            <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"1626\" y=\"221.488\">module</tspan></text>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"1621.5\" y=\"411.818\">module</tspan></text>  <text fill=\"#CCCCCB\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"1623\" y=\"586.988\">module</tspan></text>  <text fill=\"#CCCCCB\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"1626\" y=\"776.488\">module</tspan></text>  <text fill=\"#CCCCCB\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0.33em\"><tspan x=\"1660.5\" y=\"965.488\">···</tspan></text>  <text fill=\"white\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"154.707\" y=\"570.988\">Server </tspan><tspan x=\"162.76\" y=\"615.988\">ready</tspan></text>   <text fill=\"#E06666\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" letter-spacing=\"0em\"><tspan x=\"918\" y=\"938.988\">Dynamic import </tspan><tspan x=\"918\" y=\"983.988\">(code split point)</tspan></text> <text fill=\"#C892E9\" xml:space=\"preserve\" style=\"white-space: pre\" font-size=\"38\" letter-spacing=\"0em\"><tspan x=\"399\" y=\"431.488\">HTTP request</tspan></text>  </svg> </figure><h3 id=\"slow-updates\" tabindex=\"-1\">Slow Updates </h3>\n<p>When a file is edited in a bundler-based build setup, it is inefficient to rebuild the whole bundle for an obvious reason: the update speed will degrade linearly with the size of the app.</p>\n<p>In some bundlers, the dev server runs the bundling in memory so that it only needs to invalidate part of its module graph when a file changes, but it still needs to re-construct the entire bundle and reload the web page. Reconstructing the bundle can be expensive, and reloading the page blows away the current state of the application. This is why some bundlers support Hot Module Replacement (HMR): allowing a module to \"hot replace\" itself without affecting the rest of the page. This greatly improves DX - however, in practice we've found that even HMR update speed deteriorates significantly as the size of the application grows.</p>\n<p>In Vite, HMR is performed over native ESM. When a file is edited, Vite only needs to precisely invalidate the chain between the edited module and its closest HMR boundary (most of the time only the module itself), making HMR updates consistently fast regardless of the size of your application.</p>\n<p>Vite also leverages HTTP headers to speed up full page reloads (again, let the browser do more work for us): source code module requests are made conditional via <code>304 Not Modified</code>, and dependency module requests are strongly cached via <code>Cache-Control: max-age=31536000,immutable</code> so they don't hit the server again once cached.</p>\n<p>Once you experience how fast Vite is, we highly doubt you'd be willing to put up with bundled development again.</p>\n<h2 id=\"why-bundle-for-production\" tabindex=\"-1\">Why Bundle for Production </h2>\n<p>Even though native ESM is now widely supported, shipping unbundled ESM in production is still inefficient (even with HTTP/2) due to the additional network round trips caused by nested imports. To get the optimal loading performance in production, it is still better to bundle your code with tree-shaking, lazy-loading and common chunk splitting (for better caching).</p>\n<p>Ensuring optimal output and behavioral consistency between the dev server and the production build isn't easy. This is why Vite ships with a pre-configured <a href=\"build\">build command</a> that bakes in many <a href=\"features#build-optimizations\">performance optimizations</a> out of the box.</p>\n<h2 id=\"why-not-bundle-with-esbuild\" tabindex=\"-1\">Why Not Bundle with esbuild? </h2>\n<p>While Vite leverages esbuild to <a href=\"dep-pre-bundling\">pre-bundle some dependencies in dev</a>, Vite does not use esbuild as a bundler for production builds.</p>\n<p>Vite's current plugin API isn't compatible with using <code>esbuild</code> as a bundler. In spite of <code>esbuild</code> being faster, Vite's adoption of Rollup's flexible plugin API and infrastructure heavily contributed to its success in the ecosystem. For the time being, we believe that Rollup offers a better performance-vs-flexibility tradeoff.</p>\n<p>Rollup has also been working on performance improvements, <a href=\"https://github.com/rollup/rollup/pull/5073\" target=\"_blank\" rel=\"noreferrer\">switching its parser to SWC in v4</a>. And there is an ongoing effort to build a Rust-port of Rollup called Rolldown. Once Rolldown is ready, it could replace both Rollup and esbuild in Vite, improving build performance significantly and removing inconsistencies between development and build. You can watch <a href=\"https://youtu.be/hrdwQHoAp0M\" target=\"_blank\" rel=\"noreferrer\">Evan You's ViteConf 2023 keynote for more details</a>.</p>\n<h2 id=\"how-vite-relates-to-other-unbundled-build-tools\" tabindex=\"-1\">How Vite Relates to Other Unbundled Build Tools? </h2>\n<p><a href=\"https://github.com/preactjs/wmr\" target=\"_blank\" rel=\"noreferrer\">WMR</a> by the Preact team looked to provide a similar feature set. Vite's universal Rollup plugin API for dev and build was inspired by it. WMR is no longer maintained. The Preact team now recommends Vite with <a href=\"https://github.com/preactjs/preset-vite\" target=\"_blank\" rel=\"noreferrer\">@preactjs/preset-vite</a>.</p>\n<p><a href=\"https://www.snowpack.dev/\" target=\"_blank\" rel=\"noreferrer\">Snowpack</a> was also a no-bundle native ESM dev server, very similar in scope to Vite. Vite's dependency pre-bundling is also inspired by Snowpack v1 (now <a href=\"https://github.com/snowpackjs/snowpack/tree/main/esinstall\" target=\"_blank\" rel=\"noreferrer\"><code>esinstall</code></a>). Snowpack is no longer being maintained. The Snowpack team is now working on <a href=\"https://astro.build/\" target=\"_blank\" rel=\"noreferrer\">Astro</a>, a static site builder powered by Vite.</p>\n<p><a href=\"https://modern-web.dev/docs/dev-server/overview/\" target=\"_blank\" rel=\"noreferrer\">@web/dev-server</a> (previously <code>es-dev-server</code>) is a great project and Vite 1.0's Koa-based server setup was inspired by it. The <code>@web</code> umbrella project is actively maintained and contains many other excellent tools that may benefit Vite users as well.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/why\" class=\"_attribution-link\">https://vite.dev/guide/why</a>\n  </p>\n</div>\n","config/build-options":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /config/build-options.md for this page in Markdown format</div>\n<h1 id=\"build-options\" tabindex=\"-1\">Build Options </h1>\n<p>Unless noted, the options in this section are only applied to build.</p>\n<h2 id=\"build-target\" tabindex=\"-1\">build.target </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string | string[]</code>\n</li>\n<li>\n<strong>Default:</strong> <code>'baseline-widely-available'</code>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"../guide/build#browser-compatibility\">Browser Compatibility</a>\n</li>\n</ul>\n<p>Browser compatibility target for the final bundle. The default value is a Vite special value, <code>'baseline-widely-available'</code>, which targets browsers that are included in the <a href=\"https://web-platform-dx.github.io/web-features/\" target=\"_blank\" rel=\"noreferrer\">Baseline</a> Widely Available on 2025-05-01. Specifically, it is <code>['chrome107', 'edge107', 'firefox104', 'safari16']</code>.</p>\n<p>Another special value is <code>'esnext'</code> - which assumes native dynamic imports support and will only perform minimal transpiling.</p>\n<p>The transform is performed with esbuild and the value should be a valid <a href=\"https://esbuild.github.io/api/#target\" target=\"_blank\" rel=\"noreferrer\">esbuild target option</a>. Custom targets can either be an ES version (e.g. <code>es2015</code>), a browser with version (e.g. <code>chrome58</code>), or an array of multiple target strings.</p>\n<p>Note the build will fail if the code contains features that cannot be safely transpiled by esbuild. See <a href=\"https://esbuild.github.io/content-types/#javascript\" target=\"_blank\" rel=\"noreferrer\">esbuild docs</a> for more details.</p>\n<h2 id=\"build-modulepreload\" tabindex=\"-1\">build.modulePreload </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean | { polyfill?: boolean, resolveDependencies?: ResolveModulePreloadDependenciesFn }</code>\n</li>\n<li>\n<strong>Default:</strong> <code>{ polyfill: true }</code>\n</li>\n</ul>\n<p>By default, a <a href=\"https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill\" target=\"_blank\" rel=\"noreferrer\">module preload polyfill</a> is automatically injected. The polyfill is auto injected into the proxy module of each <code>index.html</code> entry. If the build is configured to use a non-HTML custom entry via <code>build.rollupOptions.input</code>, then it is necessary to manually import the polyfill in your custom entry:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import 'vite/modulepreload-polyfill'</pre>\n</div>\n<p>Note: the polyfill does <strong>not</strong> apply to <a href=\"../guide/build#library-mode\">Library Mode</a>. If you need to support browsers without native dynamic import, you should probably avoid using it in your library.</p>\n<p>The polyfill can be disabled using <code>{ polyfill: false }</code>.</p>\n<p>The list of chunks to preload for each dynamic import is computed by Vite. By default, an absolute path including the <code>base</code> will be used when loading these dependencies. If the <code>base</code> is relative (<code>''</code> or <code>'./'</code>), <code>import.meta.url</code> is used at runtime to avoid absolute paths that depend on the final deployed base.</p>\n<p>There is experimental support for fine grained control over the dependencies list and their paths using the <code>resolveDependencies</code> function. <a href=\"https://github.com/vitejs/vite/discussions/13841\" target=\"_blank\" rel=\"noreferrer\">Give Feedback</a>. It expects a function of type <code>ResolveModulePreloadDependenciesFn</code>:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">type ResolveModulePreloadDependenciesFn = (\n  url: string,\n  deps: string[],\n  context: {\n    hostId: string\n    hostType: 'html' | 'js'\n  },\n) =&gt; string[]</pre>\n</div>\n<p>The <code>resolveDependencies</code> function will be called for each dynamic import with a list of the chunks it depends on, and it will also be called for each chunk imported in entry HTML files. A new dependencies array can be returned with these filtered or more dependencies injected, and their paths modified. The <code>deps</code> paths are relative to the <code>build.outDir</code>. The return value should be a relative path to the <code>build.outDir</code>.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">modulePreload: {\n  resolveDependencies: (filename, deps, { hostId, hostType }) =&gt; {\n    return deps.filter(condition)\n  },\n},</pre>\n</div>\n<p>The resolved dependency paths can be further modified using <a href=\"../guide/build#advanced-base-options\"><code>experimental.renderBuiltUrl</code></a>.</p>\n<h2 id=\"build-polyfillmodulepreload\" tabindex=\"-1\">build.polyfillModulePreload </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>true</code>\n</li>\n<li>\n<strong>Deprecated</strong> use <code>build.modulePreload.polyfill</code> instead</li>\n</ul>\n<p>Whether to automatically inject a <a href=\"https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill\" target=\"_blank\" rel=\"noreferrer\">module preload polyfill</a>.</p>\n<h2 id=\"build-outdir\" tabindex=\"-1\">build.outDir </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string</code>\n</li>\n<li>\n<strong>Default:</strong> <code>dist</code>\n</li>\n</ul>\n<p>Specify the output directory (relative to <a href=\"../guide/index#index-html-and-project-root\">project root</a>).</p>\n<h2 id=\"build-assetsdir\" tabindex=\"-1\">build.assetsDir </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string</code>\n</li>\n<li>\n<strong>Default:</strong> <code>assets</code>\n</li>\n</ul>\n<p>Specify the directory to nest generated assets under (relative to <code>build.outDir</code>. This is not used in <a href=\"../guide/build#library-mode\">Library Mode</a>).</p>\n<h2 id=\"build-assetsinlinelimit\" tabindex=\"-1\">build.assetsInlineLimit </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>number</code> | <code>((filePath: string, content: Buffer) =&gt; boolean | undefined)</code>\n</li>\n<li>\n<strong>Default:</strong> <code>4096</code> (4 KiB)</li>\n</ul>\n<p>Imported or referenced assets that are smaller than this threshold will be inlined as base64 URLs to avoid extra http requests. Set to <code>0</code> to disable inlining altogether.</p>\n<p>If a callback is passed, a boolean can be returned to opt-in or opt-out. If nothing is returned the default logic applies.</p>\n<p>Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Note</strong><p>If you specify <code>build.lib</code>, <code>build.assetsInlineLimit</code> will be ignored and assets will always be inlined, regardless of file size or being a Git LFS placeholder.</p>\n</div>\n<h2 id=\"build-csscodesplit\" tabindex=\"-1\">build.cssCodeSplit </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>true</code>\n</li>\n</ul>\n<p>Enable/disable CSS code splitting. When enabled, CSS imported in async JS chunks will be preserved as chunks and fetched together when the chunk is fetched.</p>\n<p>If disabled, all CSS in the entire project will be extracted into a single CSS file.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Note</strong><p>If you specify <code>build.lib</code>, <code>build.cssCodeSplit</code> will be <code>false</code> as default.</p>\n</div>\n<h2 id=\"build-csstarget\" tabindex=\"-1\">build.cssTarget </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>string | string[]</code>\n</li>\n<li>\n<strong>Default:</strong> the same as <a href=\"#build-target\"><code>build.target</code></a>\n</li>\n</ul>\n<p>This option allows users to set a different browser target for CSS minification from the one used for JavaScript transpilation.</p>\n<p>It should only be used when you are targeting a non-mainstream browser. One example is Android WeChat WebView, which supports most modern JavaScript features but not the <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb_colors\" target=\"_blank\" rel=\"noreferrer\"><code>#RGBA</code> hexadecimal color notation in CSS</a>. In this case, you need to set <code>build.cssTarget</code> to <code>chrome61</code> to prevent vite from transforming <code>rgba()</code> colors into <code>#RGBA</code> hexadecimal notations.</p>\n<h2 id=\"build-cssminify\" tabindex=\"-1\">build.cssMinify </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean | 'esbuild' | 'lightningcss'</code>\n</li>\n<li>\n<strong>Default:</strong> the same as <a href=\"#build-minify\"><code>build.minify</code></a> for client, <code>'esbuild'</code> for SSR</li>\n</ul>\n<p>This option allows users to override CSS minification specifically instead of defaulting to <code>build.minify</code>, so you can configure minification for JS and CSS separately. Vite uses <code>esbuild</code> by default to minify CSS. Set the option to <code>'lightningcss'</code> to use <a href=\"https://lightningcss.dev/minification.html\" target=\"_blank\" rel=\"noreferrer\">Lightning CSS</a> instead. If selected, it can be configured using <a href=\"shared-options#css-lightningcss\"><code>css.lightningcss</code></a>.</p>\n<h2 id=\"build-sourcemap\" tabindex=\"-1\">build.sourcemap </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean | 'inline' | 'hidden'</code>\n</li>\n<li>\n<strong>Default:</strong> <code>false</code>\n</li>\n</ul>\n<p>Generate production source maps. If <code>true</code>, a separate sourcemap file will be created. If <code>'inline'</code>, the sourcemap will be appended to the resulting output file as a data URI. <code>'hidden'</code> works like <code>true</code> except that the corresponding sourcemap comments in the bundled files are suppressed.</p>\n<h2 id=\"build-rollupoptions\" tabindex=\"-1\">build.rollupOptions </h2>\n<ul><li>\n<strong>Type:</strong> <a href=\"https://rollupjs.org/configuration-options/\" target=\"_blank\" rel=\"noreferrer\"><code>RollupOptions</code></a>\n</li></ul>\n<p>Directly customize the underlying Rollup bundle. This is the same as options that can be exported from a Rollup config file and will be merged with Vite's internal Rollup options. See <a href=\"https://rollupjs.org/configuration-options/\" target=\"_blank\" rel=\"noreferrer\">Rollup options docs</a> for more details.</p>\n<h2 id=\"build-commonjsoptions\" tabindex=\"-1\">build.commonjsOptions </h2>\n<ul><li>\n<strong>Type:</strong> <a href=\"https://github.com/rollup/plugins/tree/master/packages/commonjs#options\" target=\"_blank\" rel=\"noreferrer\"><code>RollupCommonJSOptions</code></a>\n</li></ul>\n<p>Options to pass on to <a href=\"https://github.com/rollup/plugins/tree/master/packages/commonjs\" target=\"_blank\" rel=\"noreferrer\">@rollup/plugin-commonjs</a>.</p>\n<h2 id=\"build-dynamicimportvarsoptions\" tabindex=\"-1\">build.dynamicImportVarsOptions </h2>\n<ul>\n<li>\n<strong>Type:</strong> <a href=\"https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#options\" target=\"_blank\" rel=\"noreferrer\"><code>RollupDynamicImportVarsOptions</code></a>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"../guide/features#dynamic-import\">Dynamic Import</a>\n</li>\n</ul>\n<p>Options to pass on to <a href=\"https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars\" target=\"_blank\" rel=\"noreferrer\">@rollup/plugin-dynamic-import-vars</a>.</p>\n<h2 id=\"build-lib\" tabindex=\"-1\">build.lib </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>{ entry: string | string[] | { [entryAlias: string]: string }, name?: string, formats?: ('es' | 'cjs' | 'umd' | 'iife')[], fileName?: string | ((format: ModuleFormat, entryName: string) =&gt; string), cssFileName?: string }</code>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"../guide/build#library-mode\">Library Mode</a>\n</li>\n</ul>\n<p>Build as a library. <code>entry</code> is required since the library cannot use HTML as entry. <code>name</code> is the exposed global variable and is required when <code>formats</code> includes <code>'umd'</code> or <code>'iife'</code>. Default <code>formats</code> are <code>['es', 'umd']</code>, or <code>['es', 'cjs']</code>, if multiple entries are used.</p>\n<p><code>fileName</code> is the name of the package file output, which defaults to the <code>\"name\"</code> in <code>package.json</code>. It can also be defined as a function taking the <code>format</code> and <code>entryName</code> as arguments, and returning the file name.</p>\n<p>If your package imports CSS, <code>cssFileName</code> can be used to specify the name of the CSS file output. It defaults to the same value as <code>fileName</code> if it's set a string, otherwise it also falls back to the <code>\"name\"</code> in <code>package.json</code>.</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { defineConfig } from 'vite'\n\nexport default defineConfig({\n  build: {\n    lib: {\n      entry: ['src/main.js'],\n      fileName: (format, entryName) =&gt; `my-lib-${entryName}.${format}.js`,\n      cssFileName: 'my-lib-style',\n    },\n  },\n})</pre>\n</div>\n</div>\n<h2 id=\"build-manifest\" tabindex=\"-1\">build.manifest </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean | string</code>\n</li>\n<li>\n<strong>Default:</strong> <code>false</code>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"../guide/backend-integration\">Backend Integration</a>\n</li>\n</ul>\n<p>Whether to generate a manifest file that contains a mapping of non-hashed asset filenames to their hashed versions, which can then be used by a server framework to render the correct asset links.</p>\n<p>When the value is a string, it will be used as the manifest file path relative to <code>build.outDir</code>. When set to <code>true</code>, the path would be <code>.vite/manifest.json</code>.</p>\n<h2 id=\"build-ssrmanifest\" tabindex=\"-1\">build.ssrManifest </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean | string</code>\n</li>\n<li>\n<strong>Default:</strong> <code>false</code>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"../guide/ssr\">Server-Side Rendering</a>\n</li>\n</ul>\n<p>Whether to generate a SSR manifest file for determining style links and asset preload directives in production.</p>\n<p>When the value is a string, it will be used as the manifest file path relative to <code>build.outDir</code>. When set to <code>true</code>, the path would be <code>.vite/ssr-manifest.json</code>.</p>\n<h2 id=\"build-ssr\" tabindex=\"-1\">build.ssr </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean | string</code>\n</li>\n<li>\n<strong>Default:</strong> <code>false</code>\n</li>\n<li>\n<strong>Related:</strong> <a href=\"../guide/ssr\">Server-Side Rendering</a>\n</li>\n</ul>\n<p>Produce SSR-oriented build. The value can be a string to directly specify the SSR entry, or <code>true</code>, which requires specifying the SSR entry via <code>rollupOptions.input</code>.</p>\n<h2 id=\"build-emitassets\" tabindex=\"-1\">build.emitAssets </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>false</code>\n</li>\n</ul>\n<p>During non-client builds, static assets aren't emitted as it is assumed they would be emitted as part of the client build. This option allows frameworks to force emitting them in other environments build. It is responsibility of the framework to merge the assets with a post build step.</p>\n<h2 id=\"build-ssremitassets\" tabindex=\"-1\">build.ssrEmitAssets </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>false</code>\n</li>\n</ul>\n<p>During the SSR build, static assets aren't emitted as it is assumed they would be emitted as part of the client build. This option allows frameworks to force emitting them in both the client and SSR build. It is responsibility of the framework to merge the assets with a post build step. This option will be replaced by <code>build.emitAssets</code> once Environment API is stable.</p>\n<h2 id=\"build-minify\" tabindex=\"-1\">build.minify </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean | 'terser' | 'esbuild'</code>\n</li>\n<li>\n<strong>Default:</strong> <code>'esbuild'</code> for client build, <code>false</code> for SSR build</li>\n</ul>\n<p>Set to <code>false</code> to disable minification, or specify the minifier to use. The default is <a href=\"https://github.com/evanw/esbuild\" target=\"_blank\" rel=\"noreferrer\">esbuild</a> which is 20 ~ 40x faster than terser and only 1 ~ 2% worse compression. <a href=\"https://github.com/privatenumber/minification-benchmarks\" target=\"_blank\" rel=\"noreferrer\">Benchmarks</a></p>\n<p>Note the <code>build.minify</code> option does not minify whitespaces when using the <code>'es'</code> format in lib mode, as it removes pure annotations and breaks tree-shaking.</p>\n<p>Terser must be installed when it is set to <code>'terser'</code>.</p>\n<div class=\"language-sh\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">npm add -D terser</pre>\n</div>\n<h2 id=\"build-terseroptions\" tabindex=\"-1\">build.terserOptions </h2>\n<ul><li>\n<strong>Type:</strong> <code>TerserOptions</code>\n</li></ul>\n<p>Additional <a href=\"https://terser.org/docs/api-reference#minify-options\" target=\"_blank\" rel=\"noreferrer\">minify options</a> to pass on to Terser.</p>\n<p>In addition, you can also pass a <code>maxWorkers: number</code> option to specify the max number of workers to spawn. Defaults to the number of CPUs minus 1.</p>\n<h2 id=\"build-write\" tabindex=\"-1\">build.write </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>true</code>\n</li>\n</ul>\n<p>Set to <code>false</code> to disable writing the bundle to disk. This is mostly used in <a href=\"../guide/api-javascript#build\">programmatic <code>build()</code> calls</a> where further post processing of the bundle is needed before writing to disk.</p>\n<h2 id=\"build-emptyoutdir\" tabindex=\"-1\">build.emptyOutDir </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>true</code> if <code>outDir</code> is inside <code>root</code>\n</li>\n</ul>\n<p>By default, Vite will empty the <code>outDir</code> on build if it is inside project root. It will emit a warning if <code>outDir</code> is outside of root to avoid accidentally removing important files. You can explicitly set this option to suppress the warning. This is also available via command line as <code>--emptyOutDir</code>.</p>\n<h2 id=\"build-copypublicdir\" tabindex=\"-1\">build.copyPublicDir </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>true</code>\n</li>\n</ul>\n<p>By default, Vite will copy files from the <code>publicDir</code> into the <code>outDir</code> on build. Set to <code>false</code> to disable this.</p>\n<h2 id=\"build-reportcompressedsize\" tabindex=\"-1\">build.reportCompressedSize </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>boolean</code>\n</li>\n<li>\n<strong>Default:</strong> <code>true</code>\n</li>\n</ul>\n<p>Enable/disable gzip-compressed size reporting. Compressing large output files can be slow, so disabling this may increase build performance for large projects.</p>\n<h2 id=\"build-chunksizewarninglimit\" tabindex=\"-1\">build.chunkSizeWarningLimit </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>number</code>\n</li>\n<li>\n<strong>Default:</strong> <code>500</code>\n</li>\n</ul>\n<p>Limit for chunk size warnings (in kB). It is compared against the uncompressed chunk size as the <a href=\"https://v8.dev/blog/cost-of-javascript-2019\" target=\"_blank\" rel=\"noreferrer\">JavaScript size itself is related to the execution time</a>.</p>\n<h2 id=\"build-watch\" tabindex=\"-1\">build.watch </h2>\n<ul>\n<li>\n<strong>Type:</strong> <a href=\"https://rollupjs.org/configuration-options/#watch\" target=\"_blank\" rel=\"noreferrer\"><code>WatcherOptions</code></a><code>| null</code>\n</li>\n<li>\n<strong>Default:</strong> <code>null</code>\n</li>\n</ul>\n<p>Set to <code>{}</code> to enable rollup watcher. This is mostly used in cases that involve build-only plugins or integrations processes.</p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Using Vite on Windows Subsystem for Linux (WSL) 2</strong><p>There are cases that file system watching does not work with WSL2. See <a href=\"server-options#server-watch\"><code>server.watch</code></a> for more details.</p>\n</div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/config/build-options\" class=\"_attribution-link\">https://vite.dev/config/build-options</a>\n  </p>\n</div>\n","guide/api-plugin":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/api-plugin.md for this page in Markdown format</div>\n<h1 id=\"plugin-api\" tabindex=\"-1\">Plugin API </h1>\n<p>Vite plugins extends Rollup's well-designed plugin interface with a few extra Vite-specific options. As a result, you can write a Vite plugin once and have it work for both dev and build.</p>\n<p><strong>It is recommended to go through <a href=\"https://rollupjs.org/plugin-development/\" target=\"_blank\" rel=\"noreferrer\">Rollup's plugin documentation</a> first before reading the sections below.</strong></p>\n<h2 id=\"authoring-a-plugin\" tabindex=\"-1\">Authoring a Plugin </h2>\n<p>Vite strives to offer established patterns out of the box, so before creating a new plugin make sure that you check the <a href=\"features\" target=\"_blank\" rel=\"noreferrer\">Features guide</a> to see if your need is covered. Also review available community plugins, both in the form of a <a href=\"https://github.com/rollup/awesome\" target=\"_blank\" rel=\"noreferrer\">compatible Rollup plugin</a> and <a href=\"https://github.com/vitejs/awesome-vite#plugins\" target=\"_blank\" rel=\"noreferrer\">Vite Specific plugins</a></p>\n<p>When creating a plugin, you can inline it in your <code>vite.config.js</code>. There is no need to create a new package for it. Once you see that a plugin was useful in your projects, consider sharing it to help others <a href=\"https://chat.vite.dev\" target=\"_blank\" rel=\"noreferrer\">in the ecosystem</a>.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">TIP</strong><p>When learning, debugging, or authoring plugins, we suggest including <a href=\"https://github.com/antfu/vite-plugin-inspect\" target=\"_blank\" rel=\"noreferrer\">vite-plugin-inspect</a> in your project. It allows you to inspect the intermediate state of Vite plugins. After installing, you can visit <code>localhost:5173/__inspect/</code> to inspect the modules and transformation stack of your project. Check out install instructions in the <a href=\"https://github.com/antfu/vite-plugin-inspect\" target=\"_blank\" rel=\"noreferrer\">vite-plugin-inspect docs</a>. <img src=\"https://vite.dev/assets/vite-plugin-inspect.BSP8m2UZ.webp\" alt=\"vite-plugin-inspect\" width=\"2608\" height=\"1760\"></p>\n</div>\n<h2 id=\"conventions\" tabindex=\"-1\">Conventions </h2>\n<p>If the plugin doesn't use Vite specific hooks and can be implemented as a <a href=\"#rollup-plugin-compatibility\">Compatible Rollup Plugin</a>, then it is recommended to use the <a href=\"https://rollupjs.org/plugin-development/#conventions\" target=\"_blank\" rel=\"noreferrer\">Rollup Plugin naming conventions</a>.</p>\n<ul>\n<li>Rollup Plugins should have a clear name with <code>rollup-plugin-</code> prefix.</li>\n<li>Include <code>rollup-plugin</code> and <code>vite-plugin</code> keywords in package.json.</li>\n</ul>\n<p>This exposes the plugin to be also used in pure Rollup or WMR based projects</p>\n<p>For Vite only plugins</p>\n<ul>\n<li>Vite Plugins should have a clear name with <code>vite-plugin-</code> prefix.</li>\n<li>Include <code>vite-plugin</code> keyword in package.json.</li>\n<li>Include a section in the plugin docs detailing why it is a Vite only plugin (for example, it uses Vite specific plugin hooks).</li>\n</ul>\n<p>If your plugin is only going to work for a particular framework, its name should be included as part of the prefix</p>\n<ul>\n<li>\n<code>vite-plugin-vue-</code> prefix for Vue Plugins</li>\n<li>\n<code>vite-plugin-react-</code> prefix for React Plugins</li>\n<li>\n<code>vite-plugin-svelte-</code> prefix for Svelte Plugins</li>\n</ul>\n<p>See also <a href=\"#virtual-modules-convention\">Virtual Modules Convention</a>.</p>\n<h2 id=\"plugins-config\" tabindex=\"-1\">Plugins Config </h2>\n<p>Users will add plugins to the project <code>devDependencies</code> and configure them using the <code>plugins</code> array option.</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import vitePlugin from 'vite-plugin-feature'\nimport rollupPlugin from 'rollup-plugin-feature'\n\nexport default defineConfig({\n  plugins: [vitePlugin(), rollupPlugin()],\n})</pre>\n</div>\n</div>\n<p>Falsy plugins will be ignored, which can be used to easily activate or deactivate plugins.</p>\n<p><code>plugins</code> also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// framework-plugin\nimport frameworkRefresh from 'vite-plugin-framework-refresh'\nimport frameworkDevtools from 'vite-plugin-framework-devtools'\n\nexport default function framework(config) {\n  return [frameworkRefresh(config), frameworkDevTools(config)]\n}</pre>\n</div>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { defineConfig } from 'vite'\nimport framework from 'vite-plugin-framework'\n\nexport default defineConfig({\n  plugins: [framework()],\n})</pre>\n</div>\n</div>\n<h2 id=\"simple-examples\" tabindex=\"-1\">Simple Examples </h2>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">TIP</strong><p>It is common convention to author a Vite/Rollup plugin as a factory function that returns the actual plugin object. The function can accept options which allows users to customize the behavior of the plugin.</p>\n</div>\n<h3 id=\"transforming-custom-file-types\" tabindex=\"-1\">Transforming Custom File Types </h3>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const fileRegex = /\\.(my-file-ext)$/\n\nexport default function myPlugin() {\n  return {\n    name: 'transform-file',\n\n    transform(src, id) {\n      if (fileRegex.test(id)) {\n        return {\n          code: compileFileToJS(src),\n          map: null, // provide source map if available\n        }\n      }\n    },\n  }\n}</pre>\n</div>\n<h3 id=\"importing-a-virtual-file\" tabindex=\"-1\">Importing a Virtual File </h3>\n<p>See the example in the <a href=\"#virtual-modules-convention\">next section</a>.</p>\n<h2 id=\"virtual-modules-convention\" tabindex=\"-1\">Virtual Modules Convention </h2>\n<p>Virtual modules are a useful scheme that allows you to pass build time information to the source files using normal ESM import syntax.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default function myPlugin() {\n  const virtualModuleId = 'virtual:my-module'\n  const resolvedVirtualModuleId = '\\0' + virtualModuleId\n\n  return {\n    name: 'my-plugin', // required, will show up in warnings and errors\n    resolveId(id) {\n      if (id === virtualModuleId) {\n        return resolvedVirtualModuleId\n      }\n    },\n    load(id) {\n      if (id === resolvedVirtualModuleId) {\n        return `export const msg = \"from virtual module\"`\n      }\n    },\n  }\n}</pre>\n</div>\n<p>Which allows importing the module in JavaScript:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { msg } from 'virtual:my-module'\n\nconsole.log(msg)</pre>\n</div>\n<p>Virtual modules in Vite (and Rollup) are prefixed with <code>virtual:</code> for the user-facing path by convention. If possible the plugin name should be used as a namespace to avoid collisions with other plugins in the ecosystem. For example, a <code>vite-plugin-posts</code> could ask users to import a <code>virtual:posts</code> or <code>virtual:posts/helpers</code> virtual modules to get build time information. Internally, plugins that use virtual modules should prefix the module ID with <code>\\0</code> while resolving the id, a convention from the rollup ecosystem. This prevents other plugins from trying to process the id (like node resolution), and core features like sourcemaps can use this info to differentiate between virtual modules and regular files. <code>\\0</code> is not a permitted char in import URLs so we have to replace them during import analysis. A <code>\\0{id}</code> virtual id ends up encoded as <code>/@id/__x00__{id}</code> during dev in the browser. The id will be decoded back before entering the plugins pipeline, so this is not seen by plugins hooks code.</p>\n<p>Note that modules directly derived from a real file, as in the case of a script module in a Single File Component (like a .vue or .svelte SFC) don't need to follow this convention. SFCs generally generate a set of submodules when processed but the code in these can be mapped back to the filesystem. Using <code>\\0</code> for these submodules would prevent sourcemaps from working correctly.</p>\n<h2 id=\"universal-hooks\" tabindex=\"-1\">Universal Hooks </h2>\n<p>During dev, the Vite dev server creates a plugin container that invokes <a href=\"https://rollupjs.org/plugin-development/#build-hooks\" target=\"_blank\" rel=\"noreferrer\">Rollup Build Hooks</a> the same way Rollup does it.</p>\n<p>The following hooks are called once on server start:</p>\n<ul>\n<li><a href=\"https://rollupjs.org/plugin-development/#options\" target=\"_blank\" rel=\"noreferrer\"><code>options</code></a></li>\n<li><a href=\"https://rollupjs.org/plugin-development/#buildstart\" target=\"_blank\" rel=\"noreferrer\"><code>buildStart</code></a></li>\n</ul>\n<p>The following hooks are called on each incoming module request:</p>\n<ul>\n<li><a href=\"https://rollupjs.org/plugin-development/#resolveid\" target=\"_blank\" rel=\"noreferrer\"><code>resolveId</code></a></li>\n<li><a href=\"https://rollupjs.org/plugin-development/#load\" target=\"_blank\" rel=\"noreferrer\"><code>load</code></a></li>\n<li><a href=\"https://rollupjs.org/plugin-development/#transform\" target=\"_blank\" rel=\"noreferrer\"><code>transform</code></a></li>\n</ul>\n<p>These hooks also have an extended <code>options</code> parameter with additional Vite-specific properties. You can read more in the <a href=\"ssr#ssr-specific-plugin-logic\">SSR documentation</a>.</p>\n<p>Some <code>resolveId</code> calls' <code>importer</code> value may be an absolute path for a generic <code>index.html</code> at root as it's not always possible to derive the actual importer due to Vite's unbundled dev server pattern. For imports handled within Vite's resolve pipeline, the importer can be tracked during the import analysis phase, providing the correct <code>importer</code> value.</p>\n<p>The following hooks are called when the server is closed:</p>\n<ul>\n<li><a href=\"https://rollupjs.org/plugin-development/#buildend\" target=\"_blank\" rel=\"noreferrer\"><code>buildEnd</code></a></li>\n<li><a href=\"https://rollupjs.org/plugin-development/#closebundle\" target=\"_blank\" rel=\"noreferrer\"><code>closeBundle</code></a></li>\n</ul>\n<p>Note that the <a href=\"https://rollupjs.org/plugin-development/#moduleparsed\" target=\"_blank\" rel=\"noreferrer\"><code>moduleParsed</code></a> hook is <strong>not</strong> called during dev, because Vite avoids full AST parses for better performance.</p>\n<p><a href=\"https://rollupjs.org/plugin-development/#output-generation-hooks\" target=\"_blank\" rel=\"noreferrer\">Output Generation Hooks</a> (except <code>closeBundle</code>) are <strong>not</strong> called during dev. You can think of Vite's dev server as only calling <code>rollup.rollup()</code> without calling <code>bundle.generate()</code>.</p>\n<h2 id=\"vite-specific-hooks\" tabindex=\"-1\">Vite Specific Hooks </h2>\n<p>Vite plugins can also provide hooks that serve Vite-specific purposes. These hooks are ignored by Rollup.</p>\n<h3 id=\"config\" tabindex=\"-1\">\n<code>config</code> </h3>\n<ul>\n<li><p><strong>Type:</strong> <code>(config: UserConfig, env: { mode: string, command: string }) =&gt; UserConfig | null | void</code></p></li>\n<li>\n<p><strong>Kind:</strong> <code>async</code>, <code>sequential</code></p>\n<p>Modify Vite config before it's resolved. The hook receives the raw user config (CLI options merged with config file) and the current config env which exposes the <code>mode</code> and <code>command</code> being used. It can return a partial config object that will be deeply merged into existing config, or directly mutate the config (if the default merging cannot achieve the desired result).</p>\n<p><strong>Example:</strong></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// return partial config (recommended)\nconst partialConfigPlugin = () =&gt; ({\n  name: 'return-partial',\n  config: () =&gt; ({\n    resolve: {\n      alias: {\n        foo: 'bar',\n      },\n    },\n  }),\n})\n\n// mutate the config directly (use only when merging doesn't work)\nconst mutateConfigPlugin = () =&gt; ({\n  name: 'mutate-config',\n  config(config, { command }) {\n    if (command === 'build') {\n      config.root = 'foo'\n    }\n  },\n})</pre>\n</div>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Note</strong><p>User plugins are resolved before running this hook so injecting other plugins inside the <code>config</code> hook will have no effect.</p>\n</div>\n</li>\n</ul>\n<h3 id=\"configresolved\" tabindex=\"-1\">\n<code>configResolved</code> </h3>\n<ul>\n<li><p><strong>Type:</strong> <code>(config: ResolvedConfig) =&gt; void | Promise&lt;void&gt;</code></p></li>\n<li>\n<p><strong>Kind:</strong> <code>async</code>, <code>parallel</code></p>\n<p>Called after the Vite config is resolved. Use this hook to read and store the final resolved config. It is also useful when the plugin needs to do something different based on the command being run.</p>\n<p><strong>Example:</strong></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const examplePlugin = () =&gt; {\n  let config\n\n  return {\n    name: 'read-config',\n\n    configResolved(resolvedConfig) {\n      // store the resolved config\n      config = resolvedConfig\n    },\n\n    // use stored config in other hooks\n    transform(code, id) {\n      if (config.command === 'serve') {\n        // dev: plugin invoked by dev server\n      } else {\n        // build: plugin invoked by Rollup\n      }\n    },\n  }\n}</pre>\n</div>\n<p>Note that the <code>command</code> value is <code>serve</code> in dev (in the cli <code>vite</code>, <code>vite dev</code>, and <code>vite serve</code> are aliases).</p>\n</li>\n</ul>\n<h3 id=\"configureserver\" tabindex=\"-1\">\n<code>configureServer</code> </h3>\n<ul>\n<li><p><strong>Type:</strong> <code>(server: ViteDevServer) =&gt; (() =&gt; void) | void | Promise&lt;(() =&gt; void) | void&gt;</code></p></li>\n<li><p><strong>Kind:</strong> <code>async</code>, <code>sequential</code></p></li>\n<li>\n<p><strong>See also:</strong> <a href=\"api-javascript#vitedevserver\">ViteDevServer</a></p>\n<p>Hook for configuring the dev server. The most common use case is adding custom middlewares to the internal <a href=\"https://github.com/senchalabs/connect\" target=\"_blank\" rel=\"noreferrer\">connect</a> app:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const myPlugin = () =&gt; ({\n  name: 'configure-server',\n  configureServer(server) {\n    server.middlewares.use((req, res, next) =&gt; {\n      // custom handle request...\n    })\n  },\n})</pre>\n</div>\n<p><strong>Injecting Post Middleware</strong></p>\n<p>The <code>configureServer</code> hook is called before internal middlewares are installed, so the custom middlewares will run before internal middlewares by default. If you want to inject a middleware <strong>after</strong> internal middlewares, you can return a function from <code>configureServer</code>, which will be called after internal middlewares are installed:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const myPlugin = () =&gt; ({\n  name: 'configure-server',\n  configureServer(server) {\n    // return a post hook that is called after internal middlewares are\n    // installed\n    return () =&gt; {\n      server.middlewares.use((req, res, next) =&gt; {\n        // custom handle request...\n      })\n    }\n  },\n})</pre>\n</div>\n<p><strong>Storing Server Access</strong></p>\n<p>In some cases, other plugin hooks may need access to the dev server instance (e.g. accessing the web socket server, the file system watcher, or the module graph). This hook can also be used to store the server instance for access in other hooks:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const myPlugin = () =&gt; {\n  let server\n  return {\n    name: 'configure-server',\n    configureServer(_server) {\n      server = _server\n    },\n    transform(code, id) {\n      if (server) {\n        // use server...\n      }\n    },\n  }\n}</pre>\n</div>\n<p>Note <code>configureServer</code> is not called when running the production build so your other hooks need to guard against its absence.</p>\n</li>\n</ul>\n<h3 id=\"configurepreviewserver\" tabindex=\"-1\">\n<code>configurePreviewServer</code> </h3>\n<ul>\n<li><p><strong>Type:</strong> <code>(server: PreviewServer) =&gt; (() =&gt; void) | void | Promise&lt;(() =&gt; void) | void&gt;</code></p></li>\n<li><p><strong>Kind:</strong> <code>async</code>, <code>sequential</code></p></li>\n<li>\n<p><strong>See also:</strong> <a href=\"api-javascript#previewserver\">PreviewServer</a></p>\n<p>Same as <a href=\"api-plugin#configureserver\"><code>configureServer</code></a> but for the preview server. Similarly to <code>configureServer</code>, the <code>configurePreviewServer</code> hook is called before other middlewares are installed. If you want to inject a middleware <strong>after</strong> other middlewares, you can return a function from <code>configurePreviewServer</code>, which will be called after internal middlewares are installed:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const myPlugin = () =&gt; ({\n  name: 'configure-preview-server',\n  configurePreviewServer(server) {\n    // return a post hook that is called after other middlewares are\n    // installed\n    return () =&gt; {\n      server.middlewares.use((req, res, next) =&gt; {\n        // custom handle request...\n      })\n    }\n  },\n})</pre>\n</div>\n</li>\n</ul>\n<h3 id=\"transformindexhtml\" tabindex=\"-1\">\n<code>transformIndexHtml</code> </h3>\n<ul>\n<li><p><strong>Type:</strong> <code>IndexHtmlTransformHook | { order?: 'pre' | 'post', handler: IndexHtmlTransformHook }</code></p></li>\n<li>\n<p><strong>Kind:</strong> <code>async</code>, <code>sequential</code></p>\n<p>Dedicated hook for transforming HTML entry point files such as <code>index.html</code>. The hook receives the current HTML string and a transform context. The context exposes the <a href=\"api-javascript#vitedevserver\"><code>ViteDevServer</code></a> instance during dev, and exposes the Rollup output bundle during build.</p>\n<p>The hook can be async and can return one of the following:</p>\n<ul>\n<li>Transformed HTML string</li>\n<li>An array of tag descriptor objects (<code>{ tag, attrs, children }</code>) to inject to the existing HTML. Each tag can also specify where it should be injected to (default is prepending to <code>&lt;head&gt;</code>)</li>\n<li>An object containing both as <code>{ html, tags }</code>\n</li>\n</ul>\n<p>By default <code>order</code> is <code>undefined</code>, with this hook applied after the HTML has been transformed. In order to inject a script that should go through the Vite plugins pipeline, <code>order: 'pre'</code> will apply the hook before processing the HTML. <code>order: 'post'</code> applies the hook after all hooks with <code>order</code> undefined are applied.</p>\n<p><strong>Basic Example:</strong></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const htmlPlugin = () =&gt; {\n  return {\n    name: 'html-transform',\n    transformIndexHtml(html) {\n      return html.replace(\n        /&lt;title&gt;(.*?)&lt;\\/title&gt;/,\n        `&lt;title&gt;Title replaced!&lt;/title&gt;`,\n      )\n    },\n  }\n}</pre>\n</div>\n<p><strong>Full Hook Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">type IndexHtmlTransformHook = (\n  html: string,\n  ctx: {\n    path: string\n    filename: string\n    server?: ViteDevServer\n    bundle?: import('rollup').OutputBundle\n    chunk?: import('rollup').OutputChunk\n  },\n) =&gt;\n  | IndexHtmlTransformResult\n  | void\n  | Promise&lt;IndexHtmlTransformResult | void&gt;\n\ntype IndexHtmlTransformResult =\n  | string\n  | HtmlTagDescriptor[]\n  | {\n      html: string\n      tags: HtmlTagDescriptor[]\n    }\n\ninterface HtmlTagDescriptor {\n  tag: string\n  attrs?: Record&lt;string, string | boolean&gt;\n  children?: string | HtmlTagDescriptor[]\n  /**\n   * default: 'head-prepend'\n   */\n  injectTo?: 'head' | 'body' | 'head-prepend' | 'body-prepend'\n}</pre>\n</div>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Note</strong><p>This hook won't be called if you are using a framework that has custom handling of entry files (for example <a href=\"https://github.com/sveltejs/kit/discussions/8269#discussioncomment-4509145\" target=\"_blank\" rel=\"noreferrer\">SvelteKit</a>).</p>\n</div>\n</li>\n</ul>\n<h3 id=\"handlehotupdate\" tabindex=\"-1\">\n<code>handleHotUpdate</code> </h3>\n<ul>\n<li><p><strong>Type:</strong> <code>(ctx: HmrContext) =&gt; Array&lt;ModuleNode&gt; | void | Promise&lt;Array&lt;ModuleNode&gt; | void&gt;</code></p></li>\n<li>\n<p><strong>See also:</strong> <a href=\"api-hmr\">HMR API</a></p>\n<p>Perform custom HMR update handling. The hook receives a context object with the following signature:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface HmrContext {\n  file: string\n  timestamp: number\n  modules: Array&lt;ModuleNode&gt;\n  read: () =&gt; string | Promise&lt;string&gt;\n  server: ViteDevServer\n}</pre>\n</div>\n<ul>\n<li><p><code>modules</code> is an array of modules that are affected by the changed file. It's an array because a single file may map to multiple served modules (e.g. Vue SFCs).</p></li>\n<li><p><code>read</code> is an async read function that returns the content of the file. This is provided because on some systems, the file change callback may fire too fast before the editor finishes updating the file and direct <code>fs.readFile</code> will return empty content. The read function passed in normalizes this behavior.</p></li>\n</ul>\n<p>The hook can choose to:</p>\n<ul>\n<li><p>Filter and narrow down the affected module list so that the HMR is more accurate.</p></li>\n<li>\n<p>Return an empty array and perform a full reload:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">handleHotUpdate({ server, modules, timestamp }) {\n  // Invalidate modules manually\n  const invalidatedModules = new Set()\n  for (const mod of modules) {\n    server.moduleGraph.invalidateModule(\n      mod,\n      invalidatedModules,\n      timestamp,\n      true\n    )\n  }\n  server.ws.send({ type: 'full-reload' })\n  return []\n}</pre>\n</div>\n</li>\n<li>\n<p>Return an empty array and perform complete custom HMR handling by sending custom events to the client:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">handleHotUpdate({ server }) {\n  server.ws.send({\n    type: 'custom',\n    event: 'special-update',\n    data: {}\n  })\n  return []\n}</pre>\n</div>\n<p>Client code should register corresponding handler using the <a href=\"api-hmr\">HMR API</a> (this could be injected by the same plugin's <code>transform</code> hook):</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">if (import.meta.hot) {\n  import.meta.hot.on('special-update', (data) =&gt; {\n    // perform custom update\n  })\n}</pre>\n</div>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"plugin-ordering\" tabindex=\"-1\">Plugin Ordering </h2>\n<p>A Vite plugin can additionally specify an <code>enforce</code> property (similar to webpack loaders) to adjust its application order. The value of <code>enforce</code> can be either <code>\"pre\"</code> or <code>\"post\"</code>. The resolved plugins will be in the following order:</p>\n<ul>\n<li>Alias</li>\n<li>User plugins with <code>enforce: 'pre'</code>\n</li>\n<li>Vite core plugins</li>\n<li>User plugins without enforce value</li>\n<li>Vite build plugins</li>\n<li>User plugins with <code>enforce: 'post'</code>\n</li>\n<li>Vite post build plugins (minify, manifest, reporting)</li>\n</ul>\n<p>Note that this is separate from hooks ordering, those are still separately subject to their <code>order</code> attribute <a href=\"https://rollupjs.org/plugin-development/#build-hooks\" target=\"_blank\" rel=\"noreferrer\">as usual for Rollup hooks</a>.</p>\n<h2 id=\"conditional-application\" tabindex=\"-1\">Conditional Application </h2>\n<p>By default plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the <code>apply</code> property to only invoke them during <code>'build'</code> or <code>'serve'</code>:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function myPlugin() {\n  return {\n    name: 'build-only',\n    apply: 'build', // or 'serve'\n  }\n}</pre>\n</div>\n<p>A function can also be used for more precise control:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">apply(config, { command }) {\n  // apply only on build but not for SSR\n  return command === 'build' &amp;&amp; !config.build.ssr\n}</pre>\n</div>\n<h2 id=\"rollup-plugin-compatibility\" tabindex=\"-1\">Rollup Plugin Compatibility </h2>\n<p>A fair number of Rollup plugins will work directly as a Vite plugin (e.g. <code>@rollup/plugin-alias</code> or <code>@rollup/plugin-json</code>), but not all of them, since some plugin hooks do not make sense in an unbundled dev server context.</p>\n<p>In general, as long as a Rollup plugin fits the following criteria then it should just work as a Vite plugin:</p>\n<ul>\n<li>It doesn't use the <a href=\"https://rollupjs.org/plugin-development/#moduleparsed\" target=\"_blank\" rel=\"noreferrer\"><code>moduleParsed</code></a> hook.</li>\n<li>It doesn't have strong coupling between bundle-phase hooks and output-phase hooks.</li>\n</ul>\n<p>If a Rollup plugin only makes sense for the build phase, then it can be specified under <code>build.rollupOptions.plugins</code> instead. It will work the same as a Vite plugin with <code>enforce: 'post'</code> and <code>apply: 'build'</code>.</p>\n<p>You can also augment an existing Rollup plugin with Vite-only properties:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import example from 'rollup-plugin-example'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...example(),\n      enforce: 'post',\n      apply: 'build',\n    },\n  ],\n})</pre>\n</div>\n</div>\n<h2 id=\"path-normalization\" tabindex=\"-1\">Path Normalization </h2>\n<p>Vite normalizes paths while resolving ids to use POSIX separators ( / ) while preserving the volume in Windows. On the other hand, Rollup keeps resolved paths untouched by default, so resolved ids have win32 separators ( \\ ) in Windows. However, Rollup plugins use a <a href=\"https://github.com/rollup/plugins/tree/master/packages/pluginutils#normalizepath\" target=\"_blank\" rel=\"noreferrer\"><code>normalizePath</code> utility function</a> from <code>@rollup/pluginutils</code> internally, which converts separators to POSIX before performing comparisons. This means that when these plugins are used in Vite, the <code>include</code> and <code>exclude</code> config pattern and other similar paths against resolved ids comparisons work correctly.</p>\n<p>So, for Vite plugins, when comparing paths against resolved ids it is important to first normalize the paths to use POSIX separators. An equivalent <code>normalizePath</code> utility function is exported from the <code>vite</code> module.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { normalizePath } from 'vite'\n\nnormalizePath('foo\\\\bar') // 'foo/bar'\nnormalizePath('foo/bar') // 'foo/bar'</pre>\n</div>\n<h2 id=\"filtering-include-exclude-pattern\" tabindex=\"-1\">Filtering, include/exclude pattern </h2>\n<p>Vite exposes <a href=\"https://github.com/rollup/plugins/tree/master/packages/pluginutils#createfilter\" target=\"_blank\" rel=\"noreferrer\"><code>@rollup/pluginutils</code>'s <code>createFilter</code></a> function to encourage Vite specific plugins and integrations to use the standard include/exclude filtering pattern, which is also used in Vite core itself.</p>\n<h2 id=\"client-server-communication\" tabindex=\"-1\">Client-server Communication </h2>\n<p>Since Vite 2.9, we provide some utilities for plugins to help handle the communication with clients.</p>\n<h3 id=\"server-to-client\" tabindex=\"-1\">Server to Client </h3>\n<p>On the plugin side, we could use <code>server.ws.send</code> to broadcast events to the client:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  plugins: [\n    {\n      // ...\n      configureServer(server) {\n        server.ws.on('connection', () =&gt; {\n          server.ws.send('my:greetings', { msg: 'hello' })\n        })\n      },\n    },\n  ],\n})</pre>\n</div>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p>We recommend <strong>always prefixing</strong> your event names to avoid collisions with other plugins.</p>\n</div>\n<p>On the client side, use <a href=\"api-hmr#hot-on-event-cb\"><code>hot.on</code></a> to listen to the events:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// client side\nif (import.meta.hot) {\n  import.meta.hot.on('my:greetings', (data) =&gt; {\n    console.log(data.msg) // hello\n  })\n}</pre>\n</div>\n<h3 id=\"client-to-server\" tabindex=\"-1\">Client to Server </h3>\n<p>To send events from the client to the server, we can use <a href=\"api-hmr#hot-send-event-payload\"><code>hot.send</code></a>:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// client side\nif (import.meta.hot) {\n  import.meta.hot.send('my:from-client', { msg: 'Hey!' })\n}</pre>\n</div>\n<p>Then use <code>server.ws.on</code> and listen to the events on the server side:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  plugins: [\n    {\n      // ...\n      configureServer(server) {\n        server.ws.on('my:from-client', (data, client) =&gt; {\n          console.log('Message from client:', data.msg) // Hey!\n          // reply only to the client (if needed)\n          client.send('my:ack', { msg: 'Hi! I got your message!' })\n        })\n      },\n    },\n  ],\n})</pre>\n</div>\n</div>\n<h3 id=\"typescript-for-custom-events\" tabindex=\"-1\">TypeScript for Custom Events </h3>\n<p>Internally, vite infers the type of a payload from the <code>CustomEventMap</code> interface, it is possible to type custom events by extending the interface:</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Note</strong><p>Make sure to include the <code>.d.ts</code> extension when specifying TypeScript declaration files. Otherwise, Typescript may not know which file the module is trying to extend.</p>\n</div>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"events.d.ts\">events.d.ts</span></div>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import 'vite/types/customEvent.d.ts'\n\ndeclare module 'vite/types/customEvent.d.ts' {\n  interface CustomEventMap {\n    'custom:foo': { msg: string }\n    // 'event-key': payload\n  }\n}</pre>\n</div>\n</div>\n<p>This interface extension is utilized by <code>InferCustomEventPayload&lt;T&gt;</code> to infer the payload type for event <code>T</code>. For more information on how this interface is utilized, refer to the <a href=\"api-hmr#hmr-api\">HMR API Documentation</a>.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">type CustomFooPayload = InferCustomEventPayload&lt;'custom:foo'&gt;\nimport.meta.hot?.on('custom:foo', (payload) =&gt; {\n  // The type of payload will be { msg: string }\n})\nimport.meta.hot?.on('unknown:event', (payload) =&gt; {\n  // The type of payload will be any\n})</pre>\n</div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/api-plugin\" class=\"_attribution-link\">https://vite.dev/guide/api-plugin</a>\n  </p>\n</div>\n","guide/dep-pre-bundling":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/dep-pre-bundling.md for this page in Markdown format</div>\n<h1 id=\"dependency-pre-bundling\" tabindex=\"-1\">Dependency Pre-Bundling </h1>\n<p>When you run <code>vite</code> for the first time, Vite prebundles your project dependencies before loading your site locally. It is done automatically and transparently by default.</p>\n<h2 id=\"the-why\" tabindex=\"-1\">The Why </h2>\n<p>This is Vite performing what we call \"dependency pre-bundling\". This process serves two purposes:</p>\n<ol>\n<li>\n<p><strong>CommonJS and UMD compatibility:</strong> During development, Vite's dev serves all code as native ESM. Therefore, Vite must convert dependencies that are shipped as CommonJS or UMD into ESM first.</p>\n<p>When converting CommonJS dependencies, Vite performs smart import analysis so that named imports to CommonJS modules will work as expected even if the exports are dynamically assigned (e.g. React):</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// works as expected\nimport React, { useState } from 'react'</pre>\n</div>\n</li>\n<li>\n<p><strong>Performance:</strong> Vite converts ESM dependencies with many internal modules into a single module to improve subsequent page load performance.</p>\n<p>Some packages ship their ES modules builds as many separate files importing one another. For example, <a href=\"https://unpkg.com/browse/lodash-es/\" target=\"_blank\" rel=\"noreferrer\"><code>lodash-es</code> has over 600 internal modules</a>! When we do <code>import { debounce } from 'lodash-es'</code>, the browser fires off 600+ HTTP requests at the same time! Even though the server has no problem handling them, the large amount of requests create a network congestion on the browser side, causing the page to load noticeably slower.</p>\n<p>By pre-bundling <code>lodash-es</code> into a single module, we now only need one HTTP request instead!</p>\n</li>\n</ol>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p>Dependency pre-bundling only applies in development mode, and uses <code>esbuild</code> to convert dependencies to ESM. In production builds, <code>@rollup/plugin-commonjs</code> is used instead.</p>\n</div>\n<h2 id=\"automatic-dependency-discovery\" tabindex=\"-1\">Automatic Dependency Discovery </h2>\n<p>If an existing cache is not found, Vite will crawl your source code and automatically discover dependency imports (i.e. \"bare imports\" that expect to be resolved from <code>node_modules</code>) and use these found imports as entry points for the pre-bundle. The pre-bundling is performed with <code>esbuild</code> so it's typically very fast.</p>\n<p>After the server has already started, if a new dependency import is encountered that isn't already in the cache, Vite will re-run the dep bundling process and reload the page if needed.</p>\n<h2 id=\"monorepos-and-linked-dependencies\" tabindex=\"-1\">Monorepos and Linked Dependencies </h2>\n<p>In a monorepo setup, a dependency may be a linked package from the same repo. Vite automatically detects dependencies that are not resolved from <code>node_modules</code> and treats the linked dep as source code. It will not attempt to bundle the linked dep, and will analyze the linked dep's dependency list instead.</p>\n<p>However, this requires the linked dep to be exported as ESM. If not, you can add the dependency to <a href=\"../config/dep-optimization-options#optimizedeps-include\"><code>optimizeDeps.include</code></a> and <a href=\"../config/build-options#build-commonjsoptions\"><code>build.commonjsOptions.include</code></a> in your config.</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  optimizeDeps: {\n    include: ['linked-dep'],\n  },\n  build: {\n    commonjsOptions: {\n      include: [/linked-dep/, /node_modules/],\n    },\n  },\n})</pre>\n</div>\n</div>\n<p>When making changes to the linked dep, restart the dev server with the <code>--force</code> command line option for the changes to take effect.</p>\n<h2 id=\"customizing-the-behavior\" tabindex=\"-1\">Customizing the Behavior </h2>\n<p>The default dependency discovery heuristics may not always be desirable. In cases where you want to explicitly include/exclude dependencies from the list, use the <a href=\"../config/dep-optimization-options\"><code>optimizeDeps</code> config options</a>.</p>\n<p>A typical use case for <code>optimizeDeps.include</code> or <code>optimizeDeps.exclude</code> is when you have an import that is not directly discoverable in the source code. For example, maybe the import is created as a result of a plugin transform. This means Vite won't be able to discover the import on the initial scan - it can only discover it after the file is requested by the browser and transformed. This will cause the server to immediately re-bundle after server start.</p>\n<p>Both <code>include</code> and <code>exclude</code> can be used to deal with this. If the dependency is large (with many internal modules) or is CommonJS, then you should include it; If the dependency is small and is already valid ESM, you can exclude it and let the browser load it directly.</p>\n<p>You can further customize esbuild too with the <a href=\"../config/dep-optimization-options#optimizedeps-esbuildoptions\"><code>optimizeDeps.esbuildOptions</code> option</a>. For example, adding an esbuild plugin to handle special files in dependencies or changing the <a href=\"https://esbuild.github.io/api/#target\" target=\"_blank\" rel=\"noreferrer\">build <code>target</code></a>.</p>\n<h2 id=\"caching\" tabindex=\"-1\">Caching </h2>\n<h3 id=\"file-system-cache\" tabindex=\"-1\">File System Cache </h3>\n<p>Vite caches the pre-bundled dependencies in <code>node_modules/.vite</code>. It determines whether it needs to re-run the pre-bundling step based on a few sources:</p>\n<ul>\n<li>Package manager lockfile content, e.g. <code>package-lock.json</code>, <code>yarn.lock</code>, <code>pnpm-lock.yaml</code> or <code>bun.lock</code>.</li>\n<li>Patches folder modification time.</li>\n<li>Relevant fields in your <code>vite.config.js</code>, if present.</li>\n<li>\n<code>NODE_ENV</code> value.</li>\n</ul>\n<p>The pre-bundling step will only need to be re-run when one of the above has changed.</p>\n<p>If for some reason you want to force Vite to re-bundle deps, you can either start the dev server with the <code>--force</code> command line option, or manually delete the <code>node_modules/.vite</code> cache directory.</p>\n<h3 id=\"browser-cache\" tabindex=\"-1\">Browser Cache </h3>\n<p>Resolved dependency requests are strongly cached with HTTP headers <code>max-age=31536000,immutable</code> to improve page reload performance during dev. Once cached, these requests will never hit the dev server again. They are auto invalidated by the appended version query if a different version is installed (as reflected in your package manager lockfile). If you want to debug your dependencies by making local edits, you can:</p>\n<ol>\n<li>Temporarily disable cache via the Network tab of your browser devtools.</li>\n<li>Restart Vite dev server with the <code>--force</code> flag to re-bundle the deps.</li>\n<li>Reload the page.</li>\n</ol><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/dep-pre-bundling\" class=\"_attribution-link\">https://vite.dev/guide/dep-pre-bundling</a>\n  </p>\n</div>\n","guide/performance":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/performance.md for this page in Markdown format</div>\n<h1 id=\"performance\" tabindex=\"-1\">Performance </h1>\n<p>While Vite is fast by default, performance issues can creep in as the project's requirements grow. This guide aims to help you identify and fix common performance issues, such as:</p>\n<ul>\n<li>Slow server starts</li>\n<li>Slow page loads</li>\n<li>Slow builds</li>\n</ul>\n<h2 id=\"review-your-browser-setup\" tabindex=\"-1\">Review Your Browser Setup </h2>\n<p>Some browser extensions may interfere with requests and slow down startup and reload times for large apps, especially when using browser dev tools. We recommend creating a dev-only profile without extensions, or switch to incognito mode, while using Vite's dev server in these cases. Incognito mode should also be faster than a regular profile without extensions.</p>\n<p>The Vite dev server does hard caching of pre-bundled dependencies and implements fast 304 responses for source code. Disabling the cache while the Browser Dev Tools are open can have a big impact on startup and full-page reload times. Please check that \"Disable Cache\" isn't enabled while you work with the Vite server.</p>\n<h2 id=\"audit-configured-vite-plugins\" tabindex=\"-1\">Audit Configured Vite Plugins </h2>\n<p>Vite's internal and official plugins are optimized to do the least amount of work possible while providing compatibility with the broader ecosystem. For example, code transformations use regex in dev, but do a complete parse in build to ensure correctness.</p>\n<p>However, the performance of community plugins is out of Vite's control, which may affect the developer experience. Here are a few things you can look out for when using additional Vite plugins:</p>\n<ol>\n<li><p>Large dependencies that are only used in certain cases should be dynamically imported to reduce the Node.js startup time. Example refactors: <a href=\"https://github.com/vitejs/vite-plugin-react/pull/212\" target=\"_blank\" rel=\"noreferrer\">vite-plugin-react#212</a> and <a href=\"https://github.com/vite-pwa/vite-plugin-pwa/pull/244\" target=\"_blank\" rel=\"noreferrer\">vite-plugin-pwa#224</a>.</p></li>\n<li><p>The <code>buildStart</code>, <code>config</code>, and <code>configResolved</code> hooks should not run long and extensive operations. These hooks are awaited during dev server startup, which delays when you can access the site in the browser.</p></li>\n<li>\n<p>The <code>resolveId</code>, <code>load</code>, and <code>transform</code> hooks may cause some files to load slower than others. While sometimes unavoidable, it's still worth checking for possible areas to optimize. For example, checking if the <code>code</code> contains a specific keyword, or the <code>id</code> matches a specific extension, before doing the full transformation.</p>\n<p>The longer it takes to transform a file, the more significant the request waterfall will be when loading the site in the browser.</p>\n<p>You can inspect the duration it takes to transform a file using <code>vite --debug plugin-transform</code> or <a href=\"https://github.com/antfu/vite-plugin-inspect\" target=\"_blank\" rel=\"noreferrer\">vite-plugin-inspect</a>. Note that as asynchronous operations tend to provide inaccurate timings, you should treat the numbers as a rough estimate, but it should still reveal the more expensive operations.</p>\n</li>\n</ol>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Profiling</strong><p>You can run <code>vite --profile</code>, visit the site, and press <code>p + enter</code> in your terminal to record a <code>.cpuprofile</code>. A tool like <a href=\"https://www.speedscope.app\" target=\"_blank\" rel=\"noreferrer\">speedscope</a> can then be used to inspect the profile and identify the bottlenecks. You can also <a href=\"https://chat.vite.dev\" target=\"_blank\" rel=\"noreferrer\">share the profiles</a> with the Vite team to help us identify performance issues.</p>\n</div>\n<h2 id=\"reduce-resolve-operations\" tabindex=\"-1\">Reduce Resolve Operations </h2>\n<p>Resolving import paths can be an expensive operation when hitting its worst case often. For example, Vite supports \"guessing\" import paths with the <a href=\"../config/shared-options#resolve-extensions\"><code>resolve.extensions</code></a> option, which defaults to <code>['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']</code>.</p>\n<p>When you try to import <code>./Component.jsx</code> with <code>import './Component'</code>, Vite will run these steps to resolve it:</p>\n<ol>\n<li>Check if <code>./Component</code> exists, no.</li>\n<li>Check if <code>./Component.mjs</code> exists, no.</li>\n<li>Check if <code>./Component.js</code> exists, no.</li>\n<li>Check if <code>./Component.mts</code> exists, no.</li>\n<li>Check if <code>./Component.ts</code> exists, no.</li>\n<li>Check if <code>./Component.jsx</code> exists, yes!</li>\n</ol>\n<p>As shown, a total of 6 filesystem checks is required to resolve an import path. The more implicit imports you have, the more time it adds up to resolve the paths.</p>\n<p>Hence, it's usually better to be explicit with your import paths, e.g. <code>import './Component.jsx'</code>. You can also narrow down the list for <code>resolve.extensions</code> to reduce the general filesystem checks, but you have to make sure it works for files in <code>node_modules</code> too.</p>\n<p>If you're a plugin author, make sure to only call <a href=\"https://rollupjs.org/plugin-development/#this-resolve\" target=\"_blank\" rel=\"noreferrer\"><code>this.resolve</code></a> when needed to reduce the number of checks above.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">TypeScript</strong><p>If you are using TypeScript, enable <code>\"moduleResolution\": \"bundler\"</code> and <code>\"allowImportingTsExtensions\": true</code> in your <code>tsconfig.json</code>'s <code>compilerOptions</code> to use <code>.ts</code> and <code>.tsx</code> extensions directly in your code.</p>\n</div>\n<h2 id=\"avoid-barrel-files\" tabindex=\"-1\">Avoid Barrel Files </h2>\n<p>Barrel files are files that re-export the APIs of other files in the same directory. For example:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"src/utils/index.js\">src/utils/index.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export * from './color.js'\nexport * from './dom.js'\nexport * from './slash.js'</pre>\n</div>\n</div>\n<p>When you only import an individual API, e.g. <code>import { slash } from './utils'</code>, all the files in that barrel file need to be fetched and transformed as they may contain the <code>slash</code> API and may also contain side-effects that run on initialization. This means you're loading more files than required on the initial page load, resulting in a slower page load.</p>\n<p>If possible, you should avoid barrel files and import the individual APIs directly, e.g. <code>import { slash } from './utils/slash.js'</code>. You can read <a href=\"https://github.com/vitejs/vite/issues/8237\" target=\"_blank\" rel=\"noreferrer\">issue #8237</a> for more information.</p>\n<h2 id=\"warm-up-frequently-used-files\" tabindex=\"-1\">Warm Up Frequently Used Files </h2>\n<p>The Vite dev server only transforms files as requested by the browser, which allows it to start up quickly and only apply transformations for used files. It can also pre-transform files if it anticipates certain files will be requested shortly. However, request waterfalls may still happen if some files take longer to transform than others. For example:</p>\n<p>Given an import graph where the left file imports the right file:</p>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">main.js -&gt; BigComponent.vue -&gt; big-utils.js -&gt; large-data.json</pre>\n</div>\n<p>The import relationship can only be known after the file is transformed. If <code>BigComponent.vue</code> takes some time to transform, <code>big-utils.js</code> has to wait for its turn, and so on. This causes an internal waterfall even with pre-transformation built-in.</p>\n<p>Vite allows you to warm up files that you know are frequently used, e.g. <code>big-utils.js</code>, using the <a href=\"../config/server-options#server-warmup\"><code>server.warmup</code></a> option. This way <code>big-utils.js</code> will be ready and cached to be served immediately when requested.</p>\n<p>You can find files that are frequently used by running <code>vite --debug transform</code> and inspect the logs:</p>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">vite:transform 28.72ms /@vite/client +1ms\nvite:transform 62.95ms /src/components/BigComponent.vue +1ms\nvite:transform 102.54ms /src/utils/big-utils.js +1ms</pre>\n</div>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  server: {\n    warmup: {\n      clientFiles: [\n        './src/components/BigComponent.vue',\n        './src/utils/big-utils.js',\n      ],\n    },\n  },\n})</pre>\n</div>\n</div>\n<p>Note that you should only warm up files that are frequently used to not overload the Vite dev server on startup. Check the <a href=\"../config/server-options#server-warmup\"><code>server.warmup</code></a> option for more information.</p>\n<p>Using <a href=\"../config/server-options#server-open\"><code>--open</code> or <code>server.open</code></a> also provides a performance boost, as Vite will automatically warm up the entry point of your app or the provided URL to open.</p>\n<h2 id=\"use-lesser-or-native-tooling\" tabindex=\"-1\">Use Lesser or Native Tooling </h2>\n<p>Keeping Vite fast with a growing codebase is about reducing the amount of work for the source files (JS/TS/CSS).</p>\n<p>Examples of doing less work:</p>\n<ul>\n<li>Use CSS instead of Sass/Less/Stylus when possible (nesting can be handled by PostCSS)</li>\n<li>Don't transform SVGs into UI framework components (React, Vue, etc.). Import them as strings or URLs instead.</li>\n<li>When using <code>@vitejs/plugin-react</code>, avoid configuring the Babel options, so it skips the transformation during build (only esbuild will be used).</li>\n</ul>\n<p>Examples of using native tooling:</p>\n<p>Using native tooling often brings larger installation size and as so is not the default when starting a new Vite project. But it may be worth the cost for larger applications.</p>\n<ul>\n<li>Use <a href=\"rolldown\">Rolldown instead of Rollup and esbuild</a> for faster builds and a more aligned experience between dev and build.</li>\n<li>Try out the experimental support for <a href=\"https://github.com/vitejs/vite/discussions/13835\" target=\"_blank\" rel=\"noreferrer\">LightningCSS</a>\n</li>\n<li>Use <a href=\"https://github.com/vitejs/vite-plugin-react-swc\" target=\"_blank\" rel=\"noreferrer\"><code>@vitejs/plugin-react-swc</code></a> in place of <code>@vitejs/plugin-react</code>.</li>\n</ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/performance\" class=\"_attribution-link\">https://vite.dev/guide/performance</a>\n  </p>\n</div>\n","guide/api-hmr":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/api-hmr.md for this page in Markdown format</div>\n<h1 id=\"hmr-api\" tabindex=\"-1\">HMR API </h1>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Note</strong><p>This is the client HMR API. For handling HMR update in plugins, see <a href=\"api-plugin#handlehotupdate\">handleHotUpdate</a>.</p>\n<p>The manual HMR API is primarily intended for framework and tooling authors. As an end user, HMR is likely already handled for you in the framework specific starter templates.</p>\n</div>\n<p>Vite exposes its manual HMR API via the special <code>import.meta.hot</code> object:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface ImportMeta {\n  readonly hot?: ViteHotContext\n}\n\ninterface ViteHotContext {\n  readonly data: any\n\n  accept(): void\n  accept(cb: (mod: ModuleNamespace | undefined) =&gt; void): void\n  accept(dep: string, cb: (mod: ModuleNamespace | undefined) =&gt; void): void\n  accept(\n    deps: readonly string[],\n    cb: (mods: Array&lt;ModuleNamespace | undefined&gt;) =&gt; void,\n  ): void\n\n  dispose(cb: (data: any) =&gt; void): void\n  prune(cb: (data: any) =&gt; void): void\n  invalidate(message?: string): void\n\n  on&lt;T extends CustomEventName&gt;(\n    event: T,\n    cb: (payload: InferCustomEventPayload&lt;T&gt;) =&gt; void,\n  ): void\n  off&lt;T extends CustomEventName&gt;(\n    event: T,\n    cb: (payload: InferCustomEventPayload&lt;T&gt;) =&gt; void,\n  ): void\n  send&lt;T extends CustomEventName&gt;(\n    event: T,\n    data?: InferCustomEventPayload&lt;T&gt;,\n  ): void\n}</pre>\n</div>\n<h2 id=\"required-conditional-guard\" tabindex=\"-1\">Required Conditional Guard </h2>\n<p>First of all, make sure to guard all HMR API usage with a conditional block so that the code can be tree-shaken in production:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">if (import.meta.hot) {\n  // HMR code\n}</pre>\n</div>\n<h2 id=\"intellisense-for-typescript\" tabindex=\"-1\">IntelliSense for TypeScript </h2>\n<p>Vite provides type definitions for <code>import.meta.hot</code> in <a href=\"https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts\" target=\"_blank\" rel=\"noreferrer\"><code>vite/client.d.ts</code></a>. You can create an <code>vite-env.d.ts</code> in the <code>src</code> directory so TypeScript picks up the type definitions:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite-env.d.ts\">vite-env.d.ts</span></div>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">/// &lt;reference types=\"vite/client\" /&gt;</pre>\n</div>\n</div>\n<h2 id=\"hot-accept-cb\" tabindex=\"-1\">\n<code>hot.accept(cb)</code> </h2>\n<p>For a module to self-accept, use <code>import.meta.hot.accept</code> with a callback which receives the updated module:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export const count = 1\n\nif (import.meta.hot) {\n  import.meta.hot.accept((newModule) =&gt; {\n    if (newModule) {\n      // newModule is undefined when SyntaxError happened\n      console.log('updated: count is now ', newModule.count)\n    }\n  })\n}</pre>\n</div>\n<p>A module that \"accepts\" hot updates is considered an <strong>HMR boundary</strong>.</p>\n<p>Vite's HMR does not actually swap the originally imported module: if an HMR boundary module re-exports imports from a dep, then it is responsible for updating those re-exports (and these exports must be using <code>let</code>). In addition, importers up the chain from the boundary module will not be notified of the change. This simplified HMR implementation is sufficient for most dev use cases, while allowing us to skip the expensive work of generating proxy modules.</p>\n<p>Vite requires that the call to this function appears as <code>import.meta.hot.accept(</code> (whitespace-sensitive) in the source code in order for the module to accept update. This is a requirement of the static analysis that Vite does to enable HMR support for a module.</p>\n<h2 id=\"hot-accept-deps-cb\" tabindex=\"-1\">\n<code>hot.accept(deps, cb)</code> </h2>\n<p>A module can also accept updates from direct dependencies without reloading itself:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { foo } from './foo.js'\n\nfoo()\n\nif (import.meta.hot) {\n  import.meta.hot.accept('./foo.js', (newFoo) =&gt; {\n    // the callback receives the updated './foo.js' module\n    newFoo?.foo()\n  })\n\n  // Can also accept an array of dep modules:\n  import.meta.hot.accept(\n    ['./foo.js', './bar.js'],\n    ([newFooModule, newBarModule]) =&gt; {\n      // The callback receives an array where only the updated module is\n      // non null. If the update was not successful (syntax error for ex.),\n      // the array is empty\n    },\n  )\n}</pre>\n</div>\n<h2 id=\"hot-dispose-cb\" tabindex=\"-1\">\n<code>hot.dispose(cb)</code> </h2>\n<p>A self-accepting module or a module that expects to be accepted by others can use <code>hot.dispose</code> to clean-up any persistent side effects created by its updated copy:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function setupSideEffect() {}\n\nsetupSideEffect()\n\nif (import.meta.hot) {\n  import.meta.hot.dispose((data) =&gt; {\n    // cleanup side effect\n  })\n}</pre>\n</div>\n<h2 id=\"hot-prune-cb\" tabindex=\"-1\">\n<code>hot.prune(cb)</code> </h2>\n<p>Register a callback that will call when the module is no longer imported on the page. Compared to <code>hot.dispose</code>, this can be used if the source code cleans up side-effects by itself on updates and you only need to clean-up when it's removed from the page. Vite currently uses this for <code>.css</code> imports.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function setupOrReuseSideEffect() {}\n\nsetupOrReuseSideEffect()\n\nif (import.meta.hot) {\n  import.meta.hot.prune((data) =&gt; {\n    // cleanup side effect\n  })\n}</pre>\n</div>\n<h2 id=\"hot-data\" tabindex=\"-1\">\n<code>hot.data</code> </h2>\n<p>The <code>import.meta.hot.data</code> object is persisted across different instances of the same updated module. It can be used to pass on information from a previous version of the module to the next one.</p>\n<p>Note that re-assignment of <code>data</code> itself is not supported. Instead, you should mutate properties of the <code>data</code> object so information added from other handlers are preserved.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// ok\nimport.meta.hot.data.someValue = 'hello'\n\n// not supported\nimport.meta.hot.data = { someValue: 'hello' }</pre>\n</div>\n<h2 id=\"hot-decline\" tabindex=\"-1\">\n<code>hot.decline()</code> </h2>\n<p>This is currently a noop and is there for backward compatibility. This could change in the future if there is a new usage for it. To indicate that the module is not hot-updatable, use <code>hot.invalidate()</code>.</p>\n<h2 id=\"hot-invalidate-message-string\" tabindex=\"-1\">\n<code>hot.invalidate(message?: string)</code> </h2>\n<p>A self-accepting module may realize during runtime that it can't handle a HMR update, and so the update needs to be forcefully propagated to importers. By calling <code>import.meta.hot.invalidate()</code>, the HMR server will invalidate the importers of the caller, as if the caller wasn't self-accepting. This will log a message both in the browser console and in the terminal. You can pass a message to give some context on why the invalidation happened.</p>\n<p>Note that you should always call <code>import.meta.hot.accept</code> even if you plan to call <code>invalidate</code> immediately afterwards, or else the HMR client won't listen for future changes to the self-accepting module. To communicate your intent clearly, we recommend calling <code>invalidate</code> within the <code>accept</code> callback like so:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import.meta.hot.accept((module) =&gt; {\n  // You may use the new module instance to decide whether to invalidate.\n  if (cannotHandleUpdate(module)) {\n    import.meta.hot.invalidate()\n  }\n})</pre>\n</div>\n<h2 id=\"hot-on-event-cb\" tabindex=\"-1\">\n<code>hot.on(event, cb)</code> </h2>\n<p>Listen to an HMR event.</p>\n<p>The following HMR events are dispatched by Vite automatically:</p>\n<ul>\n<li>\n<code>'vite:beforeUpdate'</code> when an update is about to be applied (e.g. a module will be replaced)</li>\n<li>\n<code>'vite:afterUpdate'</code> when an update has just been applied (e.g. a module has been replaced)</li>\n<li>\n<code>'vite:beforeFullReload'</code> when a full reload is about to occur</li>\n<li>\n<code>'vite:beforePrune'</code> when modules that are no longer needed are about to be pruned</li>\n<li>\n<code>'vite:invalidate'</code> when a module is invalidated with <code>import.meta.hot.invalidate()</code>\n</li>\n<li>\n<code>'vite:error'</code> when an error occurs (e.g. syntax error)</li>\n<li>\n<code>'vite:ws:disconnect'</code> when the WebSocket connection is lost</li>\n<li>\n<code>'vite:ws:connect'</code> when the WebSocket connection is (re-)established</li>\n</ul>\n<p>Custom HMR events can also be sent from plugins. See <a href=\"api-plugin#handlehotupdate\">handleHotUpdate</a> for more details.</p>\n<h2 id=\"hot-off-event-cb\" tabindex=\"-1\">\n<code>hot.off(event, cb)</code> </h2>\n<p>Remove callback from the event listeners.</p>\n<h2 id=\"hot-send-event-data\" tabindex=\"-1\">\n<code>hot.send(event, data)</code> </h2>\n<p>Send custom events back to Vite's dev server.</p>\n<p>If called before connected, the data will be buffered and sent once the connection is established.</p>\n<p>See <a href=\"api-plugin#client-server-communication\">Client-server Communication</a> for more details, including a section on <a href=\"api-plugin#typescript-for-custom-events\">Typing Custom Events</a>.</p>\n<h2 id=\"further-reading\" tabindex=\"-1\">Further Reading </h2>\n<p>If you'd like to learn more about how to use the HMR API and how it works under-the-hood. Check out these resources:</p>\n<ul><li><a href=\"https://bjornlu.com/blog/hot-module-replacement-is-easy\" target=\"_blank\" rel=\"noreferrer\">Hot Module Replacement is Easy</a></li></ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/api-hmr\" class=\"_attribution-link\">https://vite.dev/guide/api-hmr</a>\n  </p>\n</div>\n","guide/api-environment-instances":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/api-environment-instances.md for this page in Markdown format</div>\n<h1 id=\"using-environment-instances\" tabindex=\"-1\">Using <code>Environment</code> Instances </h1>\n<div class=\"info custom-block\">\n<strong class=\"custom-block-title\">Release Candidate</strong><p>The Environment API is generally in the release candidate phase. We'll maintain stability in the APIs between major releases to allow the ecosystem to experiment and build upon them. However, note that <a href=\"../changes/index#considering\">some specific APIs</a> are still considered experimental.</p>\n<p>We plan to stabilize these new APIs (with potential breaking changes) in a future major release once downstream projects have had time to experiment with the new features and validate them.</p>\n<p>Resources:</p>\n<ul>\n<li>\n<a href=\"https://github.com/vitejs/vite/discussions/16358\" target=\"_blank\" rel=\"noreferrer\">Feedback discussion</a> where we are gathering feedback about the new APIs.</li>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/16471\" target=\"_blank\" rel=\"noreferrer\">Environment API PR</a> where the new API were implemented and reviewed.</li>\n</ul>\n<p>Please share your feedback with us.</p>\n</div>\n<h2 id=\"accessing-the-environments\" tabindex=\"-1\">Accessing the Environments </h2>\n<p>During dev, the available environments in a dev server can be accessed using <code>server.environments</code>:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// create the server, or get it from the configureServer hook\nconst server = await createServer(/* options */)\n\nconst clientEnvironment = server.environments.client\nclientEnvironment.transformRequest(url)\nconsole.log(server.environments.ssr.moduleGraph)</pre>\n</div>\n<p>You can also access the current environment from plugins. See the <a href=\"api-environment-plugins#accessing-the-current-environment-in-hooks\">Environment API for Plugins</a> for more details.</p>\n<h2 id=\"devenvironment-class\" tabindex=\"-1\">\n<code>DevEnvironment</code> class </h2>\n<p>During dev, each environment is an instance of the <code>DevEnvironment</code> class:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">class DevEnvironment {\n  /**\n   * Unique identifier for the environment in a Vite server.\n   * By default Vite exposes 'client' and 'ssr' environments.\n   */\n  name: string\n  /**\n   * Communication channel to send and receive messages from the\n   * associated module runner in the target runtime.\n   */\n  hot: NormalizedHotChannel\n  /**\n   * Graph of module nodes, with the imported relationship between\n   * processed modules and the cached result of the processed code.\n   */\n  moduleGraph: EnvironmentModuleGraph\n  /**\n   * Resolved plugins for this environment, including the ones\n   * created using the per-environment `create` hook\n   */\n  plugins: Plugin[]\n  /**\n   * Allows to resolve, load, and transform code through the\n   * environment plugins pipeline\n   */\n  pluginContainer: EnvironmentPluginContainer\n  /**\n   * Resolved config options for this environment. Options at the server\n   * global scope are taken as defaults for all environments, and can\n   * be overridden (resolve conditions, external, optimizedDeps)\n   */\n  config: ResolvedConfig &amp; ResolvedDevEnvironmentOptions\n\n  constructor(\n    name: string,\n    config: ResolvedConfig,\n    context: DevEnvironmentContext,\n  )\n\n  /**\n   * Resolve the URL to an id, load it, and process the code using the\n   * plugins pipeline. The module graph is also updated.\n   */\n  async transformRequest(url: string): Promise&lt;TransformResult | null&gt;\n\n  /**\n   * Register a request to be processed with low priority. This is useful\n   * to avoid waterfalls. The Vite server has information about the\n   * imported modules by other requests, so it can warmup the module graph\n   * so the modules are already processed when they are requested.\n   */\n  async warmupRequest(url: string): Promise&lt;void&gt;\n}</pre>\n</div>\n<p>With <code>DevEnvironmentContext</code> being:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface DevEnvironmentContext {\n  hot: boolean\n  transport?: HotChannel | WebSocketServer\n  options?: EnvironmentOptions\n  remoteRunner?: {\n    inlineSourceMap?: boolean\n  }\n  depsOptimizer?: DepsOptimizer\n}</pre>\n</div>\n<p>and with <code>TransformResult</code> being:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface TransformResult {\n  code: string\n  map: SourceMap | { mappings: '' } | null\n  etag?: string\n  deps?: string[]\n  dynamicDeps?: string[]\n}</pre>\n</div>\n<p>An environment instance in the Vite server lets you process a URL using the <code>environment.transformRequest(url)</code> method. This function will use the plugin pipeline to resolve the <code>url</code> to a module <code>id</code>, load it (reading the file from the file system or through a plugin that implements a virtual module), and then transform the code. While transforming the module, imports and other metadata will be recorded in the environment module graph by creating or updating the corresponding module node. When processing is done, the transform result is also stored in the module.</p>\n<div class=\"info custom-block\">\n<strong class=\"custom-block-title\">transformRequest naming</strong><p>We are using <code>transformRequest(url)</code> and <code>warmupRequest(url)</code> in the current version of this proposal so it is easier to discuss and understand for users used to Vite's current API. Before releasing, we can take the opportunity to review these names too. For example, it could be named <code>environment.processModule(url)</code> or <code>environment.loadModule(url)</code> taking a page from Rollup's <code>context.load(id)</code> in plugin hooks. For the moment, we think keeping the current names and delaying this discussion is better.</p>\n</div>\n<h2 id=\"separate-module-graphs\" tabindex=\"-1\">Separate Module Graphs </h2>\n<p>Each environment has an isolated module graph. All module graphs have the same signature, so generic algorithms can be implemented to crawl or query the graph without depending on the environment. <code>hotUpdate</code> is a good example. When a file is modified, the module graph of each environment will be used to discover the affected modules and perform HMR for each environment independently.</p>\n<div class=\"info custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">INFO</strong><p>Vite v5 had a mixed Client and SSR module graph. Given an unprocessed or invalidated node, it isn't possible to know if it corresponds to the Client, SSR, or both environments. Module nodes have some properties prefixed, like <code>clientImportedModules</code> and <code>ssrImportedModules</code> (and <code>importedModules</code> that returns the union of both). <code>importers</code> contains all importers from both the Client and SSR environment for each module node. A module node also has <code>transformResult</code> and <code>ssrTransformResult</code>. A backward compatibility layer allows the ecosystem to migrate from the deprecated <code>server.moduleGraph</code>.</p>\n</div>\n<p>Each module is represented by a <code>EnvironmentModuleNode</code> instance. Modules may be registered in the graph without yet being processed (<code>transformResult</code> would be <code>null</code> in that case). <code>importers</code> and <code>importedModules</code> are also updated after the module is processed.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">class EnvironmentModuleNode {\n  environment: string\n\n  url: string\n  id: string | null = null\n  file: string | null = null\n\n  type: 'js' | 'css'\n\n  importers = new Set&lt;EnvironmentModuleNode&gt;()\n  importedModules = new Set&lt;EnvironmentModuleNode&gt;()\n  importedBindings: Map&lt;string, Set&lt;string&gt;&gt; | null = null\n\n  info?: ModuleInfo\n  meta?: Record&lt;string, any&gt;\n  transformResult: TransformResult | null = null\n\n  acceptedHmrDeps = new Set&lt;EnvironmentModuleNode&gt;()\n  acceptedHmrExports: Set&lt;string&gt; | null = null\n  isSelfAccepting?: boolean\n  lastHMRTimestamp = 0\n  lastInvalidationTimestamp = 0\n}</pre>\n</div>\n<p><code>environment.moduleGraph</code> is an instance of <code>EnvironmentModuleGraph</code>:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export class EnvironmentModuleGraph {\n  environment: string\n\n  urlToModuleMap = new Map&lt;string, EnvironmentModuleNode&gt;()\n  idToModuleMap = new Map&lt;string, EnvironmentModuleNode&gt;()\n  etagToModuleMap = new Map&lt;string, EnvironmentModuleNode&gt;()\n  fileToModulesMap = new Map&lt;string, Set&lt;EnvironmentModuleNode&gt;&gt;()\n\n  constructor(\n    environment: string,\n    resolveId: (url: string) =&gt; Promise&lt;PartialResolvedId | null&gt;,\n  )\n\n  async getModuleByUrl(\n    rawUrl: string,\n  ): Promise&lt;EnvironmentModuleNode | undefined&gt;\n\n  getModuleById(id: string): EnvironmentModuleNode | undefined\n\n  getModulesByFile(file: string): Set&lt;EnvironmentModuleNode&gt; | undefined\n\n  onFileChange(file: string): void\n\n  onFileDelete(file: string): void\n\n  invalidateModule(\n    mod: EnvironmentModuleNode,\n    seen: Set&lt;EnvironmentModuleNode&gt; = new Set(),\n    timestamp: number = monotonicDateNow(),\n    isHmr: boolean = false,\n  ): void\n\n  invalidateAll(): void\n\n  async ensureEntryFromUrl(\n    rawUrl: string,\n    setIsSelfAccepting = true,\n  ): Promise&lt;EnvironmentModuleNode&gt;\n\n  createFileOnlyEntry(file: string): EnvironmentModuleNode\n\n  async resolveUrl(url: string): Promise&lt;ResolvedUrl&gt;\n\n  updateModuleTransformResult(\n    mod: EnvironmentModuleNode,\n    result: TransformResult | null,\n  ): void\n\n  getModuleByEtag(etag: string): EnvironmentModuleNode | undefined\n}</pre>\n</div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/api-environment-instances\" class=\"_attribution-link\">https://vite.dev/guide/api-environment-instances</a>\n  </p>\n</div>\n","guide/troubleshooting":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/troubleshooting.md for this page in Markdown format</div>\n<h1 id=\"troubleshooting\" tabindex=\"-1\">Troubleshooting </h1>\n<p>See <a href=\"https://rollupjs.org/troubleshooting/\" target=\"_blank\" rel=\"noreferrer\">Rollup's troubleshooting guide</a> for more information too.</p>\n<p>If the suggestions here don't work, please try posting questions on <a href=\"https://github.com/vitejs/vite/discussions\" target=\"_blank\" rel=\"noreferrer\">GitHub Discussions</a> or in the <code>#help</code> channel of <a href=\"https://chat.vite.dev\" target=\"_blank\" rel=\"noreferrer\">Vite Land Discord</a>.</p>\n<h2 id=\"cli\" tabindex=\"-1\">CLI </h2>\n<h3 id=\"error-cannot-find-module-c-foo-bar-baz-vite-bin-vite-js\" tabindex=\"-1\">\n<code>Error: Cannot find module 'C:\\foo\\bar&amp;baz\\vite\\bin\\vite.js'</code> </h3>\n<p>The path to your project folder may include <code>&amp;</code>, which doesn't work with <code>npm</code> on Windows (<a href=\"https://github.com/npm/cmd-shim/issues/45\" target=\"_blank\" rel=\"noreferrer\">npm/cmd-shim#45</a>).</p>\n<p>You will need to either:</p>\n<ul>\n<li>Switch to another package manager (e.g. <code>pnpm</code>, <code>yarn</code>)</li>\n<li>Remove <code>&amp;</code> from the path to your project</li>\n</ul>\n<h2 id=\"config\" tabindex=\"-1\">Config </h2>\n<h3 id=\"this-package-is-esm-only\" tabindex=\"-1\">This package is ESM only </h3>\n<p>When importing a ESM only package by <code>require</code>, the following error happens.</p>\n<blockquote><p>Failed to resolve \"foo\". This package is ESM only but it was tried to load by <code>require</code>.</p></blockquote>\n<blockquote><p>Error [ERR_REQUIRE_ESM]: require() of ES Module /path/to/dependency.js from /path/to/vite.config.js not supported. Instead change the require of index.js in /path/to/vite.config.js to a dynamic import() which is available in all CommonJS modules.</p></blockquote>\n<p>In Node.js &lt;=22, ESM files cannot be loaded by <a href=\"https://nodejs.org/docs/latest-v22.x/api/esm.html#require\" target=\"_blank\" rel=\"noreferrer\"><code>require</code></a> by default.</p>\n<p>While it may work using <a href=\"https://nodejs.org/docs/latest-v22.x/api/modules.html#loading-ecmascript-modules-using-require\" target=\"_blank\" rel=\"noreferrer\"><code>--experimental-require-module</code></a>, or Node.js &gt;22, or in other runtimes, we still recommend converting your config to ESM by either:</p>\n<ul>\n<li>adding <code>\"type\": \"module\"</code> to the nearest <code>package.json</code>\n</li>\n<li>renaming <code>vite.config.js</code>/<code>vite.config.ts</code> to <code>vite.config.mjs</code>/<code>vite.config.mts</code>\n</li>\n</ul>\n<h2 id=\"dev-server\" tabindex=\"-1\">Dev Server </h2>\n<h3 id=\"requests-are-stalled-forever\" tabindex=\"-1\">Requests are stalled forever </h3>\n<p>If you are using Linux, file descriptor limits and inotify limits may be causing the issue. As Vite does not bundle most of the files, browsers may request many files which require many file descriptors, going over the limit.</p>\n<p>To solve this:</p>\n<ul>\n<li>\n<p>Increase file descriptor limit by <code>ulimit</code></p>\n<div class=\"language-shell\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\"># Check current limit\n$ ulimit -Sn\n# Change limit (temporary)\n$ ulimit -Sn 10000 # You might need to change the hard limit too\n# Restart your browser</pre>\n</div>\n</li>\n<li>\n<p>Increase the following inotify related limits by <code>sysctl</code></p>\n<div class=\"language-shell\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\"># Check current limits\n$ sysctl fs.inotify\n# Change limits (temporary)\n$ sudo sysctl fs.inotify.max_queued_events=16384\n$ sudo sysctl fs.inotify.max_user_instances=8192\n$ sudo sysctl fs.inotify.max_user_watches=524288</pre>\n</div>\n</li>\n</ul>\n<p>If the above steps don't work, you can try adding <code>DefaultLimitNOFILE=65536</code> as an un-commented config to the following files:</p>\n<ul>\n<li>/etc/systemd/system.conf</li>\n<li>/etc/systemd/user.conf</li>\n</ul>\n<p>For Ubuntu Linux, you may need to add the line <code>* - nofile 65536</code> to the file <code>/etc/security/limits.conf</code> instead of updating systemd config files.</p>\n<p>Note that these settings persist but a <strong>restart is required</strong>.</p>\n<p>Alternatively, if the server is running inside a VS Code devcontainer, the request may appear to be stalled. To fix this issue, see <a href=\"#dev-containers-vs-code-port-forwarding\">Dev Containers / VS Code Port Forwarding</a>.</p>\n<h3 id=\"network-requests-stop-loading\" tabindex=\"-1\">Network requests stop loading </h3>\n<p>When using a self-signed SSL certificate, Chrome ignores all caching directives and reloads the content. Vite relies on these caching directives.</p>\n<p>To resolve the problem use a trusted SSL cert.</p>\n<p>See: <a href=\"https://helpx.adobe.com/mt/experience-manager/kb/cache-problems-on-chrome-with-SSL-certificate-errors.html\" target=\"_blank\" rel=\"noreferrer\">Cache problems</a>, <a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=110649#c8\" target=\"_blank\" rel=\"noreferrer\">Chrome issue</a></p>\n<h4 id=\"macos\" tabindex=\"-1\">macOS </h4>\n<p>You can install a trusted cert via the CLI with this command:</p>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">security add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain-db your-cert.cer</pre>\n</div>\n<p>Or, by importing it into the Keychain Access app and updating the trust of your cert to \"Always Trust.\"</p>\n<h3 id=\"_431-request-header-fields-too-large\" tabindex=\"-1\">431 Request Header Fields Too Large </h3>\n<p>When the server / WebSocket server receives a large HTTP header, the request will be dropped and the following warning will be shown.</p>\n<blockquote><p>Server responded with status code 431. See <a href=\"troubleshooting#_431-request-header-fields-too-large\" rel=\"noreferrer\" target=\"_blank\">https://vite.dev/guide/troubleshooting.html#_431-request-header-fields-too-large</a>.</p></blockquote>\n<p>This is because Node.js limits request header size to mitigate <a href=\"https://www.cve.org/CVERecord?id=CVE-2018-12121\" target=\"_blank\" rel=\"noreferrer\">CVE-2018-12121</a>.</p>\n<p>To avoid this, try to reduce your request header size. For example, if the cookie is long, delete it. Or you can use <a href=\"https://nodejs.org/api/cli.html#--max-http-header-sizesize\" target=\"_blank\" rel=\"noreferrer\"><code>--max-http-header-size</code></a> to change max header size.</p>\n<h3 id=\"dev-containers-vs-code-port-forwarding\" tabindex=\"-1\">Dev Containers / VS Code Port Forwarding </h3>\n<p>If you are using a Dev Container or port forwarding feature in VS Code, you may need to set the <a href=\"../config/server-options#server-host\"><code>server.host</code></a> option to <code>127.0.0.1</code> in the config to make it work.</p>\n<p>This is because <a href=\"https://github.com/microsoft/vscode-remote-release/issues/7029\" target=\"_blank\" rel=\"noreferrer\">the port forwarding feature in VS Code does not support IPv6</a>.</p>\n<p>See <a href=\"https://github.com/vitejs/vite/issues/16522\" target=\"_blank\" rel=\"noreferrer\">#16522</a> for more details.</p>\n<h2 id=\"hmr\" tabindex=\"-1\">HMR </h2>\n<h3 id=\"vite-detects-a-file-change-but-the-hmr-is-not-working\" tabindex=\"-1\">Vite detects a file change but the HMR is not working </h3>\n<p>You may be importing a file with a different case. For example, <code>src/foo.js</code> exists and <code>src/bar.js</code> contains:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import './Foo.js' // should be './foo.js'</pre>\n</div>\n<p>Related issue: <a href=\"https://github.com/vitejs/vite/issues/964\" target=\"_blank\" rel=\"noreferrer\">#964</a></p>\n<h3 id=\"vite-does-not-detect-a-file-change\" tabindex=\"-1\">Vite does not detect a file change </h3>\n<p>If you are running Vite with WSL2, Vite cannot watch file changes in some conditions. See <a href=\"../config/server-options#server-watch\"><code>server.watch</code> option</a>.</p>\n<h3 id=\"a-full-reload-happens-instead-of-hmr\" tabindex=\"-1\">A full reload happens instead of HMR </h3>\n<p>If HMR is not handled by Vite or a plugin, a full reload will happen as it's the only way to refresh the state.</p>\n<p>If HMR is handled but it is within a circular dependency, a full reload will also happen to recover the execution order. To solve this, try breaking the loop. You can run <code>vite --debug hmr</code> to log the circular dependency path if a file change triggered it.</p>\n<h2 id=\"build\" tabindex=\"-1\">Build </h2>\n<h3 id=\"built-file-does-not-work-because-of-cors-error\" tabindex=\"-1\">Built file does not work because of CORS error </h3>\n<p>If the HTML file output was opened with <code>file</code> protocol, the scripts won't run with the following error.</p>\n<blockquote><p>Access to script at 'file:///foo/bar.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.</p></blockquote>\n<blockquote><p>Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at file:///foo/bar.js. (Reason: CORS request not http).</p></blockquote>\n<p>See <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSRequestNotHttp\" target=\"_blank\" rel=\"noreferrer\">Reason: CORS request not HTTP - HTTP | MDN</a> for more information about why this happens.</p>\n<p>You will need to access the file with <code>http</code> protocol. The easiest way to achieve this is to run <code>npx vite preview</code>.</p>\n<h3 id=\"no-such-file-or-directory-error-due-to-case-sensitivity\" tabindex=\"-1\">No such file or directory error due to case sensitivity </h3>\n<p>If you encounter errors like <code>ENOENT: no such file or directory</code> or <code>Module not found</code>, this often occurs when your project was developed on a case-insensitive filesystem (Windows / macOS) but built on a case-sensitive one (Linux). Please make sure that the imports have the correct casing.</p>\n<h2 id=\"optimized-dependencies\" tabindex=\"-1\">Optimized Dependencies </h2>\n<h3 id=\"outdated-pre-bundled-deps-when-linking-to-a-local-package\" tabindex=\"-1\">Outdated pre-bundled deps when linking to a local package </h3>\n<p>The hash key used to invalidate optimized dependencies depends on the package lock contents, the patches applied to dependencies, and the options in the Vite config file that affects the bundling of node modules. This means that Vite will detect when a dependency is overridden using a feature as <a href=\"https://docs.npmjs.com/cli/v9/configuring-npm/package-json#overrides\" target=\"_blank\" rel=\"noreferrer\">npm overrides</a>, and re-bundle your dependencies on the next server start. Vite won't invalidate the dependencies when you use a feature like <a href=\"https://docs.npmjs.com/cli/v9/commands/npm-link\" target=\"_blank\" rel=\"noreferrer\">npm link</a>. In case you link or unlink a dependency, you'll need to force re-optimization on the next server start by using <code>vite --force</code>. We recommend using overrides instead, which are supported now by every package manager (see also <a href=\"https://pnpm.io/9.x/package_json#pnpmoverrides\" target=\"_blank\" rel=\"noreferrer\">pnpm overrides</a> and <a href=\"https://yarnpkg.com/configuration/manifest/#resolutions\" target=\"_blank\" rel=\"noreferrer\">yarn resolutions</a>).</p>\n<h2 id=\"performance-bottlenecks\" tabindex=\"-1\">Performance Bottlenecks </h2>\n<p>If you suffer any application performance bottlenecks resulting in slow load times, you can start the built-in Node.js inspector with your Vite dev server or when building your application to create the CPU profile:</p>\n<div class=\"vp-code-group\">\n<div class=\"tabs\">\n<input type=\"radio\" name=\"group-246\" id=\"tab-247\" checked><label data-title=\"dev server\" for=\"tab-247\">dev server</label><input type=\"radio\" name=\"group-246\" id=\"tab-248\"><label data-title=\"build\" for=\"tab-248\">build</label>\n</div>\n<div class=\"blocks\">\n<div class=\"language-bash active\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">vite --profile --open</pre>\n</div>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">vite build --profile</pre>\n</div>\n</div>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Vite Dev Server</strong><p>Once your application is opened in the browser, just await finish loading it and then go back to the terminal and press <code>p</code> key (will stop the Node.js inspector) then press <code>q</code> key to stop the dev server.</p>\n</div>\n<p>Node.js inspector will generate <code>vite-profile-0.cpuprofile</code> in the root folder, go to <a href=\"https://www.speedscope.app/\" target=\"_blank\" rel=\"noreferrer\">https://www.speedscope.app/</a>, and upload the CPU profile using the <code>BROWSE</code> button to inspect the result.</p>\n<p>You can install <a href=\"https://github.com/antfu/vite-plugin-inspect\" target=\"_blank\" rel=\"noreferrer\">vite-plugin-inspect</a>, which lets you inspect the intermediate state of Vite plugins and can also help you to identify which plugins or middlewares are the bottleneck in your applications. The plugin can be used in both dev and build modes. Check the readme file for more details.</p>\n<h2 id=\"others\" tabindex=\"-1\">Others </h2>\n<h3 id=\"module-externalized-for-browser-compatibility\" tabindex=\"-1\">Module externalized for browser compatibility </h3>\n<p>When you use a Node.js module in the browser, Vite will output the following warning.</p>\n<blockquote><p>Module \"fs\" has been externalized for browser compatibility. Cannot access \"fs.readFile\" in client code.</p></blockquote>\n<p>This is because Vite does not automatically polyfill Node.js modules.</p>\n<p>We recommend avoiding Node.js modules for browser code to reduce the bundle size, although you can add polyfills manually. If the module is imported from a third-party library (that's meant to be used in the browser), it's advised to report the issue to the respective library.</p>\n<h3 id=\"syntax-error-type-error-happens\" tabindex=\"-1\">Syntax Error / Type Error happens </h3>\n<p>Vite cannot handle and does not support code that only runs on non-strict mode (sloppy mode). This is because Vite uses ESM and it is always <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" rel=\"noreferrer\">strict mode</a> inside ESM.</p>\n<p>For example, you might see these errors.</p>\n<blockquote><p>[ERROR] With statements cannot be used with the \"esm\" output format due to strict mode</p></blockquote>\n<blockquote><p>TypeError: Cannot create property 'foo' on boolean 'false'</p></blockquote>\n<p>If these codes are used inside dependencies, you could use <a href=\"https://github.com/ds300/patch-package\" target=\"_blank\" rel=\"noreferrer\"><code>patch-package</code></a> (or <a href=\"https://yarnpkg.com/cli/patch\" target=\"_blank\" rel=\"noreferrer\"><code>yarn patch</code></a> or <a href=\"https://pnpm.io/cli/patch\" target=\"_blank\" rel=\"noreferrer\"><code>pnpm patch</code></a>) for an escape hatch.</p>\n<h3 id=\"browser-extensions\" tabindex=\"-1\">Browser extensions </h3>\n<p>Some browser extensions (like ad-blockers) may prevent the Vite client from sending requests to the Vite dev server. You may see a white screen without logged errors in this case. Try disabling extensions if you have this issue.</p>\n<h3 id=\"cross-drive-links-on-windows\" tabindex=\"-1\">Cross drive links on Windows </h3>\n<p>If there's a cross drive links in your project on Windows, Vite may not work.</p>\n<p>An example of cross drive links are:</p>\n<ul>\n<li>a virtual drive linked to a folder by <code>subst</code> command</li>\n<li>a symlink/junction to a different drive by <code>mklink</code> command (e.g. Yarn global cache)</li>\n</ul>\n<p>Related issue: <a href=\"https://github.com/vitejs/vite/issues/10802\" target=\"_blank\" rel=\"noreferrer\">#10802</a></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/troubleshooting\" class=\"_attribution-link\">https://vite.dev/guide/troubleshooting</a>\n  </p>\n</div>\n","guide/static-deploy":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/static-deploy.md for this page in Markdown format</div>\n<h1 id=\"deploying-a-static-site\" tabindex=\"-1\">Deploying a Static Site </h1>\n<p>The following guides are based on some shared assumptions:</p>\n<ul>\n<li>You are using the default build output location (<code>dist</code>). This location <a href=\"../config/build-options#build-outdir\">can be changed using <code>build.outDir</code></a>, and you can extrapolate instructions from these guides in that case.</li>\n<li>You are using npm. You can use equivalent commands to run the scripts if you are using Yarn or other package managers.</li>\n<li>Vite is installed as a local dev dependency in your project, and you have setup the following npm scripts:</li>\n</ul>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"package.json\">package.json</span></div>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"scripts\": {\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  }\n}</pre>\n</div>\n</div>\n<p>It is important to note that <code>vite preview</code> is intended for previewing the build locally and not meant as a production server.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p>These guides provide instructions for performing a static deployment of your Vite site. Vite also supports Server-Side Rendering. SSR refers to front-end frameworks that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. Check out the <a href=\"ssr\">SSR Guide</a> to learn about this feature. On the other hand, if you are looking for integration with traditional server-side frameworks, check out the <a href=\"backend-integration\">Backend Integration guide</a> instead.</p>\n</div>\n<h2 id=\"building-the-app\" tabindex=\"-1\">Building the App </h2>\n<p>You may run <code>npm run build</code> command to build the app.</p>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ npm run build</pre>\n</div>\n<p>By default, the build output will be placed at <code>dist</code>. You may deploy this <code>dist</code> folder to any of your preferred platforms.</p>\n<h3 id=\"testing-the-app-locally\" tabindex=\"-1\">Testing the App Locally </h3>\n<p>Once you've built the app, you may test it locally by running <code>npm run preview</code> command.</p>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ npm run preview</pre>\n</div>\n<p>The <code>vite preview</code> command will boot up a local static web server that serves the files from <code>dist</code> at <code>http://localhost:4173</code>. It's an easy way to check if the production build looks OK in your local environment.</p>\n<p>You may configure the port of the server by passing the <code>--port</code> flag as an argument.</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"package.json\">package.json</span></div>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"scripts\": {\n    \"preview\": \"vite preview --port 8080\"\n  }\n}</pre>\n</div>\n</div>\n<p>Now the <code>preview</code> command will launch the server at <code>http://localhost:8080</code>.</p>\n<h2 id=\"github-pages\" tabindex=\"-1\">GitHub Pages </h2>\n<ol>\n<li>\n<p>Set the correct <code>base</code> in <code>vite.config.js</code>.</p>\n<p>If you are deploying to <code>https://&lt;USERNAME&gt;.github.io/</code>, or to a custom domain through GitHub Pages (eg. <code>www.example.com</code>), set <code>base</code> to <code>'/'</code>. Alternatively, you can remove <code>base</code> from the configuration, as it defaults to <code>'/'</code>.</p>\n<p>If you are deploying to <code>https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;/</code> (eg. your repository is at <code>https://github.com/&lt;USERNAME&gt;/&lt;REPO&gt;</code>), then set <code>base</code> to <code>'/&lt;REPO&gt;/'</code>.</p>\n</li>\n<li>\n<p>Go to your GitHub Pages configuration in the repository settings page and choose the source of deployment as \"GitHub Actions\", this will lead you to create a workflow that builds and deploys your project, a sample workflow that installs dependencies and builds using npm is provided:</p>\n<div class=\"language-yaml\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\"># Simple workflow for deploying static content to GitHub Pages\nname: Deploy static content to Pages\n\non:\n  # Runs on pushes targeting the default branch\n  push:\n    branches: ['main']\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\n# Sets the GITHUB_TOKEN permissions to allow deployment to GitHub Pages\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n\n# Allow one concurrent deployment\nconcurrency:\n  group: 'pages'\n  cancel-in-progress: true\n\njobs:\n  # Single deploy job since we're just deploying\n  deploy:\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      - name: Set up Node\n        uses: actions/setup-node@v4\n        with:\n          node-version: lts/*\n          cache: 'npm'\n      - name: Install dependencies\n        run: npm ci\n      - name: Build\n        run: npm run build\n      - name: Setup Pages\n        uses: actions/configure-pages@v5\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v3\n        with:\n          # Upload dist folder\n          path: './dist'\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4</pre>\n</div>\n</li>\n</ol>\n<h2 id=\"gitlab-pages-and-gitlab-ci\" tabindex=\"-1\">GitLab Pages and GitLab CI </h2>\n<ol>\n<li>\n<p>Set the correct <code>base</code> in <code>vite.config.js</code>.</p>\n<p>If you are deploying to <code>https://&lt;USERNAME or GROUP&gt;.gitlab.io/</code>, you can omit <code>base</code> as it defaults to <code>'/'</code>.</p>\n<p>If you are deploying to <code>https://&lt;USERNAME or GROUP&gt;.gitlab.io/&lt;REPO&gt;/</code>, for example your repository is at <code>https://gitlab.com/&lt;USERNAME&gt;/&lt;REPO&gt;</code>, then set <code>base</code> to <code>'/&lt;REPO&gt;/'</code>.</p>\n</li>\n<li>\n<p>Create a file called <code>.gitlab-ci.yml</code> in the root of your project with the content below. This will build and deploy your site whenever you make changes to your content:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\".gitlab-ci.yml\">.gitlab-ci.yml</span></div>\n<div class=\"language-yaml\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">image: node:lts\npages:\n  stage: deploy\n  cache:\n    key:\n      files:\n        - package-lock.json\n      prefix: npm\n    paths:\n      - node_modules/\n  script:\n    - npm install\n    - npm run build\n    - cp -a dist/. public/\n  artifacts:\n    paths:\n      - public\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH</pre>\n</div>\n</div>\n</li>\n</ol>\n<h2 id=\"netlify\" tabindex=\"-1\">Netlify </h2>\n<h3 id=\"netlify-cli\" tabindex=\"-1\">Netlify CLI </h3>\n<ol>\n<li>Install the <a href=\"https://cli.netlify.com/\" target=\"_blank\" rel=\"noreferrer\">Netlify CLI</a>.</li>\n<li>Create a new site using <code>ntl init</code>.</li>\n<li>Deploy using <code>ntl deploy</code>.</li>\n</ol>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\"># Install the Netlify CLI\n$ npm install -g netlify-cli\n\n# Create a new site in Netlify\n$ ntl init\n\n# Deploy to a unique preview URL\n$ ntl deploy</pre>\n</div>\n<p>The Netlify CLI will share with you a preview URL to inspect. When you are ready to go into production, use the <code>prod</code> flag:</p>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\"># Deploy the site into production\n$ ntl deploy --prod</pre>\n</div>\n<h3 id=\"netlify-with-git\" tabindex=\"-1\">Netlify with Git </h3>\n<ol>\n<li>Push your code to a git repository (GitHub, GitLab, BitBucket, Azure DevOps).</li>\n<li>\n<a href=\"https://app.netlify.com/start\" target=\"_blank\" rel=\"noreferrer\">Import the project</a> to Netlify.</li>\n<li>Choose the branch, output directory, and set up environment variables if applicable.</li>\n<li>Click on <strong>Deploy</strong>.</li>\n<li>Your Vite app is deployed!</li>\n</ol>\n<p>After your project has been imported and deployed, all subsequent pushes to branches other than the production branch along with pull requests will generate <a href=\"https://docs.netlify.com/site-deploys/deploy-previews/\" target=\"_blank\" rel=\"noreferrer\">Preview Deployments</a>, and all changes made to the Production Branch (commonly “main”) will result in a <a href=\"https://docs.netlify.com/site-deploys/overview/#definitions\" target=\"_blank\" rel=\"noreferrer\">Production Deployment</a>.</p>\n<h2 id=\"vercel\" tabindex=\"-1\">Vercel </h2>\n<h3 id=\"vercel-cli\" tabindex=\"-1\">Vercel CLI </h3>\n<ol>\n<li>Install the <a href=\"https://vercel.com/cli\" target=\"_blank\" rel=\"noreferrer\">Vercel CLI</a> and run <code>vercel</code> to deploy.</li>\n<li>Vercel will detect that you are using Vite and will enable the correct settings for your deployment.</li>\n<li>Your application is deployed! (e.g. <a href=\"https://vite-vue-template.vercel.app/\" target=\"_blank\" rel=\"noreferrer\">vite-vue-template.vercel.app</a>)</li>\n</ol>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ npm i -g vercel\n$ vercel init vite\nVercel CLI\n&gt; Success! Initialized \"vite\" example in ~/your-folder.\n- To deploy, `cd vite` and run `vercel`.</pre>\n</div>\n<h3 id=\"vercel-for-git\" tabindex=\"-1\">Vercel for Git </h3>\n<ol>\n<li>Push your code to your git repository (GitHub, GitLab, Bitbucket).</li>\n<li>\n<a href=\"https://vercel.com/new\" target=\"_blank\" rel=\"noreferrer\">Import your Vite project</a> into Vercel.</li>\n<li>Vercel will detect that you are using Vite and will enable the correct settings for your deployment.</li>\n<li>Your application is deployed! (e.g. <a href=\"https://vite-vue-template.vercel.app/\" target=\"_blank\" rel=\"noreferrer\">vite-vue-template.vercel.app</a>)</li>\n</ol>\n<p>After your project has been imported and deployed, all subsequent pushes to branches will generate <a href=\"https://vercel.com/docs/concepts/deployments/environments#preview\" target=\"_blank\" rel=\"noreferrer\">Preview Deployments</a>, and all changes made to the Production Branch (commonly “main”) will result in a <a href=\"https://vercel.com/docs/concepts/deployments/environments#production\" target=\"_blank\" rel=\"noreferrer\">Production Deployment</a>.</p>\n<p>Learn more about Vercel’s <a href=\"https://vercel.com/docs/concepts/git\" target=\"_blank\" rel=\"noreferrer\">Git Integration</a>.</p>\n<h2 id=\"cloudflare-pages\" tabindex=\"-1\">Cloudflare Pages </h2>\n<h3 id=\"cloudflare-pages-via-wrangler\" tabindex=\"-1\">Cloudflare Pages via Wrangler </h3>\n<ol>\n<li>Install <a href=\"https://developers.cloudflare.com/workers/wrangler/get-started/\" target=\"_blank\" rel=\"noreferrer\">Wrangler CLI</a>.</li>\n<li>Authenticate Wrangler with your Cloudflare account using <code>wrangler login</code>.</li>\n<li>Run your build command.</li>\n<li>Deploy using <code>npx wrangler pages deploy dist</code>.</li>\n</ol>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\"># Install Wrangler CLI\n$ npm install -g wrangler\n\n# Login to Cloudflare account from CLI\n$ wrangler login\n\n# Run your build command\n$ npm run build\n\n# Create new deployment\n$ npx wrangler pages deploy dist</pre>\n</div>\n<p>After your assets are uploaded, Wrangler will give you a preview URL to inspect your site. When you log into the Cloudflare Pages dashboard, you will see your new project.</p>\n<h3 id=\"cloudflare-pages-with-git\" tabindex=\"-1\">Cloudflare Pages with Git </h3>\n<ol>\n<li>Push your code to your git repository (GitHub, GitLab).</li>\n<li>Log in to the Cloudflare dashboard and select your account in <strong>Account Home</strong> &gt; <strong>Pages</strong>.</li>\n<li>Select <strong>Create a new Project</strong> and the <strong>Connect Git</strong> option.</li>\n<li>Select the git project you want to deploy and click <strong>Begin setup</strong>\n</li>\n<li>Select the corresponding framework preset in the build setting depending on the Vite framework you have selected.</li>\n<li>Then save and deploy!</li>\n<li>Your application is deployed! (e.g <code>https://&lt;PROJECTNAME&gt;.pages.dev/</code>)</li>\n</ol>\n<p>After your project has been imported and deployed, all subsequent pushes to branches will generate <a href=\"https://developers.cloudflare.com/pages/platform/preview-deployments/\" target=\"_blank\" rel=\"noreferrer\">Preview Deployments</a> unless specified not to in your <a href=\"https://developers.cloudflare.com/pages/platform/branch-build-controls/\" target=\"_blank\" rel=\"noreferrer\">branch build controls</a>. All changes to the Production Branch (commonly “main”) will result in a Production Deployment.</p>\n<p>You can also add custom domains and handle custom build settings on Pages. Learn more about <a href=\"https://developers.cloudflare.com/pages/get-started/#manage-your-site\" target=\"_blank\" rel=\"noreferrer\">Cloudflare Pages Git Integration</a>.</p>\n<h2 id=\"google-firebase\" tabindex=\"-1\">Google Firebase </h2>\n<ol>\n<li><p>Make sure you have <a href=\"https://www.npmjs.com/package/firebase-tools\" target=\"_blank\" rel=\"noreferrer\">firebase-tools</a> installed.</p></li>\n<li>\n<p>Create <code>firebase.json</code> and <code>.firebaserc</code> at the root of your project with the following content:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"firebase.json\">firebase.json</span></div>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"hosting\": {\n    \"public\": \"dist\",\n    \"ignore\": [],\n    \"rewrites\": [\n      {\n        \"source\": \"**\",\n        \"destination\": \"/index.html\"\n      }\n    ]\n  }\n}</pre>\n</div>\n</div>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\".firebaserc\">.firebaserc</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"projects\": {\n    \"default\": \"&lt;YOUR_FIREBASE_ID&gt;\"\n  }\n}</pre>\n</div>\n</div>\n</li>\n<li><p>After running <code>npm run build</code>, deploy using the command <code>firebase deploy</code>.</p></li>\n</ol>\n<h2 id=\"surge\" tabindex=\"-1\">Surge </h2>\n<ol>\n<li><p>First install <a href=\"https://www.npmjs.com/package/surge\" target=\"_blank\" rel=\"noreferrer\">surge</a>, if you haven’t already.</p></li>\n<li><p>Run <code>npm run build</code>.</p></li>\n<li><p>Deploy to surge by typing <code>surge dist</code>.</p></li>\n</ol>\n<p>You can also deploy to a <a href=\"http://surge.sh/help/adding-a-custom-domain\" target=\"_blank\" rel=\"noreferrer\">custom domain</a> by adding <code>surge dist yourdomain.com</code>.</p>\n<h2 id=\"azure-static-web-apps\" tabindex=\"-1\">Azure Static Web Apps </h2>\n<p>You can quickly deploy your Vite app with Microsoft Azure <a href=\"https://aka.ms/staticwebapps\" target=\"_blank\" rel=\"noreferrer\">Static Web Apps</a> service. You need:</p>\n<ul>\n<li>An Azure account and a subscription key. You can create a <a href=\"https://azure.microsoft.com/free\" target=\"_blank\" rel=\"noreferrer\">free Azure account here</a>.</li>\n<li>Your app code pushed to <a href=\"https://github.com\" target=\"_blank\" rel=\"noreferrer\">GitHub</a>.</li>\n<li>The <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurestaticwebapps\" target=\"_blank\" rel=\"noreferrer\">SWA Extension</a> in <a href=\"https://code.visualstudio.com\" target=\"_blank\" rel=\"noreferrer\">Visual Studio Code</a>.</li>\n</ul>\n<p>Install the extension in VS Code and navigate to your app root. Open the Static Web Apps extension, sign in to Azure, and click the '+' sign to create a new Static Web App. You will be prompted to designate which subscription key to use.</p>\n<p>Follow the wizard started by the extension to give your app a name, choose a framework preset, and designate the app root (usually <code>/</code>) and built file location <code>/dist</code>. The wizard will run and will create a GitHub action in your repo in a <code>.github</code> folder.</p>\n<p>The action will work to deploy your app (watch its progress in your repo's Actions tab) and, when successfully completed, you can view your app in the address provided in the extension's progress window by clicking the 'Browse Website' button that appears when the GitHub action has run.</p>\n<h2 id=\"render\" tabindex=\"-1\">Render </h2>\n<p>You can deploy your Vite app as a Static Site on <a href=\"https://render.com/\" target=\"_blank\" rel=\"noreferrer\">Render</a>.</p>\n<ol>\n<li><p>Create a <a href=\"https://dashboard.render.com/register\" target=\"_blank\" rel=\"noreferrer\">Render account</a>.</p></li>\n<li><p>In the <a href=\"https://dashboard.render.com/\" target=\"_blank\" rel=\"noreferrer\">Dashboard</a>, click the <strong>New</strong> button and select <strong>Static Site</strong>.</p></li>\n<li><p>Connect your GitHub/GitLab account or use a public repository.</p></li>\n<li>\n<p>Specify a project name and branch.</p>\n<ul>\n<li>\n<strong>Build Command</strong>: <code>npm install &amp;&amp; npm run build</code>\n</li>\n<li>\n<strong>Publish Directory</strong>: <code>dist</code>\n</li>\n</ul>\n</li>\n<li>\n<p>Click <strong>Create Static Site</strong>.</p>\n<p>Your app should be deployed at <code>https://&lt;PROJECTNAME&gt;.onrender.com/</code>.</p>\n</li>\n</ol>\n<p>By default, any new commit pushed to the specified branch will automatically trigger a new deployment. <a href=\"https://render.com/docs/deploys#toggling-auto-deploy-for-a-service\" target=\"_blank\" rel=\"noreferrer\">Auto-Deploy</a> can be configured in the project settings.</p>\n<p>You can also add a <a href=\"https://render.com/docs/custom-domains\" target=\"_blank\" rel=\"noreferrer\">custom domain</a> to your project.</p>\n<h2 id=\"flightcontrol\" tabindex=\"-1\">Flightcontrol </h2>\n<p>Deploy your static site using <a href=\"https://www.flightcontrol.dev/?ref=docs-vite\" target=\"_blank\" rel=\"noreferrer\">Flightcontrol</a> by following these <a href=\"https://www.flightcontrol.dev/docs/reference/examples/vite?ref=docs-vite\" target=\"_blank\" rel=\"noreferrer\">instructions</a>.</p>\n<h2 id=\"kinsta-static-site-hosting\" tabindex=\"-1\">Kinsta Static Site Hosting </h2>\n<p>Deploy your static site using <a href=\"https://kinsta.com/static-site-hosting/\" target=\"_blank\" rel=\"noreferrer\">Kinsta</a> by following these <a href=\"https://kinsta.com/docs/react-vite-example/\" target=\"_blank\" rel=\"noreferrer\">instructions</a>.</p>\n<h2 id=\"xmit-static-site-hosting\" tabindex=\"-1\">xmit Static Site Hosting </h2>\n<p>Deploy your static site using <a href=\"https://xmit.co\" target=\"_blank\" rel=\"noreferrer\">xmit</a> by following this <a href=\"https://xmit.dev/posts/vite-quickstart/\" target=\"_blank\" rel=\"noreferrer\">guide</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/static-deploy\" class=\"_attribution-link\">https://vite.dev/guide/static-deploy</a>\n  </p>\n</div>\n","guide/backend-integration":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/backend-integration.md for this page in Markdown format</div>\n<h1 id=\"backend-integration\" tabindex=\"-1\">Backend Integration </h1>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Note</strong><p>If you want to serve the HTML using a traditional backend (e.g. Rails, Laravel) but use Vite for serving assets, check for existing integrations listed in <a href=\"https://github.com/vitejs/awesome-vite#integrations-with-backends\" target=\"_blank\" rel=\"noreferrer\">Awesome Vite</a>.</p>\n<p>If you need a custom integration, you can follow the steps in this guide to configure it manually</p>\n</div>\n<ol>\n<li>\n<p>In your Vite config, configure the entry and enable build manifest:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  server: {\n    cors: {\n      // the origin you will be accessing via browser\n      origin: 'http://my-backend.example.com',\n    },\n  },\n  build: {\n    // generate .vite/manifest.json in outDir\n    manifest: true,\n    rollupOptions: {\n      // overwrite default .html entry\n      input: '/path/to/main.js',\n    },\n  },\n})</pre>\n</div>\n</div>\n<p>If you haven't disabled the <a href=\"../config/build-options#build-polyfillmodulepreload\">module preload polyfill</a>, you also need to import the polyfill in your entry</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// add the beginning of your app entry\nimport 'vite/modulepreload-polyfill'</pre>\n</div>\n</li>\n<li>\n<p>For development, inject the following in your server's HTML template (substitute <code>http://localhost:5173</code> with the local URL Vite is running at):</p>\n<div class=\"language-html\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">&lt;!-- if development --&gt;\n&lt;script type=\"module\" src=\"http://localhost:5173/@vite/client\"&gt;&lt;/script&gt;\n&lt;script type=\"module\" src=\"http://localhost:5173/main.js\"&gt;&lt;/script&gt;</pre>\n</div>\n<p>In order to properly serve assets, you have two options:</p>\n<ul>\n<li>Make sure the server is configured to proxy static assets requests to the Vite server</li>\n<li>Set <a href=\"../config/server-options#server-origin\"><code>server.origin</code></a> so that generated asset URLs will be resolved using the back-end server URL instead of a relative path</li>\n</ul>\n<p>This is needed for assets such as images to load properly.</p>\n<p>Note if you are using React with <code>@vitejs/plugin-react</code>, you'll also need to add this before the above scripts, since the plugin is not able to modify the HTML you are serving (substitute <code>http://localhost:5173</code> with the local URL Vite is running at):</p>\n<div class=\"language-html\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">&lt;script type=\"module\"&gt;\n  import RefreshRuntime from 'http://localhost:5173/@react-refresh'\n  RefreshRuntime.injectIntoGlobalHook(window)\n  window.$RefreshReg$ = () =&gt; {}\n  window.$RefreshSig$ = () =&gt; (type) =&gt; type\n  window.__vite_plugin_react_preamble_installed__ = true\n&lt;/script&gt;</pre>\n</div>\n</li>\n<li>\n<p>For production: after running <code>vite build</code>, a <code>.vite/manifest.json</code> file will be generated alongside other asset files. An example manifest file looks like this:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\".vite/manifest.json\">.vite/manifest.json</span></div>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"_shared-B7PI925R.js\": {\n    \"file\": \"assets/shared-B7PI925R.js\",\n    \"name\": \"shared\",\n    \"css\": [\"assets/shared-ChJ_j-JJ.css\"]\n  },\n  \"_shared-ChJ_j-JJ.css\": {\n    \"file\": \"assets/shared-ChJ_j-JJ.css\",\n    \"src\": \"_shared-ChJ_j-JJ.css\"\n  },\n  \"logo.svg\": {\n    \"file\": \"assets/logo-BuPIv-2h.svg\",\n    \"src\": \"logo.svg\"\n  },\n  \"baz.js\": {\n    \"file\": \"assets/baz-B2H3sXNv.js\",\n    \"name\": \"baz\",\n    \"src\": \"baz.js\",\n    \"isDynamicEntry\": true\n  },\n  \"views/bar.js\": {\n    \"file\": \"assets/bar-gkvgaI9m.js\",\n    \"name\": \"bar\",\n    \"src\": \"views/bar.js\",\n    \"isEntry\": true,\n    \"imports\": [\"_shared-B7PI925R.js\"],\n    \"dynamicImports\": [\"baz.js\"]\n  },\n  \"views/foo.js\": {\n    \"file\": \"assets/foo-BRBmoGS9.js\",\n    \"name\": \"foo\",\n    \"src\": \"views/foo.js\",\n    \"isEntry\": true,\n    \"imports\": [\"_shared-B7PI925R.js\"],\n    \"css\": [\"assets/foo-5UjPuW-k.css\"]\n  }\n}</pre>\n</div>\n</div>\n<p>The manifest has a <code>Record&lt;name, chunk&gt;</code> structure where each chunk follows the <code>ManifestChunk</code> interface:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface ManifestChunk {\n  src?: string\n  file: string\n  css?: string[]\n  assets?: string[]\n  isEntry?: boolean\n  name?: string\n  names?: string[]\n  isDynamicEntry?: boolean\n  imports?: string[]\n  dynamicImports?: string[]\n}</pre>\n</div>\n<p>Each entry in the manifest represents one of the following:</p>\n<ul>\n<li>\n<strong>Entry chunks</strong>: Generated from files specified in <a href=\"https://rollupjs.org/configuration-options/#input\" target=\"_blank\" rel=\"noreferrer\"><code>build.rollupOptions.input</code></a>. These chunks have <code>isEntry: true</code> and their key is the relative src path from project root.</li>\n<li>\n<strong>Dynamic entry chunks</strong>: Generated from dynamic imports. These chunks have <code>isDynamicEntry: true</code> and their key is the relative src path from project root.</li>\n<li>\n<strong>Non-entry chunks</strong>: Their key is the base name of the generated file prefixed with <code>_</code>.</li>\n<li>\n<strong>Asset chunks</strong>: Generated from imported assets like images, fonts. Their key is the relative src path from project root.</li>\n<li>\n<strong>CSS files</strong>: When <a href=\"../config/build-options#build-csscodesplit\"><code>build.cssCodeSplit</code></a> is <code>false</code>, a single CSS file is generated with the key <code>style.css</code>. When <code>build.cssCodeSplit</code> is not <code>false</code>, the key is generated similar to JS chunks (i.e. entry chunks will not have <code>_</code> prefix and non-entry chunks will have <code>_</code> prefix).</li>\n</ul>\n<p>Chunks will contain information on their static and dynamic imports (both are keys that map to the corresponding chunk in the manifest), and also their corresponding CSS and asset files (if any).</p>\n</li>\n<li>\n<p>You can use this file to render links or preload directives with hashed filenames.</p>\n<p>Here is an example HTML template to render the proper links. The syntax here is for explanation only, substitute with your server templating language. The <code>importedChunks</code> function is for illustration and isn't provided by Vite.</p>\n<div class=\"language-html\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">&lt;!-- if production --&gt;\n\n&lt;!-- for cssFile of manifest[name].css --&gt;\n&lt;link rel=\"stylesheet\" href=\"/{{ cssFile }}\" /&gt;\n\n&lt;!-- for chunk of importedChunks(manifest, name) --&gt;\n&lt;!-- for cssFile of chunk.css --&gt;\n&lt;link rel=\"stylesheet\" href=\"/{{ cssFile }}\" /&gt;\n\n&lt;script type=\"module\" src=\"/{{ manifest[name].file }}\"&gt;&lt;/script&gt;\n\n&lt;!-- for chunk of importedChunks(manifest, name) --&gt;\n&lt;link rel=\"modulepreload\" href=\"/{{ chunk.file }}\" /&gt;</pre>\n</div>\n<p>Specifically, a backend generating HTML should include the following tags given a manifest file and an entry point. Note that following this order is recommended for optimal performance:</p>\n<ol>\n<li>A <code>&lt;link rel=\"stylesheet\"&gt;</code> tag for each file in the entry point chunk's <code>css</code> list (if it exists)</li>\n<li>Recursively follow all chunks in the entry point's <code>imports</code> list and include a <code>&lt;link rel=\"stylesheet\"&gt;</code> tag for each CSS file of each imported chunk's <code>css</code> list (if it exists).</li>\n<li>A tag for the <code>file</code> key of the entry point chunk. This can be <code>&lt;script type=\"module\"&gt;</code> for JavaScript, <code>&lt;link rel=\"stylesheet\"&gt;</code> for CSS.</li>\n<li>Optionally, <code>&lt;link rel=\"modulepreload\"&gt;</code> tag for the <code>file</code> of each imported JavaScript chunk, again recursively following the imports starting from the entry point chunk.</li>\n</ol>\n<p>Following the above example manifest, for the entry point <code>views/foo.js</code> the following tags should be included in production:</p>\n<div class=\"language-html\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">&lt;link rel=\"stylesheet\" href=\"assets/foo-5UjPuW-k.css\" /&gt;\n&lt;link rel=\"stylesheet\" href=\"assets/shared-ChJ_j-JJ.css\" /&gt;\n&lt;script type=\"module\" src=\"assets/foo-BRBmoGS9.js\"&gt;&lt;/script&gt;\n&lt;!-- optional --&gt;\n&lt;link rel=\"modulepreload\" href=\"assets/shared-B7PI925R.js\" /&gt;</pre>\n</div>\n<p>While the following should be included for the entry point <code>views/bar.js</code>:</p>\n<div class=\"language-html\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">&lt;link rel=\"stylesheet\" href=\"assets/shared-ChJ_j-JJ.css\" /&gt;\n&lt;script type=\"module\" src=\"assets/bar-gkvgaI9m.js\"&gt;&lt;/script&gt;\n&lt;!-- optional --&gt;\n&lt;link rel=\"modulepreload\" href=\"assets/shared-B7PI925R.js\" /&gt;</pre>\n</div>\n<div class=\"details custom-block\">\n<summary>Pseudo implementation of <code>importedChunks</code></summary><p>An example pseudo implementation of <code>importedChunks</code> in TypeScript (This will need to be adapted for your programming language and templating language):</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import type { Manifest, ManifestChunk } from 'vite'\n\nexport default function importedChunks(\n  manifest: Manifest,\n  name: string,\n): ManifestChunk[] {\n  const seen = new Set&lt;string&gt;()\n\n  function getImportedChunks(chunk: ManifestChunk): ManifestChunk[] {\n    const chunks: ManifestChunk[] = []\n    for (const file of chunk.imports ?? []) {\n      const importee = manifest[file]\n      if (seen.has(file)) {\n        continue\n      }\n      seen.add(file)\n\n      chunks.push(...getImportedChunks(importee))\n      chunks.push(importee)\n    }\n\n    return chunks\n  }\n\n  return getImportedChunks(manifest[name])\n}</pre>\n</div>\n</div>\n</li>\n</ol><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/backend-integration\" class=\"_attribution-link\">https://vite.dev/guide/backend-integration</a>\n  </p>\n</div>\n","guide/rolldown":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/rolldown.md for this page in Markdown format</div>\n<h1 id=\"rolldown-integration\" tabindex=\"-1\">Rolldown Integration </h1>\n<p>Vite is planning to integrate <a href=\"https://rolldown.rs\" target=\"_blank\" rel=\"noreferrer\">Rolldown</a>, a Rust-powered JavaScript bundler, to improve build performance and capabilities.</p>\n<div class=\"full-width-youtube-video\" data-v-4fe468b5><iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/RRjfm8cMveQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen data-v-4fe468b5 sandbox=\"allow-forms allow-scripts allow-same-origin\"></iframe></div>\n<h2 id=\"what-is-rolldown\" tabindex=\"-1\">What is Rolldown? </h2>\n<p>Rolldown is a modern, high-performance JavaScript bundler written in Rust. It's designed as a drop-in replacement for Rollup, aiming to provide significant performance improvements while maintaining compatibility with the existing ecosystem.</p>\n<p>Rolldown focuses on three key principles:</p>\n<ul>\n<li>\n<strong>Speed</strong>: Built with Rust for maximum performance</li>\n<li>\n<strong>Compatibility</strong>: Works with existing Rollup plugins</li>\n<li>\n<strong>Optimization</strong>: Comes with features that go beyond what esbuild and Rollup implement</li>\n</ul>\n<h2 id=\"why-vite-is-migrating-to-rolldown\" tabindex=\"-1\">Why Vite is Migrating to Rolldown </h2>\n<ol>\n<li><p><strong>Unification</strong>: Vite currently uses esbuild for dependency pre-bundling and Rollup for production builds. Rolldown aims to unify these into a single, high-performance bundler that can be used for both purposes, reducing complexity.</p></li>\n<li><p><strong>Performance</strong>: Rolldown's Rust-based implementation offers significant performance improvements over JavaScript-based bundlers. While specific benchmarks may vary by project size and complexity, early tests show promising speed increases compared to Rollup.</p></li>\n<li><p><strong>Additional Features</strong>: Rolldown introduces features that are not available in Rollup or esbuild, such as advanced chunk splitting control, built-in HMR, and Module Federation.</p></li>\n</ol>\n<p>For additional insights on the motivations behind Rolldown, see the <a href=\"https://rolldown.rs/guide/#why-rolldown\" target=\"_blank\" rel=\"noreferrer\">reasons why Rolldown is being built</a>.</p>\n<h2 id=\"benefits-of-trying-rolldown-vite\" tabindex=\"-1\">Benefits of Trying <code>rolldown-vite</code> </h2>\n<ul>\n<li>Experience significantly faster build times, especially for larger projects</li>\n<li>Provide valuable feedback to help shape the future of Vite's bundling experience</li>\n<li>Prepare your projects for the eventual official Rolldown integration</li>\n</ul>\n<h2 id=\"how-to-try-rolldown\" tabindex=\"-1\">How to Try Rolldown </h2>\n<p>The rolldown-powered version of Vite is currently available as a separate package called <code>rolldown-vite</code>. If you have <code>vite</code> as a direct dependency, you can alias the <code>vite</code> package to <code>rolldown-vite</code> in your project's <code>package.json</code>, which should result in a drop-in replacement.</p>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark has-diff\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"dependencies\": {\n    \"vite\": \"^7.0.0\"\n    \"vite\": \"npm:rolldown-vite@latest\"\n  }\n}</pre>\n</div>\n<p>If you use a Vitepress or a meta framework that has Vite as peer dependency, you have to override the <code>vite</code> dependency in your <code>package.json</code>, which works slightly different depending on your package manager:</p>\n<div class=\"vp-code-group\">\n<div class=\"tabs\">\n<input type=\"radio\" name=\"group-88\" id=\"tab-89\" checked><label data-title=\"npm\" for=\"tab-89\">npm</label><input type=\"radio\" name=\"group-88\" id=\"tab-90\"><label data-title=\"Yarn\" for=\"tab-90\">Yarn</label><input type=\"radio\" name=\"group-88\" id=\"tab-91\"><label data-title=\"pnpm\" for=\"tab-91\">pnpm</label><input type=\"radio\" name=\"group-88\" id=\"tab-92\"><label data-title=\"Bun\" for=\"tab-92\">Bun</label>\n</div>\n<div class=\"blocks\">\n<div class=\"language-json active\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"overrides\": {\n    \"vite\": \"npm:rolldown-vite@latest\"\n  }\n}</pre>\n</div>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"resolutions\": {\n    \"vite\": \"npm:rolldown-vite@latest\"\n  }\n}</pre>\n</div>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"pnpm\": {\n    \"overrides\": {\n      \"vite\": \"npm:rolldown-vite@latest\"\n    }\n  }\n}</pre>\n</div>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"overrides\": {\n    \"vite\": \"npm:rolldown-vite@latest\"\n  }\n}</pre>\n</div>\n</div>\n</div>\n<p>After adding these overrides, reinstall your dependencies and start your development server or build your project as usual. No further configuration changes are required.</p>\n<h2 id=\"known-limitations\" tabindex=\"-1\">Known Limitations </h2>\n<p>While Rolldown aims to be a drop-in replacement for Rollup, there are features that are still being implemented and minor intentional behavior differences. For a comprehensive list, please refer to <a href=\"https://github.com/vitejs/rolldown-vite/pull/84#issue-2903144667\" target=\"_blank\" rel=\"noreferrer\">this GitHub PR</a> which is regularly updated.</p>\n<h3 id=\"option-validation-warnings\" tabindex=\"-1\">Option Validation Warnings </h3>\n<p>Rolldown outputs an warning when unknown or invalid options are passed. Because some options available in Rollup are not supported by Rolldown, you may encounter warnings based on the options you or the meta framework you use set. Below, you can find an example of such an warning message:</p>\n<blockquote>\n<p>Warning validate output options.</p>\n<ul><li>For the \"generatedCode\". Invalid key: Expected never but received \"generatedCode\".</li></ul>\n</blockquote>\n<p>If you don't pass the option in yourself, this must be fixed by the utilized framework.</p>\n<h3 id=\"api-differences\" tabindex=\"-1\">API Differences </h3>\n<h4 id=\"manualchunks-to-advancedchunks\" tabindex=\"-1\">\n<code>manualChunks</code> to <code>advancedChunks</code> </h4>\n<p>While Rolldown has support for the <code>manualChunks</code> option that is also exposed by Rollup, it is marked deprecated. Instead of it, Rolldown offers a more fine-grained setting via the <a href=\"https://rolldown.rs/guide/in-depth/advanced-chunks#advanced-chunks\" target=\"_blank\" rel=\"noreferrer\"><code>advancedChunks</code> option</a>, which is more similar to webpack's <code>splitChunk</code>:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// Old configuration (Rollup)\nexport default {\n  build: {\n    rollupOptions: {\n      output: {\n        manualChunks(id) {\n          if (/\\/react(?:-dom)?/.test(id)) {\n            return 'vendor'\n          }\n        }\n      }\n    }\n  }\n}\n\n// New configuration (Rolldown)\nexport default {\n  build: {\n    rollupOptions: {\n      output: {\n        advancedChunks: {\n          groups: [{ name: 'vendor', test: /\\/react(?:-dom)?/ }]\n        }\n      }\n    }\n  }\n}</pre>\n</div>\n<h2 id=\"performance\" tabindex=\"-1\">Performance </h2>\n<p><code>rolldown-vite</code> is focused on ensuring compatibility with the existing ecosystem, so defaults are geared towards a smooth transition. You can get further performance gains by switching over to faster Rust-based internal plugins and other customizations.</p>\n<h3 id=\"enabling-native-plugins\" tabindex=\"-1\">Enabling Native Plugins </h3>\n<p>Thanks to Rolldown and Oxc, various internal Vite plugins, such as the alias or resolve plugin, have been converted to Rust. Native plugins are now enabled by default, with the default value set to <code>'v1'</code>.</p>\n<p>If you encounter any issues, you can change the <code>experimental.enableNativePlugin</code> option in your Vite config to <code>'resolver'</code> or <code>false</code> as a workaround. Note that this option will be removed in the future.</p>\n<h3 id=\"utilizing-oxc-s-react-refresh-transform\" tabindex=\"-1\">Utilizing Oxc's React refresh transform </h3>\n<p><code>@vitejs/plugin-react</code> v5.0.0+ uses Oxc's React refresh transform. If you are not using any Babel plugins (including the React compiler), the full transform would now be done by Oxc and will improve the build performance without any changes other than updating <code>@vitejs/plugin-react</code>.</p>\n<p>If you are using <code>@vitejs/plugin-react-swc</code> without SWC plugins and custom SWC options, you can switch to the <code>@vitejs/plugin-react</code> plugin to utilize Oxc.</p>\n<div class=\"details custom-block\">\n<summary><code>@vitejs/plugin-react-oxc</code> plugin is deprecated</summary><p>Previously, we recommended using <code>@vitejs/plugin-react-oxc</code> to utilize Oxc's React refresh transform. However, we have merged the implementation into <code>@vitejs/plugin-react</code> so that it is easier to switch to <code>rolldown-vite</code>. <code>@vitejs/plugin-react-oxc</code> is now deprecated and will no longer be updated.</p>\n</div>\n<h3 id=\"withfilter-wrapper\" tabindex=\"-1\">\n<code>withFilter</code> Wrapper </h3>\n<p>Plugin authors have the option to use the <a href=\"#hook-filter-feature\">hook filter feature</a> to reduce the communication overhead between the Rust and JavaScript runtimes. But in case some of the used plugins are not using this feature (yet) but you still want to benefit from it, you can use the <code>withFilter</code> wrapper to wrap the plugin with a filter yourself.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// In your vite.config.ts\nimport { withFilter, defineConfig } from 'vite'\nimport svgr from 'vite-plugin-svgr'\n\nexport default defineConfig({\n  plugins: [\n    // Load the `svgr` plugin only for files which end in `.svg?react`\n    withFilter(\n      svgr({\n        /*...*/\n      }),\n      { load: { id: /\\.svg\\?react$/ } },\n    ),\n  ],\n})</pre>\n</div>\n<h2 id=\"reporting-issues\" tabindex=\"-1\">Reporting Issues </h2>\n<p>Since this is an experimental integration, you may encounter issues. If you do, please report them in the <a href=\"https://github.com/vitejs/rolldown-vite\" target=\"_blank\" rel=\"noreferrer\"><code>vitejs/rolldown-vite</code></a> repository, <strong>not the main Vite repository</strong>.</p>\n<p>When <a href=\"https://github.com/vitejs/rolldown-vite/issues/new\" target=\"_blank\" rel=\"noreferrer\">reporting issues</a>, please follow the appropriate issue template and provide what is requested there, commonly including:</p>\n<ul>\n<li>A minimal reproduction of the issue</li>\n<li>Your environment details (OS, Node version, package manager)</li>\n<li>Any relevant error messages or logs</li>\n</ul>\n<p>For real-time discussions and troubleshooting, make sure to join the <a href=\"https://chat.rolldown.rs/\" target=\"_blank\" rel=\"noreferrer\">Rolldown Discord</a>.</p>\n<h2 id=\"versioning-policy\" tabindex=\"-1\">Versioning Policy </h2>\n<p>The versioning policy for <code>rolldown-vite</code> aligns its major and minor versions with those of the normal Vite package. This synchronization ensures that features present in a specific normal Vite minor release are also included in the corresponding <code>rolldown-vite</code> minor release. However, it's important to note that patch versions are not synchronized between the two projects. If you're wondering whether a specific change from normal Vite has been included in <code>rolldown-vite</code>, you can always check <a href=\"https://github.com/vitejs/rolldown-vite/blob/rolldown-vite/packages/vite/CHANGELOG.md\" target=\"_blank\" rel=\"noreferrer\"><code>rolldown-vite</code>'s separate changelog</a> for confirmation.</p>\n<p>Furthermore, please be aware that <code>rolldown-vite</code> itself is considered experimental. Due to its experimental nature, breaking changes might be introduced even within its patch versions. Additionally, please note that <code>rolldown-vite</code> only receives updates for its most recent minor version. Even for important security or bug fixes, patches are not created for older major or minor versions.</p>\n<h2 id=\"future-plans\" tabindex=\"-1\">Future Plans </h2>\n<p>The <code>rolldown-vite</code> package is a temporary solution to gather feedback and stabilize the Rolldown integration. In the future, this functionality will be merged back into the main Vite repository.</p>\n<p>We encourage you to try out <code>rolldown-vite</code> and contribute to its development through feedback and issue reports.</p>\n<p>In the future, we will also introduce a \"Full Bundle Mode\" for Vite, which will serve bundled files in production <em>and development mode</em>.</p>\n<h3 id=\"why-introducing-a-full-bundle-mode\" tabindex=\"-1\">Why introducing a Full Bundle Mode? </h3>\n<p>Vite is known for its unbundled dev server approach, which is a main reason for Vite's speed and popularity when it was first introduced. This approach was initially an experiment to see just how far we could push the boundaries of development server performance without traditional bundling.</p>\n<p>However, as projects scale in size and complexity, two main challenges have emerged:</p>\n<ol>\n<li><p><strong>Development/Production inconsistency</strong>: The unbundled JavaScript served in development versus the bundled production build creates different runtime behaviors. This can lead to issues that only manifest in production, making debugging more difficult.</p></li>\n<li><p><strong>Performance degradation during development</strong>: The unbundled approach results in each module being fetched separately, which creates a large number of network requests. While this has <em>no impact in production</em>, it causes significant overhead during dev server startup and when refreshing the page in development. The impact is especially noticeable in large applications where hundreds or even thousands of separate requests must be processed. These bottlenecks become even more severe when developers use network proxy, resulting in slower refresh times and degraded developer experience.</p></li>\n</ol>\n<p>With the Rolldown integration, we have an opportunity to unify the development and production experiences while maintaining Vite's signature performance. A Full Bundle Mode would allow serving bundled files not only in production but also during development, combining the best of both worlds:</p>\n<ul>\n<li>Fast startup times even for large applications</li>\n<li>Consistent behavior between development and production</li>\n<li>Reduced network overhead on page refreshes</li>\n<li>Maintained efficient HMR on top of ESM output</li>\n</ul>\n<p>When the Full Bundle Mode is introduced, it will be an opt-in feature at first. Similar to the Rolldown integration, we are aiming to make it the default after gathering feedback and ensuring stability.</p>\n<h2 id=\"plugin-framework-authors-guide\" tabindex=\"-1\">Plugin / Framework Authors Guide </h2>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">TIP</strong><p>This section is mostly relevant for plugin and framework authors. If you are a user, you can skip this section.</p>\n</div>\n<h3 id=\"overview-of-major-changes\" tabindex=\"-1\">Overview of Major Changes </h3>\n<ul>\n<li>Rolldown is used for build (Rollup was used before)</li>\n<li>Rolldown is used for the optimizer (esbuild was used before)</li>\n<li>CommonJS support is handled by Rolldown (@rollup/plugin-commonjs was used before)</li>\n<li>Oxc is used for syntax lowering (esbuild was used before)</li>\n<li>Lightning CSS is used for CSS minification by default (esbuild was used before)</li>\n<li>Oxc minifier is used for JS minification by default (esbuild was used before)</li>\n<li>Rolldown is used for bundling the config (esbuild was used before)</li>\n</ul>\n<h3 id=\"detecting-rolldown-vite\" tabindex=\"-1\">Detecting <code>rolldown-vite</code> </h3>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">WARNING</strong><p>In most cases, you don't need to detect whether your plugin runs with <code>rolldown-vite</code> or <code>vite</code> and you should aim for consistent behavior across both, without conditional branching.</p>\n</div>\n<p>In case you need different behavior with <code>rolldown-vite</code>, you have two ways to detect if <code>rolldown-vite</code> is used:</p>\n<p>Checking the existence of <code>this.meta.rolldownVersion</code>:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const plugin = {\n  resolveId() {\n    if (this.meta.rolldownVersion) {\n      // logic for rolldown-vite\n    } else {\n      // logic for rollup-vite\n    }\n  },\n}</pre>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">TIP</strong><p>Since Vite 7.0.0, <code>this.meta</code> is available in all hooks. In previous versions, <code>this.meta</code> was not available in Vite-specific hooks, such as the <code>config</code> hook.</p>\n</div>\n<br><p>Checking the existence of the <code>rolldownVersion</code> export:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import * as vite from 'vite'\n\nif (vite.rolldownVersion) {\n  // logic for rolldown-vite\n} else {\n  // logic for rollup-vite\n}</pre>\n</div>\n<p>If you have <code>vite</code> as a dependency (not a peer dependency), the <code>rolldownVersion</code> export is useful as it can be used from anywhere in your code.</p>\n<h3 id=\"ignoring-option-validation-in-rolldown\" tabindex=\"-1\">Ignoring option validation in Rolldown </h3>\n<p>As <a href=\"#option-validation-errors\">mentioned above</a>, Rolldown outputs a warning when unknown or invalid options are passed.</p>\n<p>This can be fixed by conditionally passing the option by checking whether it's running with <code>rolldown-vite</code> as <a href=\"#detecting-rolldown-vite\">shown above</a>.</p>\n<h3 id=\"transformwithesbuild-requires-esbuild-to-be-installed-separately\" tabindex=\"-1\">\n<code>transformWithEsbuild</code> requires <code>esbuild</code> to be installed separately </h3>\n<p>Since Vite itself does not use <code>esbuild</code> any more, <code>esbuild</code> is now an optional peer dependency. If your plugin uses <code>transformWithEsbuild</code>, the plugin needs to add <code>esbuild</code> to its dependencies or the user needs to install it manually.</p>\n<p>The recommended migration is to use the newly exported <code>transformWithOxc</code> function, which utilizes Oxc instead of <code>esbuild</code>.</p>\n<h3 id=\"compatibility-layer-for-esbuild-options\" tabindex=\"-1\">Compatibility layer for <code>esbuild</code> options </h3>\n<p>Rolldown-Vite has a compatibility layer to convert options for <code>esbuild</code> to the respective Oxc or <code>rolldown</code> ones. As tested in <a href=\"https://github.com/vitejs/vite-ecosystem-ci/blob/rolldown-vite/README-temp.md\" target=\"_blank\" rel=\"noreferrer\">the ecosystem-ci</a>, this works in many cases, including simple <code>esbuild</code> plugins. That said, <strong>we'll be removing the <code>esbuild</code> options support in the future</strong> and encourage you to try the corresponding Oxc or <code>rolldown</code> options. You can get the options set by the compatibility layer from the <code>configResolved</code> hook.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const plugin = {\n  name: 'log-config',\n  configResolved(config) {\n    console.log('options', config.optimizeDeps, config.oxc)\n  },\n},</pre>\n</div>\n<h3 id=\"hook-filter-feature\" tabindex=\"-1\">Hook filter feature </h3>\n<p>Rolldown introduced a <a href=\"https://rolldown.rs/guide/plugin-development#plugin-hook-filters\" target=\"_blank\" rel=\"noreferrer\">hook filter feature</a> to reduce the communication overhead the between Rust and JavaScript runtimes. By using this feature you can make your plugin more performant. This is also supported by Rollup 4.38.0+ and Vite 6.3.0+. To make your plugin backward compatible with the older versions, make sure to also run the filter inside the hook handlers.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">TIP</strong><p><a href=\"https://www.npmjs.com/package/@rolldown/pluginutils\" target=\"_blank\" rel=\"noreferrer\"><code>@rolldown/pluginutils</code></a> exports some utilities for hook filters like <code>exactRegex</code> and <code>prefixRegex</code>.</p>\n</div>\n<h3 id=\"converting-content-to-javascript-in-load-or-transform-hooks\" tabindex=\"-1\">Converting content to JavaScript in <code>load</code> or <code>transform</code> hooks </h3>\n<p>If you are converting the content to JavaScript from other types in <code>load</code> or <code>transform</code> hooks, you may need to add <code>moduleType: 'js'</code> to the returned value.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark has-diff\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const plugin = {\n  name: 'txt-loader',\n  load(id) {\n    if (id.endsWith('.txt')) {\n      const content = fs.readFile(id, 'utf-8')\n      return {\n        code: `export default ${JSON.stringify(content)}`,\n        moduleType: 'js', \n      }\n    }\n  },\n}</pre>\n</div>\n<p>This is because <a href=\"https://rolldown.rs/guide/in-depth/module-types\" target=\"_blank\" rel=\"noreferrer\">Rolldown supports non-JavaScript modules</a> and infers the module type from extensions unless specified.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/rolldown\" class=\"_attribution-link\">https://vite.dev/guide/rolldown</a>\n  </p>\n</div>\n","guide/api-environment":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/api-environment.md for this page in Markdown format</div>\n<h1 id=\"environment-api\" tabindex=\"-1\">Environment API </h1>\n<div class=\"info custom-block\">\n<strong class=\"custom-block-title\">Release Candidate</strong><p>The Environment API is generally in the release candidate phase. We'll maintain stability in the APIs between major releases to allow the ecosystem to experiment and build upon them. However, note that <a href=\"../changes/index#considering\">some specific APIs</a> are still considered experimental.</p>\n<p>We plan to stabilize these new APIs (with potential breaking changes) in a future major release once downstream projects have had time to experiment with the new features and validate them.</p>\n<p>Resources:</p>\n<ul>\n<li>\n<a href=\"https://github.com/vitejs/vite/discussions/16358\" target=\"_blank\" rel=\"noreferrer\">Feedback discussion</a> where we are gathering feedback about the new APIs.</li>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/16471\" target=\"_blank\" rel=\"noreferrer\">Environment API PR</a> where the new API were implemented and reviewed.</li>\n</ul>\n<p>Please share your feedback with us.</p>\n</div>\n<h2 id=\"formalizing-environments\" tabindex=\"-1\">Formalizing Environments </h2>\n<p>Vite 6 formalizes the concept of Environments. Until Vite 5, there were two implicit Environments (<code>client</code>, and optionally <code>ssr</code>). The new Environment API allows users and framework authors to create as many environments as needed to map the way their apps work in production. This new capability required a big internal refactoring, but a lot of effort has been placed on backward compatibility. The initial goal of Vite 6 is to move the ecosystem to the new major as smoothly as possible, delaying the adoption of the APIs until enough users have migrated and frameworks and plugin authors have validated the new design.</p>\n<h2 id=\"closing-the-gap-between-build-and-dev\" tabindex=\"-1\">Closing the Gap Between Build and Dev </h2>\n<p>For a simple SPA/MPA, no new APIs around environments are exposed to the config. Internally, Vite will apply the options to a <code>client</code> environment, but it's not necessary to know of this concept when configuring Vite. The config and behavior from Vite 5 should work seamlessly here.</p>\n<p>When we move to a typical server-side rendered (SSR) app, we'll have two environments:</p>\n<ul>\n<li>\n<code>client</code>: runs the app in the browser.</li>\n<li>\n<code>ssr</code>: runs the app in node (or other server runtimes) which renders pages before sending them to the browser.</li>\n</ul>\n<p>In dev, Vite executes the server code in the same Node process as the Vite dev server, giving a close approximation to the production environment. However, it is also possible for servers to run in other JS runtimes, like <a href=\"https://github.com/cloudflare/workerd\" target=\"_blank\" rel=\"noreferrer\">Cloudflare's workerd</a> which have different constraints. Modern apps may also run in more than two environments, e.g. a browser, a node server, and an edge server. Vite 5 didn't allow to properly represent these environments.</p>\n<p>Vite 6 allows users to configure their app during build and dev to map all of its environments. During dev, a single Vite dev server can now be used to run code in multiple different environments concurrently. The app source code is still transformed by Vite dev server. On top of the shared HTTP server, middlewares, resolved config, and plugins pipeline, the Vite dev server now has a set of independent dev environments. Each of them is configured to match the production environment as closely as possible, and is connected to a dev runtime where the code is executed (for workerd, the server code can now run in miniflare locally). In the client, the browser imports and executes the code. In other environments, a module runner fetches and evaluates the transformed code.</p>\n<p><img src=\"https://vite.dev/assets/vite-environments.DZyy20w5.svg\" alt=\"Vite Environments\" width=\"1110\" height=\"1187\"></p>\n<h2 id=\"environments-configuration\" tabindex=\"-1\">Environments Configuration </h2>\n<p>For an SPA/MPA, the configuration will look similar to Vite 5. Internally these options are used to configure the <code>client</code> environment.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig({\n  build: {\n    sourcemap: false,\n  },\n  optimizeDeps: {\n    include: ['lib'],\n  },\n})</pre>\n</div>\n<p>This is important because we'd like to keep Vite approachable and avoid exposing new concepts until they are needed.</p>\n<p>If the app is composed of several environments, then these environments can be configured explicitly with the <code>environments</code> config option.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default {\n  build: {\n    sourcemap: false,\n  },\n  optimizeDeps: {\n    include: ['lib'],\n  },\n  environments: {\n    server: {},\n    edge: {\n      resolve: {\n        noExternal: true,\n      },\n    },\n  },\n}</pre>\n</div>\n<p>When not explicitly documented, environment inherits the configured top-level config options (for example, the new <code>server</code> and <code>edge</code> environments will inherit the <code>build.sourcemap: false</code> option). A small number of top-level options, like <code>optimizeDeps</code>, only apply to the <code>client</code> environment, as they don't work well when applied as a default to server environments. Those options have <a href=\"api-environment#environments-configuration\" class=\"ignore-header\"><span class=\"VPBadge info\">non-inherit</span></a> badge in <a href=\"../config/index\">the reference</a>. The <code>client</code> environment can also be configured explicitly through <code>environments.client</code>, but we recommend to do it with the top-level options so the client config remains unchanged when adding new environments.</p>\n<p>The <code>EnvironmentOptions</code> interface exposes all the per-environment options. There are environment options that apply to both <code>build</code> and <code>dev</code>, like <code>resolve</code>. And there are <code>DevEnvironmentOptions</code> and <code>BuildEnvironmentOptions</code> for dev and build specific options (like <code>dev.warmup</code> or <code>build.outDir</code>). Some options like <code>optimizeDeps</code> only applies to dev, but is kept as top level instead of nested in <code>dev</code> for backward compatibility.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface EnvironmentOptions {\n  define?: Record&lt;string, any&gt;\n  resolve?: EnvironmentResolveOptions\n  optimizeDeps: DepOptimizationOptions\n  consumer?: 'client' | 'server'\n  dev: DevOptions\n  build: BuildOptions\n}</pre>\n</div>\n<p>The <code>UserConfig</code> interface extends from the <code>EnvironmentOptions</code> interface, allowing to configure the client and defaults for other environments, configured through the <code>environments</code> option. The <code>client</code> and a server environment named <code>ssr</code> are always present during dev. This allows backward compatibility with <code>server.ssrLoadModule(url)</code> and <code>server.moduleGraph</code>. During build, the <code>client</code> environment is always present, and the <code>ssr</code> environment is only present if it is explicitly configured (using <code>environments.ssr</code> or for backward compatibility <code>build.ssr</code>). An app doesn't need to use the <code>ssr</code> name for its SSR environment, it could name it <code>server</code> for example.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface UserConfig extends EnvironmentOptions {\n  environments: Record&lt;string, EnvironmentOptions&gt;\n  // other options\n}</pre>\n</div>\n<p>Note that the <code>ssr</code> top-level property is going to be deprecated once the Environment API is stable. This option has the same role as <code>environments</code>, but for the default <code>ssr</code> environment and only allowed configuring of a small set of options.</p>\n<h2 id=\"custom-environment-instances\" tabindex=\"-1\">Custom Environment Instances </h2>\n<p>Low level configuration APIs are available so runtime providers can provide environments with proper defaults for their runtimes. These environments can also spawn other processes or threads to run the modules during dev in a closer runtime to the production environment.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { customEnvironment } from 'vite-environment-provider'\n\nexport default {\n  build: {\n    outDir: '/dist/client',\n  },\n  environments: {\n    ssr: customEnvironment({\n      build: {\n        outDir: '/dist/ssr',\n      },\n    }),\n  },\n}</pre>\n</div>\n<h2 id=\"backward-compatibility\" tabindex=\"-1\">Backward Compatibility </h2>\n<p>The current Vite server API is not yet deprecated and is backward compatible with Vite 5.</p>\n<p>The <code>server.moduleGraph</code> returns a mixed view of the client and ssr module graphs. Backward compatible mixed module nodes will be returned from all its methods. The same scheme is used for the module nodes passed to <code>handleHotUpdate</code>.</p>\n<p>We don't recommend switching to Environment API yet. We are aiming for a good portion of the user base to adopt Vite 6 before so plugins don't need to maintain two versions. Checkout the future breaking changes section for information on future deprecations and upgrade path:</p>\n<ul>\n<li><a href=\"../changes/this-environment-in-hooks\"><code>this.environment</code> in Hooks</a></li>\n<li><a href=\"../changes/hotupdate-hook\">HMR <code>hotUpdate</code> Plugin Hook</a></li>\n<li><a href=\"../changes/per-environment-apis\">Move to Per-environment APIs</a></li>\n<li><a href=\"../changes/ssr-using-modulerunner\">SSR Using <code>ModuleRunner</code> API</a></li>\n<li><a href=\"../changes/shared-plugins-during-build\">Shared Plugins During Build</a></li>\n</ul>\n<h2 id=\"target-users\" tabindex=\"-1\">Target Users </h2>\n<p>This guide provides the basic concepts about environments for end users.</p>\n<p>Plugin authors have a more consistent API available to interact with the current environment configuration. If you're building on top of Vite, the <a href=\"api-environment-plugins\">Environment API Plugins Guide</a> guide describes the way extended plugin APIs available to support multiple custom environments.</p>\n<p>Frameworks could decide to expose environments at different levels. If you're a framework author, continue reading the <a href=\"api-environment-frameworks\">Environment API Frameworks Guide</a> to learn about the Environment API programmatic side.</p>\n<p>For Runtime providers, the <a href=\"api-environment-runtimes\">Environment API Runtimes Guide</a> explains how to offer custom environment to be consumed by frameworks and users.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/api-environment\" class=\"_attribution-link\">https://vite.dev/guide/api-environment</a>\n  </p>\n</div>\n","guide/api-environment-plugins":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/api-environment-plugins.md for this page in Markdown format</div>\n<h1 id=\"environment-api-for-plugins\" tabindex=\"-1\">Environment API for Plugins </h1>\n<div class=\"info custom-block\">\n<strong class=\"custom-block-title\">Release Candidate</strong><p>The Environment API is generally in the release candidate phase. We'll maintain stability in the APIs between major releases to allow the ecosystem to experiment and build upon them. However, note that <a href=\"../changes/index#considering\">some specific APIs</a> are still considered experimental.</p>\n<p>We plan to stabilize these new APIs (with potential breaking changes) in a future major release once downstream projects have had time to experiment with the new features and validate them.</p>\n<p>Resources:</p>\n<ul>\n<li>\n<a href=\"https://github.com/vitejs/vite/discussions/16358\" target=\"_blank\" rel=\"noreferrer\">Feedback discussion</a> where we are gathering feedback about the new APIs.</li>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/16471\" target=\"_blank\" rel=\"noreferrer\">Environment API PR</a> where the new API were implemented and reviewed.</li>\n</ul>\n<p>Please share your feedback with us.</p>\n</div>\n<h2 id=\"accessing-the-current-environment-in-hooks\" tabindex=\"-1\">Accessing the Current Environment in Hooks </h2>\n<p>Given that there were only two Environments until Vite 6 (<code>client</code> and <code>ssr</code>), a <code>ssr</code> boolean was enough to identify the current environment in Vite APIs. Plugin Hooks received a <code>ssr</code> boolean in the last options parameter, and several APIs expected an optional last <code>ssr</code> parameter to properly associate modules to the correct environment (for example <code>server.moduleGraph.getModuleByUrl(url, { ssr })</code>).</p>\n<p>With the advent of configurable environments, we now have a uniform way to access their options and instance in plugins. Plugin hooks now expose <code>this.environment</code> in their context, and APIs that previously expected a <code>ssr</code> boolean are now scoped to the proper environment (for example <code>environment.moduleGraph.getModuleByUrl(url)</code>).</p>\n<p>The Vite server has a shared plugin pipeline, but when a module is processed it is always done in the context of a given environment. The <code>environment</code> instance is available in the plugin context.</p>\n<p>A plugin could use the <code>environment</code> instance to change how a module is processed depending on the configuration for the environment (which can be accessed using <code>environment.config</code>).</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">transform(code, id) {\n    console.log(this.environment.config.resolve.conditions)\n  }</pre>\n</div>\n<h2 id=\"registering-new-environments-using-hooks\" tabindex=\"-1\">Registering New Environments Using Hooks </h2>\n<p>Plugins can add new environments in the <code>config</code> hook (for example to have a separate module graph for <a href=\"https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components\" target=\"_blank\" rel=\"noreferrer\">RSC</a>):</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">config(config: UserConfig) {\n    config.environments.rsc ??= {}\n  }</pre>\n</div>\n<p>An empty object is enough to register the environment, default values from the root level environment config.</p>\n<h2 id=\"configuring-environment-using-hooks\" tabindex=\"-1\">Configuring Environment Using Hooks </h2>\n<p>While the <code>config</code> hook is running, the complete list of environments isn't yet known and the environments can be affected by both the default values from the root level environment config or explicitly through the <code>config.environments</code> record. Plugins should set default values using the <code>config</code> hook. To configure each environment, they can use the new <code>configEnvironment</code> hook. This hook is called for each environment with its partially resolved config including resolution of final defaults.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">configEnvironment(name: string, options: EnvironmentOptions) {\n    if (name === 'rsc') {\n      options.resolve.conditions = // ...</pre>\n</div>\n<h2 id=\"the-hotupdate-hook\" tabindex=\"-1\">The <code>hotUpdate</code> Hook </h2>\n<ul>\n<li>\n<strong>Type:</strong> <code>(this: { environment: DevEnvironment }, options: HotUpdateOptions) =&gt; Array&lt;EnvironmentModuleNode&gt; | void | Promise&lt;Array&lt;EnvironmentModuleNode&gt; | void&gt;</code>\n</li>\n<li>\n<strong>See also:</strong> <a href=\"api-hmr\">HMR API</a>\n</li>\n</ul>\n<p>The <code>hotUpdate</code> hook allows plugins to perform custom HMR update handling for a given environment. When a file changes, the HMR algorithm is run for each environment in series according to the order in <code>server.environments</code>, so the <code>hotUpdate</code> hook will be called multiple times. The hook receives a context object with the following signature:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface HotUpdateOptions {\n  type: 'create' | 'update' | 'delete'\n  file: string\n  timestamp: number\n  modules: Array&lt;EnvironmentModuleNode&gt;\n  read: () =&gt; string | Promise&lt;string&gt;\n  server: ViteDevServer\n}</pre>\n</div>\n<ul>\n<li><p><code>this.environment</code> is the module execution environment where a file update is currently being processed.</p></li>\n<li><p><code>modules</code> is an array of modules in this environment that are affected by the changed file. It's an array because a single file may map to multiple served modules (e.g. Vue SFCs).</p></li>\n<li><p><code>read</code> is an async read function that returns the content of the file. This is provided because, on some systems, the file change callback may fire too fast before the editor finishes updating the file, and direct <code>fs.readFile</code> will return empty content. The read function passed in normalizes this behavior.</p></li>\n</ul>\n<p>The hook can choose to:</p>\n<ul>\n<li><p>Filter and narrow down the affected module list so that the HMR is more accurate.</p></li>\n<li>\n<p>Return an empty array and perform a full reload:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">hotUpdate({ modules, timestamp }) {\n  if (this.environment.name !== 'client')\n    return\n\n  // Invalidate modules manually\n  const invalidatedModules = new Set()\n  for (const mod of modules) {\n    this.environment.moduleGraph.invalidateModule(\n      mod,\n      invalidatedModules,\n      timestamp,\n      true\n    )\n  }\n  this.environment.hot.send({ type: 'full-reload' })\n  return []\n}</pre>\n</div>\n</li>\n<li>\n<p>Return an empty array and perform complete custom HMR handling by sending custom events to the client:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">hotUpdate() {\n  if (this.environment.name !== 'client')\n    return\n\n  this.environment.hot.send({\n    type: 'custom',\n    event: 'special-update',\n    data: {}\n  })\n  return []\n}</pre>\n</div>\n<p>Client code should register the corresponding handler using the <a href=\"api-hmr\">HMR API</a> (this could be injected by the same plugin's <code>transform</code> hook):</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">if (import.meta.hot) {\n  import.meta.hot.on('special-update', (data) =&gt; {\n    // perform custom update\n  })\n}</pre>\n</div>\n</li>\n</ul>\n<h2 id=\"per-environment-state-in-plugins\" tabindex=\"-1\">Per-environment State in Plugins </h2>\n<p>Given that the same plugin instance is used for different environments, the plugin state needs to be keyed with <code>this.environment</code>. This is the same pattern the ecosystem has already been using to keep state about modules using the <code>ssr</code> boolean as key to avoid mixing client and ssr modules state. A <code>Map&lt;Environment, State&gt;</code> can be used to keep the state for each environment separately. Note that for backward compatibility, <code>buildStart</code> and <code>buildEnd</code> are only called for the client environment without the <code>perEnvironmentStartEndDuringDev: true</code> flag.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function PerEnvironmentCountTransformedModulesPlugin() {\n  const state = new Map&lt;Environment, { count: number }&gt;()\n  return {\n    name: 'count-transformed-modules',\n    perEnvironmentStartEndDuringDev: true,\n    buildStart() {\n      state.set(this.environment, { count: 0 })\n    },\n    transform(id) {\n      state.get(this.environment).count++\n    },\n    buildEnd() {\n      console.log(this.environment.name, state.get(this.environment).count)\n    }\n  }\n}</pre>\n</div>\n<h2 id=\"per-environment-plugins\" tabindex=\"-1\">Per-environment Plugins </h2>\n<p>A plugin can define what are the environments it should apply to with the <code>applyToEnvironment</code> function.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const UnoCssPlugin = () =&gt; {\n  // shared global state\n  return {\n    buildStart() {\n      // init per-environment state with WeakMap&lt;Environment,Data&gt;\n      // using this.environment\n    },\n    configureServer() {\n      // use global hooks normally\n    },\n    applyToEnvironment(environment) {\n      // return true if this plugin should be active in this environment,\n      // or return a new plugin to replace it.\n      // if the hook is not used, the plugin is active in all environments\n    },\n    resolveId(id, importer) {\n      // only called for environments this plugin apply to\n    },\n  }\n}</pre>\n</div>\n<p>If a plugin isn't environment aware and has state that isn't keyed on the current environment, the <code>applyToEnvironment</code> hook allows to easily make it per-environment.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { nonShareablePlugin } from 'non-shareable-plugin'\n\nexport default defineConfig({\n  plugins: [\n    {\n      name: 'per-environment-plugin',\n      applyToEnvironment(environment) {\n        return nonShareablePlugin({ outputName: environment.name })\n      },\n    },\n  ],\n})</pre>\n</div>\n<p>Vite exports a <code>perEnvironmentPlugin</code> helper to simplify these cases where no other hooks are required:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { nonShareablePlugin } from 'non-shareable-plugin'\n\nexport default defineConfig({\n  plugins: [\n    perEnvironmentPlugin('per-environment-plugin', (environment) =&gt;\n      nonShareablePlugin({ outputName: environment.name }),\n    ),\n  ],\n})</pre>\n</div>\n<p>The <code>applyToEnvironment</code> hook is called at config time, currently after <code>configResolved</code> due to projects in the ecosystem modifying the plugins in it. Environment plugins resolution may be moved before <code>configResolved</code> in the future.</p>\n<h2 id=\"environment-in-build-hooks\" tabindex=\"-1\">Environment in Build Hooks </h2>\n<p>In the same way as during dev, plugin hooks also receive the environment instance during build, replacing the <code>ssr</code> boolean. This also works for <code>renderChunk</code>, <code>generateBundle</code>, and other build only hooks.</p>\n<h2 id=\"shared-plugins-during-build\" tabindex=\"-1\">Shared Plugins During Build </h2>\n<p>Before Vite 6, the plugins pipelines worked in a different way during dev and build:</p>\n<ul>\n<li>\n<strong>During dev:</strong> plugins are shared</li>\n<li>\n<strong>During Build:</strong> plugins are isolated for each environment (in different processes: <code>vite build</code> then <code>vite build --ssr</code>).</li>\n</ul>\n<p>This forced frameworks to share state between the <code>client</code> build and the <code>ssr</code> build through manifest files written to the file system. In Vite 6, we are now building all environments in a single process so the way the plugins pipeline and inter-environment communication can be aligned with dev.</p>\n<p>In a future major, we could have complete alignment:</p>\n<ul><li>\n<strong>During both dev and build:</strong> plugins are shared, with <a href=\"#per-environment-plugins\">per-environment filtering</a>\n</li></ul>\n<p>There will also be a single <code>ResolvedConfig</code> instance shared during build, allowing for caching at entire app build process level in the same way as we have been doing with <code>WeakMap&lt;ResolvedConfig, CachedData&gt;</code> during dev.</p>\n<p>For Vite 6, we need to do a smaller step to keep backward compatibility. Ecosystem plugins are currently using <code>config.build</code> instead of <code>environment.config.build</code> to access configuration, so we need to create a new <code>ResolvedConfig</code> per-environment by default. A project can opt-in into sharing the full config and plugins pipeline setting <code>builder.sharedConfigBuild</code> to <code>true</code>.</p>\n<p>This option would only work of a small subset of projects at first, so plugin authors can opt-in for a particular plugin to be shared by setting the <code>sharedDuringBuild</code> flag to <code>true</code>. This allows for easily sharing state both for regular plugins:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function myPlugin() {\n  // Share state among all environments in dev and build\n  const sharedState = ...\n  return {\n    name: 'shared-plugin',\n    transform(code, id) { ... },\n\n    // Opt-in into a single instance for all environments\n    sharedDuringBuild: true,\n  }\n}</pre>\n</div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/api-environment-plugins\" class=\"_attribution-link\">https://vite.dev/guide/api-environment-plugins</a>\n  </p>\n</div>\n","changes/this-environment-in-hooks":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /changes/this-environment-in-hooks.md for this page in Markdown format</div>\n<h1 id=\"this-environment-in-hooks\" tabindex=\"-1\">\n<code>this.environment</code> in Hooks </h1>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Feedback</strong><p>Give us feedback at <a href=\"https://github.com/vitejs/vite/discussions/16358\" target=\"_blank\" rel=\"noreferrer\">Environment API feedback discussion</a></p>\n</div>\n<p>Before Vite 6, only two environments were available: <code>client</code> and <code>ssr</code>. A single <code>options.ssr</code> plugin hook argument in <code>resolveId</code>, <code>load</code> and <code>transform</code> allowed plugin authors to differentiate between these two environments when processing modules in plugin hooks. In Vite 6, a Vite application can define any number of named environments as needed. We're introducing <code>this.environment</code> in the plugin context to interact with the environment of the current module in hooks.</p>\n<p>Affected scope: <code>Vite Plugin Authors</code></p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Future Deprecation</strong><p><code>this.environment</code> was introduced in <code>v6.0</code>. The deprecation of <code>options.ssr</code> is planned for a future major. At that point we'll start recommending migrating your plugins to use the new API. To identify your usage, set <code>future.removePluginHookSsrArgument</code> to <code>\"warn\"</code> in your vite config.</p>\n</div>\n<h2 id=\"motivation\" tabindex=\"-1\">Motivation </h2>\n<p><code>this.environment</code> not only allow the plugin hook implementation to know the current environment name, it also gives access to the environment config options, module graph information, and transform pipeline (<code>environment.config</code>, <code>environment.moduleGraph</code>, <code>environment.transformRequest()</code>). Having the environment instance available in the context allows plugin authors to avoid the dependency of the whole dev server (typically cached at startup through the <code>configureServer</code> hook).</p>\n<h2 id=\"migration-guide\" tabindex=\"-1\">Migration Guide </h2>\n<p>For the existing plugin to do a quick migration, replace the <code>options.ssr</code> argument with <code>this.environment.config.consumer === 'server'</code> in the <code>resolveId</code>, <code>load</code> and <code>transform</code> hooks:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark has-diff\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { Plugin } from 'vite'\n\nexport function myPlugin(): Plugin {\n  return {\n    name: 'my-plugin',\n    resolveId(id, importer, options) {\n      const isSSR = options.ssr \n      const isSSR = this.environment.config.consumer === 'server'\n\n      if (isSSR) {\n        // SSR specific logic\n      } else {\n        // Client specific logic\n      }\n    },\n  }\n}</pre>\n</div>\n<p>For a more robust long term implementation, the plugin hook should handle for <a href=\"../guide/api-environment-plugins#accessing-the-current-environment-in-hooks\">multiple environments</a> using fine-grained environment options instead of relying on the environment name.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/changes/this-environment-in-hooks\" class=\"_attribution-link\">https://vite.dev/changes/this-environment-in-hooks</a>\n  </p>\n</div>\n","changes/per-environment-apis":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /changes/per-environment-apis.md for this page in Markdown format</div>\n<h1 id=\"move-to-per-environment-apis\" tabindex=\"-1\">Move to Per-environment APIs </h1>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Feedback</strong><p>Give us feedback at <a href=\"https://github.com/vitejs/vite/discussions/16358\" target=\"_blank\" rel=\"noreferrer\">Environment API feedback discussion</a></p>\n</div>\n<p>Multiple APIs from <code>ViteDevServer</code> related to module graph and modules transforms have been moved to the <code>DevEnvironment</code> instances.</p>\n<p>Affected scope: <code>Vite Plugin Authors</code></p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Future Deprecation</strong><p>The <code>Environment</code> instance was first introduced at <code>v6.0</code>. The deprecation of <code>server.moduleGraph</code> and other methods that are now in environments is planned for a future major. We don't recommend moving away from server methods yet. To identify your usage, set these in your vite config.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">future: {\n  removeServerModuleGraph: 'warn',\n  removeServerReloadModule: 'warn',\n  removeServerPluginContainer: 'warn',\n  removeServerHot: 'warn',\n  removeServerTransformRequest: 'warn',\n  removeServerWarmupRequest: 'warn',\n}</pre>\n</div>\n</div>\n<h2 id=\"motivation\" tabindex=\"-1\">Motivation </h2>\n<p>In Vite v5 and before, a single Vite dev server always had two environments (<code>client</code> and <code>ssr</code>). The <code>server.moduleGraph</code> had mixed modules from both of these environments. Nodes were connected through <code>clientImportedModules</code> and <code>ssrImportedModules</code> lists (but a single <code>importers</code> list was maintained for each). A transformed module was represented by an <code>id</code> and a <code>ssr</code> boolean. This boolean needed to be passed to APIs, for example <code>server.moduleGraph.getModuleByUrl(url, ssr)</code> and <code>server.transformRequest(url, { ssr })</code>.</p>\n<p>In Vite v6, it is now possible to create any number of custom environments (<code>client</code>, <code>ssr</code>, <code>edge</code>, etc). A single <code>ssr</code> boolean isn't enough anymore. Instead of changing the APIs to be of the form <code>server.transformRequest(url, { environment })</code>, we moved these methods to the environment instance allowing them to be called without a Vite dev server.</p>\n<h2 id=\"migration-guide\" tabindex=\"-1\">Migration Guide </h2>\n<ul>\n<li>\n<code>server.moduleGraph</code> -&gt; <a href=\"../guide/api-environment-instances#separate-module-graphs\"><code>environment.moduleGraph</code></a>\n</li>\n<li>\n<code>server.reloadModule(module)</code> -&gt; <code>environment.reloadModule(module)</code>\n</li>\n<li>\n<code>server.pluginContainer</code> -&gt; <code>environment.pluginContainer</code>\n</li>\n<li>\n<code>server.transformRequest(url, ssr)</code> -&gt; <code>environment.transformRequest(url)</code>\n</li>\n<li>\n<code>server.warmupRequest(url, ssr)</code> -&gt; <code>environment.warmupRequest(url)</code>\n</li>\n<li>\n<code>server.hot</code> -&gt; <code>server.client.environment.hot</code>\n</li>\n</ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/changes/per-environment-apis\" class=\"_attribution-link\">https://vite.dev/changes/per-environment-apis</a>\n  </p>\n</div>\n","guide/using-plugins":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/using-plugins.md for this page in Markdown format</div>\n<h1 id=\"using-plugins\" tabindex=\"-1\">Using Plugins </h1>\n<p>Vite can be extended using plugins, which are based on Rollup's well-designed plugin interface with a few extra Vite-specific options. This means that Vite users can rely on the mature ecosystem of Rollup plugins, while also being able to extend the dev server and SSR functionality as needed.</p>\n<h2 id=\"adding-a-plugin\" tabindex=\"-1\">Adding a Plugin </h2>\n<p>To use a plugin, it needs to be added to the <code>devDependencies</code> of the project and included in the <code>plugins</code> array in the <code>vite.config.js</code> config file. For example, to provide support for legacy browsers, the official <a href=\"https://github.com/vitejs/vite/tree/main/packages/plugin-legacy\" target=\"_blank\" rel=\"noreferrer\">@vitejs/plugin-legacy</a> can be used:</p>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">$ npm add -D @vitejs/plugin-legacy</pre>\n</div>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import legacy from '@vitejs/plugin-legacy'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    legacy({\n      targets: ['defaults', 'not IE 11'],\n    }),\n  ],\n})</pre>\n</div>\n</div>\n<p><code>plugins</code> also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.</p>\n<p>Falsy plugins will be ignored, which can be used to easily activate or deactivate plugins.</p>\n<h2 id=\"finding-plugins\" tabindex=\"-1\">Finding Plugins </h2>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p>Vite aims to provide out-of-the-box support for common web development patterns. Before searching for a Vite or compatible Rollup plugin, check out the <a href=\"features\">Features Guide</a>. A lot of the cases where a plugin would be needed in a Rollup project are already covered in Vite.</p>\n</div>\n<p>Check out the <a href=\"https://vite.dev/plugins/\">Plugins section</a> for information about official plugins. Community plugins are listed in <a href=\"https://github.com/vitejs/awesome-vite#plugins\" target=\"_blank\" rel=\"noreferrer\">awesome-vite</a>.</p>\n<p>You can also find plugins that follow the <a href=\"api-plugin#conventions\">recommended conventions</a> using a <a href=\"https://www.npmjs.com/search?q=vite-plugin&amp;ranking=popularity\" target=\"_blank\" rel=\"noreferrer\">npm search for vite-plugin</a> for Vite plugins or a <a href=\"https://www.npmjs.com/search?q=rollup-plugin&amp;ranking=popularity\" target=\"_blank\" rel=\"noreferrer\">npm search for rollup-plugin</a> for Rollup plugins.</p>\n<h2 id=\"enforcing-plugin-ordering\" tabindex=\"-1\">Enforcing Plugin Ordering </h2>\n<p>For compatibility with some Rollup plugins, it may be needed to enforce the order of the plugin or only apply at build time. This should be an implementation detail for Vite plugins. You can enforce the position of a plugin with the <code>enforce</code> modifier:</p>\n<ul>\n<li>\n<code>pre</code>: invoke plugin before Vite core plugins</li>\n<li>default: invoke plugin after Vite core plugins</li>\n<li>\n<code>post</code>: invoke plugin after Vite build plugins</li>\n</ul>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import image from '@rollup/plugin-image'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...image(),\n      enforce: 'pre',\n    },\n  ],\n})</pre>\n</div>\n</div>\n<p>Check out <a href=\"api-plugin#plugin-ordering\">Plugins API Guide</a> for detailed information.</p>\n<h2 id=\"conditional-application\" tabindex=\"-1\">Conditional Application </h2>\n<p>By default, plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the <code>apply</code> property to only invoke them during <code>'build'</code> or <code>'serve'</code>:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import typescript2 from 'rollup-plugin-typescript2'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...typescript2(),\n      apply: 'build',\n    },\n  ],\n})</pre>\n</div>\n</div>\n<h2 id=\"building-plugins\" tabindex=\"-1\">Building Plugins </h2>\n<p>Check out the <a href=\"api-plugin\">Plugins API Guide</a> for documentation about creating plugins.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/using-plugins\" class=\"_attribution-link\">https://vite.dev/guide/using-plugins</a>\n  </p>\n</div>\n","guide/api-javascript":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/api-javascript.md for this page in Markdown format</div>\n<h1 id=\"javascript-api\" tabindex=\"-1\">JavaScript API </h1>\n<p>Vite's JavaScript APIs are fully typed, and it's recommended to use TypeScript or enable JS type checking in VS Code to leverage the intellisense and validation.</p>\n<h2 id=\"createserver\" tabindex=\"-1\">\n<code>createServer</code> </h2>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">async function createServer(inlineConfig?: InlineConfig): Promise&lt;ViteDevServer&gt;</pre>\n</div>\n<p><strong>Example Usage:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { fileURLToPath } from 'node:url'\nimport { createServer } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\nconst server = await createServer({\n  // any valid user config options, plus `mode` and `configFile`\n  configFile: false,\n  root: __dirname,\n  server: {\n    port: 1337,\n  },\n})\nawait server.listen()\n\nserver.printUrls()\nserver.bindCLIShortcuts({ print: true })</pre>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p>When using <code>createServer</code> and <code>build</code> in the same Node.js process, both functions rely on <code>process.env.NODE_ENV</code> to work properly, which also depends on the <code>mode</code> config option. To prevent conflicting behavior, set <code>process.env.NODE_ENV</code> or the <code>mode</code> of the two APIs to <code>development</code>. Otherwise, you can spawn a child process to run the APIs separately.</p>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p>When using <a href=\"../config/server-options#server-middlewaremode\">middleware mode</a> combined with <a href=\"../config/server-options#server-proxy\">proxy config for WebSocket</a>, the parent http server should be provided in <code>middlewareMode</code> to bind the proxy correctly.</p>\n<div>\n<summary>Example</summary><div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import http from 'http'\nimport { createServer } from 'vite'\n\nconst parentServer = http.createServer() // or express, koa, etc.\n\nconst vite = await createServer({\n  server: {\n    // Enable middleware mode\n    middlewareMode: {\n      // Provide the parent http server for proxy WebSocket\n      server: parentServer,\n    },\n    proxy: {\n      '/ws': {\n        target: 'ws://localhost:3000',\n        // Proxying WebSocket\n        ws: true,\n      },\n    },\n  },\n})\n\nparentServer.use(vite.middlewares)</pre>\n</div>\n</div>\n</div>\n<h2 id=\"inlineconfig\" tabindex=\"-1\">\n<code>InlineConfig</code> </h2>\n<p>The <code>InlineConfig</code> interface extends <code>UserConfig</code> with additional properties:</p>\n<ul><li>\n<code>configFile</code>: specify config file to use. If not set, Vite will try to automatically resolve one from project root. Set to <code>false</code> to disable auto resolving.</li></ul>\n<h2 id=\"resolvedconfig\" tabindex=\"-1\">\n<code>ResolvedConfig</code> </h2>\n<p>The <code>ResolvedConfig</code> interface has all the same properties of a <code>UserConfig</code>, except most properties are resolved and non-undefined. It also contains utilities like:</p>\n<ul>\n<li>\n<code>config.assetsInclude</code>: A function to check if an <code>id</code> is considered an asset.</li>\n<li>\n<code>config.logger</code>: Vite's internal logger object.</li>\n</ul>\n<h2 id=\"vitedevserver\" tabindex=\"-1\">\n<code>ViteDevServer</code> </h2>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface ViteDevServer {\n  /**\n   * The resolved Vite config object.\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance\n   * - Can be used to attach custom middlewares to the dev server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks.\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * Native Node http server instance.\n   * Will be null in middleware mode.\n   */\n  httpServer: http.Server | null\n  /**\n   * Chokidar watcher instance. If `config.server.watch` is set to `null`,\n   * it will not watch any files and calling `add` or `unwatch` will have no effect.\n   * https://github.com/paulmillr/chokidar/tree/3.6.0#api\n   */\n  watcher: FSWatcher\n  /**\n   * Web socket server with `send(payload)` method.\n   */\n  ws: WebSocketServer\n  /**\n   * Rollup plugin container that can run plugin hooks on a given file.\n   */\n  pluginContainer: PluginContainer\n  /**\n   * Module graph that tracks the import relationships, url to file mapping\n   * and hmr state.\n   */\n  moduleGraph: ModuleGraph\n  /**\n   * The resolved urls Vite prints on the CLI (URL-encoded). Returns `null`\n   * in middleware mode or if the server is not listening on any port.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Programmatically resolve, load and transform a URL and get the result\n   * without going through the http request pipeline.\n   */\n  transformRequest(\n    url: string,\n    options?: TransformOptions,\n  ): Promise&lt;TransformResult | null&gt;\n  /**\n   * Apply Vite built-in HTML transforms and any plugin HTML transforms.\n   */\n  transformIndexHtml(\n    url: string,\n    html: string,\n    originalUrl?: string,\n  ): Promise&lt;string&gt;\n  /**\n   * Load a given URL as an instantiated module for SSR.\n   */\n  ssrLoadModule(\n    url: string,\n    options?: { fixStacktrace?: boolean },\n  ): Promise&lt;Record&lt;string, any&gt;&gt;\n  /**\n   * Fix ssr error stacktrace.\n   */\n  ssrFixStacktrace(e: Error): void\n  /**\n   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`\n   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.\n   */\n  reloadModule(module: ModuleNode): Promise&lt;void&gt;\n  /**\n   * Start the server.\n   */\n  listen(port?: number, isRestart?: boolean): Promise&lt;ViteDevServer&gt;\n  /**\n   * Restart the server.\n   *\n   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag\n   */\n  restart(forceOptimize?: boolean): Promise&lt;void&gt;\n  /**\n   * Stop the server.\n   */\n  close(): Promise&lt;void&gt;\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions&lt;ViteDevServer&gt;): void\n  /**\n   * Calling `await server.waitForRequestsIdle(id)` will wait until all static imports\n   * are processed. If called from a load or transform plugin hook, the id needs to be\n   * passed as a parameter to avoid deadlocks. Calling this function after the first\n   * static imports section of the module graph has been processed will resolve immediately.\n   * @experimental\n   */\n  waitForRequestsIdle: (ignoredId?: string) =&gt; Promise&lt;void&gt;\n}</pre>\n</div>\n<div class=\"info custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">INFO</strong><p><code>waitForRequestsIdle</code> is meant to be used as a escape hatch to improve DX for features that can't be implemented following the on-demand nature of the Vite dev server. It can be used during startup by tools like Tailwind to delay generating the app CSS classes until the app code has been seen, avoiding flashes of style changes. When this function is used in a load or transform hook, and the default HTTP1 server is used, one of the six http channels will be blocked until the server processes all static imports. Vite's dependency optimizer currently uses this function to avoid full-page reloads on missing dependencies by delaying loading of pre-bundled dependencies until all imported dependencies have been collected from static imported sources. Vite may switch to a different strategy in a future major release, setting <code>optimizeDeps.crawlUntilStaticImports: false</code> by default to avoid the performance hit in large applications during cold start.</p>\n</div>\n<h2 id=\"build\" tabindex=\"-1\">\n<code>build</code> </h2>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">async function build(\n  inlineConfig?: InlineConfig,\n): Promise&lt;RollupOutput | RollupOutput[]&gt;</pre>\n</div>\n<p><strong>Example Usage:</strong></p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { build } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\nawait build({\n  root: path.resolve(__dirname, './project'),\n  base: '/foo/',\n  build: {\n    rollupOptions: {\n      // ...\n    },\n  },\n})</pre>\n</div>\n</div>\n<h2 id=\"preview\" tabindex=\"-1\">\n<code>preview</code> </h2>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">async function preview(inlineConfig?: InlineConfig): Promise&lt;PreviewServer&gt;</pre>\n</div>\n<p><strong>Example Usage:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { preview } from 'vite'\n\nconst previewServer = await preview({\n  // any valid user config options, plus `mode` and `configFile`\n  preview: {\n    port: 8080,\n    open: true,\n  },\n})\n\npreviewServer.printUrls()\npreviewServer.bindCLIShortcuts({ print: true })</pre>\n</div>\n<h2 id=\"previewserver\" tabindex=\"-1\">\n<code>PreviewServer</code> </h2>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface PreviewServer {\n  /**\n   * The resolved vite config object\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance.\n   * - Can be used to attach custom middlewares to the preview server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * native Node http server instance\n   */\n  httpServer: http.Server\n  /**\n   * The resolved urls Vite prints on the CLI (URL-encoded). Returns `null`\n   * if the server is not listening on any port.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Print server urls\n   */\n  printUrls(): void\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions&lt;PreviewServer&gt;): void\n}</pre>\n</div>\n<h2 id=\"resolveconfig\" tabindex=\"-1\">\n<code>resolveConfig</code> </h2>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">async function resolveConfig(\n  inlineConfig: InlineConfig,\n  command: 'build' | 'serve',\n  defaultMode = 'development',\n  defaultNodeEnv = 'development',\n  isPreview = false,\n): Promise&lt;ResolvedConfig&gt;</pre>\n</div>\n<p>The <code>command</code> value is <code>serve</code> in dev and preview, and <code>build</code> in build.</p>\n<h2 id=\"mergeconfig\" tabindex=\"-1\">\n<code>mergeConfig</code> </h2>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function mergeConfig(\n  defaults: Record&lt;string, any&gt;,\n  overrides: Record&lt;string, any&gt;,\n  isRoot = true,\n): Record&lt;string, any&gt;</pre>\n</div>\n<p>Deeply merge two Vite configs. <code>isRoot</code> represents the level within the Vite config which is being merged. For example, set <code>false</code> if you're merging two <code>build</code> options.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p><code>mergeConfig</code> accepts only config in object form. If you have a config in callback form, you should call it before passing into <code>mergeConfig</code>.</p>\n<p>You can use the <code>defineConfig</code> helper to merge a config in callback form with another config:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default defineConfig((configEnv) =&gt;\n  mergeConfig(configAsCallback(configEnv), configAsObject),\n)</pre>\n</div>\n</div>\n<h2 id=\"searchforworkspaceroot\" tabindex=\"-1\">\n<code>searchForWorkspaceRoot</code> </h2>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function searchForWorkspaceRoot(\n  current: string,\n  root = searchForPackageRoot(current),\n): string</pre>\n</div>\n<p><strong>Related:</strong> <a href=\"../config/server-options#server-fs-allow\">server.fs.allow</a></p>\n<p>Search for the root of the potential workspace if it meets the following conditions, otherwise it would fallback to <code>root</code>:</p>\n<ul>\n<li>contains <code>workspaces</code> field in <code>package.json</code>\n</li>\n<li>contains one of the following file <ul>\n<li><code>lerna.json</code></li>\n<li><code>pnpm-workspace.yaml</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"loadenv\" tabindex=\"-1\">\n<code>loadEnv</code> </h2>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function loadEnv(\n  mode: string,\n  envDir: string,\n  prefixes: string | string[] = 'VITE_',\n): Record&lt;string, string&gt;</pre>\n</div>\n<p><strong>Related:</strong> <a href=\"env-and-mode#env-files\"><code>.env</code> Files</a></p>\n<p>Load <code>.env</code> files within the <code>envDir</code>. By default, only env variables prefixed with <code>VITE_</code> are loaded, unless <code>prefixes</code> is changed.</p>\n<h2 id=\"normalizepath\" tabindex=\"-1\">\n<code>normalizePath</code> </h2>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function normalizePath(id: string): string</pre>\n</div>\n<p><strong>Related:</strong> <a href=\"api-plugin#path-normalization\">Path Normalization</a></p>\n<p>Normalizes a path to interoperate between Vite plugins.</p>\n<h2 id=\"transformwithesbuild\" tabindex=\"-1\">\n<code>transformWithEsbuild</code> </h2>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">async function transformWithEsbuild(\n  code: string,\n  filename: string,\n  options?: EsbuildTransformOptions,\n  inMap?: object,\n): Promise&lt;ESBuildTransformResult&gt;</pre>\n</div>\n<p>Transform JavaScript or TypeScript with esbuild. Useful for plugins that prefer matching Vite's internal esbuild transform.</p>\n<h2 id=\"loadconfigfromfile\" tabindex=\"-1\">\n<code>loadConfigFromFile</code> </h2>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">async function loadConfigFromFile(\n  configEnv: ConfigEnv,\n  configFile?: string,\n  configRoot: string = process.cwd(),\n  logLevel?: LogLevel,\n  customLogger?: Logger,\n): Promise&lt;{\n  path: string\n  config: UserConfig\n  dependencies: string[]\n} | null&gt;</pre>\n</div>\n<p>Load a Vite config file manually with esbuild.</p>\n<h2 id=\"preprocesscss\" tabindex=\"-1\">\n<code>preprocessCSS</code> </h2>\n<ul><li>\n<strong>Experimental:</strong> <a href=\"https://github.com/vitejs/vite/discussions/13815\" target=\"_blank\" rel=\"noreferrer\">Give Feedback</a>\n</li></ul>\n<p><strong>Type Signature:</strong></p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">async function preprocessCSS(\n  code: string,\n  filename: string,\n  config: ResolvedConfig,\n): Promise&lt;PreprocessCSSResult&gt;\n\ninterface PreprocessCSSResult {\n  code: string\n  map?: SourceMapInput\n  modules?: Record&lt;string, string&gt;\n  deps?: Set&lt;string&gt;\n}</pre>\n</div>\n<p>Pre-processes <code>.css</code>, <code>.scss</code>, <code>.sass</code>, <code>.less</code>, <code>.styl</code> and <code>.stylus</code> files to plain CSS so it can be used in browsers or parsed by other tools. Similar to the <a href=\"features#css-pre-processors\">built-in CSS pre-processing support</a>, the corresponding pre-processor must be installed if used.</p>\n<p>The pre-processor used is inferred from the <code>filename</code> extension. If the <code>filename</code> ends with <code>.module.{ext}</code>, it is inferred as a <a href=\"https://github.com/css-modules/css-modules\" target=\"_blank\" rel=\"noreferrer\">CSS module</a> and the returned result will include a <code>modules</code> object mapping the original class names to the transformed ones.</p>\n<p>Note that pre-processing will not resolve URLs in <code>url()</code> or <code>image-set()</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/api-javascript\" class=\"_attribution-link\">https://vite.dev/guide/api-javascript</a>\n  </p>\n</div>\n","guide/api-environment-frameworks":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/api-environment-frameworks.md for this page in Markdown format</div>\n<h1 id=\"environment-api-for-frameworks\" tabindex=\"-1\">Environment API for Frameworks </h1>\n<div class=\"info custom-block\">\n<strong class=\"custom-block-title\">Release Candidate</strong><p>The Environment API is generally in the release candidate phase. We'll maintain stability in the APIs between major releases to allow the ecosystem to experiment and build upon them. However, note that <a href=\"../changes/index#considering\">some specific APIs</a> are still considered experimental.</p>\n<p>We plan to stabilize these new APIs (with potential breaking changes) in a future major release once downstream projects have had time to experiment with the new features and validate them.</p>\n<p>Resources:</p>\n<ul>\n<li>\n<a href=\"https://github.com/vitejs/vite/discussions/16358\" target=\"_blank\" rel=\"noreferrer\">Feedback discussion</a> where we are gathering feedback about the new APIs.</li>\n<li>\n<a href=\"https://github.com/vitejs/vite/pull/16471\" target=\"_blank\" rel=\"noreferrer\">Environment API PR</a> where the new API were implemented and reviewed.</li>\n</ul>\n<p>Please share your feedback with us.</p>\n</div>\n<h2 id=\"devenvironment-communication-levels\" tabindex=\"-1\">DevEnvironment Communication Levels </h2>\n<p>Since environments may run in different runtimes, communication against the environment may have constraints depending on the runtime. To allow frameworks to write runtime agnostic code easily, the Environment API provides three kinds of communication levels.</p>\n<h3 id=\"runnabledevenvironment\" tabindex=\"-1\">\n<code>RunnableDevEnvironment</code> </h3>\n<p><code>RunnableDevEnvironment</code> is an environment that can communicate arbitrary values. The implicit <code>ssr</code> environment and other non-client environments use a <code>RunnableDevEnvironment</code> by default during dev. While this requires the runtime to be the same with the one the Vite server is running in, this works similarly with <code>ssrLoadModule</code> and allows frameworks to migrate and enable HMR for their SSR dev story. You can guard any runnable environment with an <code>isRunnableDevEnvironment</code> function.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export class RunnableDevEnvironment extends DevEnvironment {\n  public readonly runner: ModuleRunner\n}\n\nclass ModuleRunner {\n  /**\n   * URL to execute.\n   * Accepts file path, server path, or id relative to the root.\n   * Returns an instantiated module (same as in ssrLoadModule)\n   */\n  public async import(url: string): Promise&lt;Record&lt;string, any&gt;&gt;\n  /**\n   * Other ModuleRunner methods...\n   */\n}\n\nif (isRunnableDevEnvironment(server.environments.ssr)) {\n  await server.environments.ssr.runner.import('/entry-point.js')\n}</pre>\n</div>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">WARNING</strong><p>The <code>runner</code> is evaluated lazily only when it's accessed for the first time. Beware that Vite enables source map support when the <code>runner</code> is created by calling <code>process.setSourceMapsEnabled</code> or by overriding <code>Error.prepareStackTrace</code> if it's not available.</p>\n</div>\n<p>Given a Vite server configured in middleware mode as described by the <a href=\"ssr#setting-up-the-dev-server\">SSR setup guide</a>, let's implement the SSR middleware using the environment API. Remember that it doesn't have to be called <code>ssr</code>, so we'll name it <code>server</code> in this example. Error handling is omitted.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import fs from 'node:fs'\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { createServer } from 'vite'\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\nconst viteServer = await createServer({\n  server: { middlewareMode: true },\n  appType: 'custom',\n  environments: {\n    server: {\n      // by default, modules are run in the same process as the vite server\n    },\n  },\n})\n\n// You might need to cast this to RunnableDevEnvironment in TypeScript or\n// use isRunnableDevEnvironment to guard the access to the runner\nconst serverEnvironment = viteServer.environments.server\n\napp.use('*', async (req, res, next) =&gt; {\n  const url = req.originalUrl\n\n  // 1. Read index.html\n  const indexHtmlPath = path.resolve(__dirname, 'index.html')\n  let template = fs.readFileSync(indexHtmlPath, 'utf-8')\n\n  // 2. Apply Vite HTML transforms. This injects the Vite HMR client,\n  //    and also applies HTML transforms from Vite plugins, e.g. global\n  //    preambles from @vitejs/plugin-react\n  template = await viteServer.transformIndexHtml(url, template)\n\n  // 3. Load the server entry. import(url) automatically transforms\n  //    ESM source code to be usable in Node.js! There is no bundling\n  //    required, and provides full HMR support.\n  const { render } = await serverEnvironment.runner.import(\n    '/src/entry-server.js',\n  )\n\n  // 4. render the app HTML. This assumes entry-server.js's exported\n  //     `render` function calls appropriate framework SSR APIs,\n  //    e.g. ReactDOMServer.renderToString()\n  const appHtml = await render(url)\n\n  // 5. Inject the app-rendered HTML into the template.\n  const html = template.replace(`&lt;!--ssr-outlet--&gt;`, appHtml)\n\n  // 6. Send the rendered HTML back.\n  res.status(200).set({ 'Content-Type': 'text/html' }).end(html)\n})</pre>\n</div>\n<p>When using environments that support HMR (such as <code>RunnableDevEnvironment</code>), you should add <code>import.meta.hot.accept()</code> in your server entry file for optimal behavior. Without this, server file changes will invalidate the entire server module graph:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// src/entry-server.js\nexport function render(...) { ... }\n\nif (import.meta.hot) {\n  import.meta.hot.accept()\n}</pre>\n</div>\n<h3 id=\"fetchabledevenvironment\" tabindex=\"-1\">\n<code>FetchableDevEnvironment</code> </h3>\n<div class=\"info custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">INFO</strong><p>We are looking for feedback on <a href=\"https://github.com/vitejs/vite/discussions/18191\" target=\"_blank\" rel=\"noreferrer\">the <code>FetchableDevEnvironment</code> proposal</a>.</p>\n</div>\n<p><code>FetchableDevEnvironment</code> is an environment that can communicate with its runtime via the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch\" target=\"_blank\" rel=\"noreferrer\">Fetch API</a> interface. Since the <code>RunnableDevEnvironment</code> is only possible to implement in a limited set of runtimes, we recommend to use the <code>FetchableDevEnvironment</code> instead of the <code>RunnableDevEnvironment</code>.</p>\n<p>This environment provides a standardized way of handling requests via the <code>handleRequest</code> method:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import {\n  createServer,\n  createFetchableDevEnvironment,\n  isFetchableDevEnvironment,\n} from 'vite'\n\nconst server = await createServer({\n  server: { middlewareMode: true },\n  appType: 'custom',\n  environments: {\n    custom: {\n      dev: {\n        createEnvironment(name, config) {\n          return createFetchableDevEnvironment(name, config, {\n            handleRequest(request: Request): Promise&lt;Response&gt; | Response {\n              // handle Request and return a Response\n            },\n          })\n        },\n      },\n    },\n  },\n})\n\n// Any consumer of the environment API can now call `dispatchFetch`\nif (isFetchableDevEnvironment(server.environments.custom)) {\n  const response: Response = await server.environments.custom.dispatchFetch(\n    new Request('/request-to-handle'),\n  )\n}</pre>\n</div>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">WARNING</strong><p>Vite validates the input and output of the <code>dispatchFetch</code> method: the request must be an instance of the global <code>Request</code> class and the response must be the instance of the global <code>Response</code> class. Vite will throw a <code>TypeError</code> if this is not the case.</p>\n<p>Note that although the <code>FetchableDevEnvironment</code> is implemented as a class, it is considered an implementation detail by the Vite team and might change at any moment.</p>\n</div>\n<h3 id=\"raw-devenvironment\" tabindex=\"-1\">raw <code>DevEnvironment</code> </h3>\n<p>If the environment does not implement the <code>RunnableDevEnvironment</code> or <code>FetchableDevEnvironment</code> interfaces, you need to set up the communication manually.</p>\n<p>If your code can run in the same runtime as the user modules (i.e., it does not rely on Node.js-specific APIs), you can use a virtual module. This approach eliminates the need to access the value from the code using Vite's APIs.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// code using the Vite's APIs\nimport { createServer } from 'vite'\n\nconst server = createServer({\n  plugins: [\n    // a plugin that handles `virtual:entrypoint`\n    {\n      name: 'virtual-module',\n      /* plugin implementation */\n    },\n  ],\n})\nconst ssrEnvironment = server.environment.ssr\nconst input = {}\n\n// use exposed functions by each environment factories that runs the code\n// check for each environment factories what they provide\nif (ssrEnvironment instanceof CustomDevEnvironment) {\n  ssrEnvironment.runEntrypoint('virtual:entrypoint')\n} else {\n  throw new Error(`Unsupported runtime for ${ssrEnvironment.name}`)\n}\n\n// -------------------------------------\n// virtual:entrypoint\nconst { createHandler } = await import('./entrypoint.js')\nconst handler = createHandler(input)\nconst response = handler(new Request('/'))\n\n// -------------------------------------\n// ./entrypoint.js\nexport function createHandler(input) {\n  return function handler(req) {\n    return new Response('hello')\n  }\n}</pre>\n</div>\n<p>For example, to call <code>transformIndexHtml</code> on the user module, the following plugin can be used:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function vitePluginVirtualIndexHtml(): Plugin {\n  let server: ViteDevServer | undefined\n  return {\n    name: vitePluginVirtualIndexHtml.name,\n    configureServer(server_) {\n      server = server_\n    },\n    resolveId(source) {\n      return source === 'virtual:index-html' ? '\\0' + source : undefined\n    },\n    async load(id) {\n      if (id === '\\0' + 'virtual:index-html') {\n        let html: string\n        if (server) {\n          this.addWatchFile('index.html')\n          html = fs.readFileSync('index.html', 'utf-8')\n          html = await server.transformIndexHtml('/', html)\n        } else {\n          html = fs.readFileSync('dist/client/index.html', 'utf-8')\n        }\n        return `export default ${JSON.stringify(html)}`\n      }\n      return\n    },\n  }\n}</pre>\n</div>\n<p>If your code requires Node.js APIs, you can use <code>hot.send</code> to communicate with the code that uses Vite's APIs from the user modules. However, be aware that this approach may not work the same way after the build process.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// code using the Vite's APIs\nimport { createServer } from 'vite'\n\nconst server = createServer({\n  plugins: [\n    // a plugin that handles `virtual:entrypoint`\n    {\n      name: 'virtual-module',\n      /* plugin implementation */\n    },\n  ],\n})\nconst ssrEnvironment = server.environment.ssr\nconst input = {}\n\n// use exposed functions by each environment factories that runs the code\n// check for each environment factories what they provide\nif (ssrEnvironment instanceof RunnableDevEnvironment) {\n  ssrEnvironment.runner.import('virtual:entrypoint')\n} else if (ssrEnvironment instanceof CustomDevEnvironment) {\n  ssrEnvironment.runEntrypoint('virtual:entrypoint')\n} else {\n  throw new Error(`Unsupported runtime for ${ssrEnvironment.name}`)\n}\n\nconst req = new Request('/')\n\nconst uniqueId = 'a-unique-id'\nssrEnvironment.send('request', serialize({ req, uniqueId }))\nconst response = await new Promise((resolve) =&gt; {\n  ssrEnvironment.on('response', (data) =&gt; {\n    data = deserialize(data)\n    if (data.uniqueId === uniqueId) {\n      resolve(data.res)\n    }\n  })\n})\n\n// -------------------------------------\n// virtual:entrypoint\nconst { createHandler } = await import('./entrypoint.js')\nconst handler = createHandler(input)\n\nimport.meta.hot.on('request', (data) =&gt; {\n  const { req, uniqueId } = deserialize(data)\n  const res = handler(req)\n  import.meta.hot.send('response', serialize({ res: res, uniqueId }))\n})\n\nconst response = handler(new Request('/'))\n\n// -------------------------------------\n// ./entrypoint.js\nexport function createHandler(input) {\n  return function handler(req) {\n    return new Response('hello')\n  }\n}</pre>\n</div>\n<h2 id=\"environments-during-build\" tabindex=\"-1\">Environments During Build </h2>\n<p>In the CLI, calling <code>vite build</code> and <code>vite build --ssr</code> will still build the client only and ssr only environments for backward compatibility.</p>\n<p>When <code>builder</code> is not <code>undefined</code> (or when calling <code>vite build --app</code>), <code>vite build</code> will opt-in into building the entire app instead. This would later on become the default in a future major. A <code>ViteBuilder</code> instance will be created (build-time equivalent to a <code>ViteDevServer</code>) to build all configured environments for production. By default the build of environments is run in series respecting the order of the <code>environments</code> record. A framework or user can further configure how the environments are built using:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export default {\n  builder: {\n    buildApp: async (builder) =&gt; {\n      const environments = Object.values(builder.environments)\n      return Promise.all(\n        environments.map((environment) =&gt; builder.build(environment)),\n      )\n    },\n  },\n}</pre>\n</div>\n<p>Plugins can also define a <code>buildApp</code> hook. Order <code>'pre'</code> and <code>null</code> are executed before the configured <code>builder.buildApp</code>, and order <code>'post'</code> hooks are executed after it. <code>environment.isBuilt</code> can be used to check if an environment has already being build.</p>\n<h2 id=\"environment-agnostic-code\" tabindex=\"-1\">Environment Agnostic Code </h2>\n<p>Most of the time, the current <code>environment</code> instance will be available as part of the context of the code being run so the need to access them through <code>server.environments</code> should be rare. For example, inside plugin hooks the environment is exposed as part of the <code>PluginContext</code>, so it can be accessed using <code>this.environment</code>. See <a href=\"api-environment-plugins\">Environment API for Plugins</a> to learn about how to build environment aware plugins.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/api-environment-frameworks\" class=\"_attribution-link\">https://vite.dev/guide/api-environment-frameworks</a>\n  </p>\n</div>\n","changes/ssr-using-modulerunner":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /changes/ssr-using-modulerunner.md for this page in Markdown format</div>\n<h1 id=\"ssr-using-modulerunner-api\" tabindex=\"-1\">SSR Using <code>ModuleRunner</code> API </h1>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Feedback</strong><p>Give us feedback at <a href=\"https://github.com/vitejs/vite/discussions/16358\" target=\"_blank\" rel=\"noreferrer\">Environment API feedback discussion</a></p>\n</div>\n<p><code>server.ssrLoadModule</code> has been replaced by importing from a <a href=\"../guide/api-environment#modulerunner\">Module Runner</a>.</p>\n<p>Affected scope: <code>Vite Plugin Authors</code></p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Future Deprecation</strong><p><code>ModuleRunner</code> was first introduced in <code>v6.0</code>. The deprecation of <code>server.ssrLoadModule</code> is planned for a future major. To identify your usage, set <code>future.removeSsrLoadModule</code> to <code>\"warn\"</code> in your vite config.</p>\n</div>\n<h2 id=\"motivation\" tabindex=\"-1\">Motivation </h2>\n<p>The <code>server.ssrLoadModule(url)</code> only allows importing modules in the <code>ssr</code> environment and can only execute the modules in the same process as the Vite dev server. For apps with custom environments, each is associated with a <code>ModuleRunner</code> that may be running in a separate thread or process. To import modules, we now have <code>moduleRunner.import(url)</code>.</p>\n<h2 id=\"migration-guide\" tabindex=\"-1\">Migration Guide </h2>\n<p>Check out the <a href=\"../guide/api-environment-frameworks\">Environment API for Frameworks Guide</a>.</p>\n<p><code>server.ssrFixStacktrace</code> and <code>server.ssrRewriteStacktrace</code> does not have to be called when using the Module Runner APIs. The stack traces will be updated unless <code>sourcemapInterceptor</code> is set to <code>false</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/changes/ssr-using-modulerunner\" class=\"_attribution-link\">https://vite.dev/changes/ssr-using-modulerunner</a>\n  </p>\n</div>\n","changes/shared-plugins-during-build":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /changes/shared-plugins-during-build.md for this page in Markdown format</div>\n<h1 id=\"shared-plugins-during-build\" tabindex=\"-1\">Shared Plugins during Build </h1>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Feedback</strong><p>Give us feedback at <a href=\"https://github.com/vitejs/vite/discussions/16358\" target=\"_blank\" rel=\"noreferrer\">Environment API feedback discussion</a></p>\n</div>\n<p>See <a href=\"../guide/api-environment-plugins#shared-plugins-during-build\">Shared plugins during build</a>.</p>\n<p>Affected scope: <code>Vite Plugin Authors</code></p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Future Default Change</strong><p><code>builder.sharedConfigBuild</code> was first introduced in <code>v6.0</code>. You can set it true to check how your plugins work with a shared config. We're looking for feedback about changing the default in a future major once the plugin ecosystem is ready.</p>\n</div>\n<h2 id=\"motivation\" tabindex=\"-1\">Motivation </h2>\n<p>Align dev and build plugin pipelines.</p>\n<h2 id=\"migration-guide\" tabindex=\"-1\">Migration Guide </h2>\n<p>To be able to share plugins across environments, plugin state must be keyed by the current environment. A plugin of the following form will count the number of transformed modules across all environments.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function CountTransformedModulesPlugin() {\n  let transformedModules\n  return {\n    name: 'count-transformed-modules',\n    buildStart() {\n      transformedModules = 0\n    },\n    transform(id) {\n      transformedModules++\n    },\n    buildEnd() {\n      console.log(transformedModules)\n    },\n  }\n}</pre>\n</div>\n<p>If we instead want to count the number of transformed modules for each environment, we need to keep a map:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function PerEnvironmentCountTransformedModulesPlugin() {\n  const state = new Map&lt;Environment, { count: number }&gt;()\n  return {\n    name: 'count-transformed-modules',\n    perEnvironmentStartEndDuringDev: true,\n    buildStart() {\n      state.set(this.environment, { count: 0 })\n    }\n    transform(id) {\n      state.get(this.environment).count++\n    },\n    buildEnd() {\n      console.log(this.environment.name, state.get(this.environment).count)\n    }\n  }\n}</pre>\n</div>\n<p>To simplify this pattern, Vite exports a <code>perEnvironmentState</code> helper:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">function PerEnvironmentCountTransformedModulesPlugin() {\n  const state = perEnvironmentState&lt;{ count: number }&gt;(() =&gt; ({ count: 0 }))\n  return {\n    name: 'count-transformed-modules',\n    perEnvironmentStartEndDuringDev: true,\n    buildStart() {\n      state(this).count = 0\n    }\n    transform(id) {\n      state(this).count++\n    },\n    buildEnd() {\n      console.log(this.environment.name, state(this).count)\n    }\n  }\n}</pre>\n</div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/changes/shared-plugins-during-build\" class=\"_attribution-link\">https://vite.dev/changes/shared-plugins-during-build</a>\n  </p>\n</div>\n","guide/ssr":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/ssr.md for this page in Markdown format</div>\n<h1 id=\"server-side-rendering-ssr\" tabindex=\"-1\">Server-Side Rendering (SSR) </h1>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Note</strong><p>SSR specifically refers to front-end frameworks (for example React, Preact, Vue, and Svelte) that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. If you are looking for integration with traditional server-side frameworks, check out the <a href=\"backend-integration\">Backend Integration guide</a> instead.</p>\n<p>The following guide also assumes prior experience working with SSR in your framework of choice, and will only focus on Vite-specific integration details.</p>\n</div>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Low-level API</strong><p>This is a low-level API meant for library and framework authors. If your goal is to create an application, make sure to check out the higher-level SSR plugins and tools at <a href=\"https://github.com/vitejs/awesome-vite#ssr\" target=\"_blank\" rel=\"noreferrer\">Awesome Vite SSR section</a> first. That said, many applications are successfully built directly on top of Vite's native low-level API.</p>\n<p>Currently, Vite is working on an improved SSR API with the <a href=\"https://github.com/vitejs/vite/discussions/16358\" target=\"_blank\" rel=\"noreferrer\">Environment API</a>. Check out the link for more details.</p>\n</div>\n<h2 id=\"example-projects\" tabindex=\"-1\">Example Projects </h2>\n<p>Vite provides built-in support for server-side rendering (SSR). <a href=\"https://github.com/bluwy/create-vite-extra\" target=\"_blank\" rel=\"noreferrer\"><code>create-vite-extra</code></a> contains example SSR setups you can use as references for this guide:</p>\n<ul>\n<li><a href=\"https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vanilla\" target=\"_blank\" rel=\"noreferrer\">Vanilla</a></li>\n<li><a href=\"https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vue\" target=\"_blank\" rel=\"noreferrer\">Vue</a></li>\n<li><a href=\"https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-react\" target=\"_blank\" rel=\"noreferrer\">React</a></li>\n<li><a href=\"https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-preact\" target=\"_blank\" rel=\"noreferrer\">Preact</a></li>\n<li><a href=\"https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-svelte\" target=\"_blank\" rel=\"noreferrer\">Svelte</a></li>\n<li><a href=\"https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-solid\" target=\"_blank\" rel=\"noreferrer\">Solid</a></li>\n</ul>\n<p>You can also scaffold these projects locally by <a href=\"index#scaffolding-your-first-vite-project\">running <code>create-vite</code></a> and choose <code>Others &gt; create-vite-extra</code> under the framework option.</p>\n<h2 id=\"source-structure\" tabindex=\"-1\">Source Structure </h2>\n<p>A typical SSR application will have the following source file structure:</p>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">- index.html\n- server.js # main application server\n- src/\n  - main.js          # exports env-agnostic (universal) app code\n  - entry-client.js  # mounts the app to a DOM element\n  - entry-server.js  # renders the app using the framework's SSR API</pre>\n</div>\n<p>The <code>index.html</code> will need to reference <code>entry-client.js</code> and include a placeholder where the server-rendered markup should be injected:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"index.html\">index.html</span></div>\n<div class=\"language-html\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">&lt;div id=\"app\"&gt;&lt;!--ssr-outlet--&gt;&lt;/div&gt;\n&lt;script type=\"module\" src=\"/src/entry-client.js\"&gt;&lt;/script&gt;</pre>\n</div>\n</div>\n<p>You can use any placeholder you prefer instead of <code>&lt;!--ssr-outlet--&gt;</code>, as long as it can be precisely replaced.</p>\n<h2 id=\"conditional-logic\" tabindex=\"-1\">Conditional Logic </h2>\n<p>If you need to perform conditional logic based on SSR vs. client, you can use</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">if (import.meta.env.SSR) {\n  // ... server only logic\n}</pre>\n</div>\n<p>This is statically replaced during build so it will allow tree-shaking of unused branches.</p>\n<h2 id=\"setting-up-the-dev-server\" tabindex=\"-1\">Setting Up the Dev Server </h2>\n<p>When building an SSR app, you likely want to have full control over your main server and decouple Vite from the production environment. It is therefore recommended to use Vite in middleware mode. Here is an example with <a href=\"https://expressjs.com/\" target=\"_blank\" rel=\"noreferrer\">express</a>:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"server.js\">server.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import fs from 'node:fs'\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport express from 'express'\nimport { createServer as createViteServer } from 'vite'\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\nasync function createServer() {\n  const app = express()\n\n  // Create Vite server in middleware mode and configure the app type as\n  // 'custom', disabling Vite's own HTML serving logic so parent server\n  // can take control\n  const vite = await createViteServer({\n    server: { middlewareMode: true },\n    appType: 'custom'\n  })\n\n  // Use vite's connect instance as middleware. If you use your own\n  // express router (express.Router()), you should use router.use\n  // When the server restarts (for example after the user modifies\n  // vite.config.js), `vite.middlewares` is still going to be the same\n  // reference (with a new internal stack of Vite and plugin-injected\n  // middlewares). The following is valid even after restarts.\n  app.use(vite.middlewares)\n\n  app.use('*all', async (req, res) =&gt; {\n    // serve index.html - we will tackle this next\n  })\n\n  app.listen(5173)\n}\n\ncreateServer()</pre>\n</div>\n</div>\n<p>Here <code>vite</code> is an instance of <a href=\"api-javascript#vitedevserver\">ViteDevServer</a>. <code>vite.middlewares</code> is a <a href=\"https://github.com/senchalabs/connect\" target=\"_blank\" rel=\"noreferrer\">Connect</a> instance which can be used as a middleware in any connect-compatible Node.js framework.</p>\n<p>The next step is implementing the <code>*</code> handler to serve server-rendered HTML:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"server.js\">server.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">app.use('*all', async (req, res, next) =&gt; {\n  const url = req.originalUrl\n\n  try {\n    // 1. Read index.html\n    let template = fs.readFileSync(\n      path.resolve(__dirname, 'index.html'),\n      'utf-8',\n    )\n\n    // 2. Apply Vite HTML transforms. This injects the Vite HMR client,\n    //    and also applies HTML transforms from Vite plugins, e.g. global\n    //    preambles from @vitejs/plugin-react\n    template = await vite.transformIndexHtml(url, template)\n\n    // 3. Load the server entry. ssrLoadModule automatically transforms\n    //    ESM source code to be usable in Node.js! There is no bundling\n    //    required, and provides efficient invalidation similar to HMR.\n    const { render } = await vite.ssrLoadModule('/src/entry-server.js')\n\n    // 4. render the app HTML. This assumes entry-server.js's exported\n    //     `render` function calls appropriate framework SSR APIs,\n    //    e.g. ReactDOMServer.renderToString()\n    const appHtml = await render(url)\n\n    // 5. Inject the app-rendered HTML into the template.\n    const html = template.replace(`&lt;!--ssr-outlet--&gt;`, () =&gt; appHtml)\n\n    // 6. Send the rendered HTML back.\n    res.status(200).set({ 'Content-Type': 'text/html' }).end(html)\n  } catch (e) {\n    // If an error is caught, let Vite fix the stack trace so it maps back\n    // to your actual source code.\n    vite.ssrFixStacktrace(e)\n    next(e)\n  }\n})</pre>\n</div>\n</div>\n<p>The <code>dev</code> script in <code>package.json</code> should also be changed to use the server script instead:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"package.json\">package.json</span></div>\n<div class=\"language-diff\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">\"scripts\": {\n-   \"dev\": \"vite\"\n+   \"dev\": \"node server\"\n  }</pre>\n</div>\n</div>\n<h2 id=\"building-for-production\" tabindex=\"-1\">Building for Production </h2>\n<p>To ship an SSR project for production, we need to:</p>\n<ol>\n<li>Produce a client build as normal;</li>\n<li>Produce an SSR build, which can be directly loaded via <code>import()</code> so that we don't have to go through Vite's <code>ssrLoadModule</code>;</li>\n</ol>\n<p>Our scripts in <code>package.json</code> will look like this:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"package.json\">package.json</span></div>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"scripts\": {\n    \"dev\": \"node server\",\n    \"build:client\": \"vite build --outDir dist/client\",\n    \"build:server\": \"vite build --outDir dist/server --ssr src/entry-server.js\"\n  }\n}</pre>\n</div>\n</div>\n<p>Note the <code>--ssr</code> flag which indicates this is an SSR build. It should also specify the SSR entry.</p>\n<p>Then, in <code>server.js</code> we need to add some production specific logic by checking <code>process.env.NODE_ENV</code>:</p>\n<ul>\n<li><p>Instead of reading the root <code>index.html</code>, use the <code>dist/client/index.html</code> as the template, since it contains the correct asset links to the client build.</p></li>\n<li><p>Instead of <code>await vite.ssrLoadModule('/src/entry-server.js')</code>, use <code>import('./dist/server/entry-server.js')</code> (this file is the result of the SSR build).</p></li>\n<li><p>Move the creation and all usage of the <code>vite</code> dev server behind dev-only conditional branches, then add static file serving middlewares to serve files from <code>dist/client</code>.</p></li>\n</ul>\n<p>Refer to the <a href=\"#example-projects\">example projects</a> for a working setup.</p>\n<h2 id=\"generating-preload-directives\" tabindex=\"-1\">Generating Preload Directives </h2>\n<p><code>vite build</code> supports the <code>--ssrManifest</code> flag which will generate <code>.vite/ssr-manifest.json</code> in build output directory:</p>\n<div class=\"language-diff\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">- \"build:client\": \"vite build --outDir dist/client\",\n+ \"build:client\": \"vite build --outDir dist/client --ssrManifest\",</pre>\n</div>\n<p>The above script will now generate <code>dist/client/.vite/ssr-manifest.json</code> for the client build (Yes, the SSR manifest is generated from the client build because we want to map module IDs to client files). The manifest contains mappings of module IDs to their associated chunks and asset files.</p>\n<p>To leverage the manifest, frameworks need to provide a way to collect the module IDs of the components that were used during a server render call.</p>\n<p><code>@vitejs/plugin-vue</code> supports this out of the box and automatically registers used component module IDs on to the associated Vue SSR context:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"src/entry-server.js\">src/entry-server.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const ctx = {}\nconst html = await vueServerRenderer.renderToString(app, ctx)\n// ctx.modules is now a Set of module IDs that were used during the render</pre>\n</div>\n</div>\n<p>In the production branch of <code>server.js</code> we need to read and pass the manifest to the <code>render</code> function exported by <code>src/entry-server.js</code>. This would provide us with enough information to render preload directives for files used by async routes! See <a href=\"https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/src/entry-server.js\" target=\"_blank\" rel=\"noreferrer\">demo source</a> for a full example. You can also use this information for <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103\" target=\"_blank\" rel=\"noreferrer\">103 Early Hints</a>.</p>\n<h2 id=\"pre-rendering-ssg\" tabindex=\"-1\">Pre-Rendering / SSG </h2>\n<p>If the routes and the data needed for certain routes are known ahead of time, we can pre-render these routes into static HTML using the same logic as production SSR. This can also be considered a form of Static-Site Generation (SSG). See <a href=\"https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/prerender.js\" target=\"_blank\" rel=\"noreferrer\">demo pre-render script</a> for working example.</p>\n<h2 id=\"ssr-externals\" tabindex=\"-1\">SSR Externals </h2>\n<p>Dependencies are \"externalized\" from Vite's SSR transform module system by default when running SSR. This speeds up both dev and build.</p>\n<p>If a dependency needs to be transformed by Vite's pipeline, for example, because Vite features are used untranspiled in them, they can be added to <a href=\"../config/ssr-options#ssr-noexternal\"><code>ssr.noExternal</code></a>.</p>\n<p>For linked dependencies, they are not externalized by default to take advantage of Vite's HMR. If this isn't desired, for example, to test dependencies as if they aren't linked, you can add it to <a href=\"../config/ssr-options#ssr-external\"><code>ssr.external</code></a>.</p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Working with Aliases</strong><p>If you have configured aliases that redirect one package to another, you may want to alias the actual <code>node_modules</code> packages instead to make it work for SSR externalized dependencies. Both <a href=\"https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias\" target=\"_blank\" rel=\"noreferrer\">Yarn</a> and <a href=\"https://pnpm.io/aliases/\" target=\"_blank\" rel=\"noreferrer\">pnpm</a> support aliasing via the <code>npm:</code> prefix.</p>\n</div>\n<h2 id=\"ssr-specific-plugin-logic\" tabindex=\"-1\">SSR-specific Plugin Logic </h2>\n<p>Some frameworks such as Vue or Svelte compile components into different formats based on client vs. SSR. To support conditional transforms, Vite passes an additional <code>ssr</code> property in the <code>options</code> object of the following plugin hooks:</p>\n<ul>\n<li><code>resolveId</code></li>\n<li><code>load</code></li>\n<li><code>transform</code></li>\n</ul>\n<p><strong>Example:</strong></p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">export function mySSRPlugin() {\n  return {\n    name: 'my-ssr',\n    transform(code, id, options) {\n      if (options?.ssr) {\n        // perform ssr-specific transform...\n      }\n    },\n  }\n}</pre>\n</div>\n<p>The options object in <code>load</code> and <code>transform</code> is optional, rollup is not currently using this object but may extend these hooks with additional metadata in the future.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Note</strong><p>Before Vite 2.7, this was informed to plugin hooks with a positional <code>ssr</code> param instead of using the <code>options</code> object. All major frameworks and plugins are updated but you may find outdated posts using the previous API.</p>\n</div>\n<h2 id=\"ssr-target\" tabindex=\"-1\">SSR Target </h2>\n<p>The default target for the SSR build is a node environment, but you can also run the server in a Web Worker. Packages entry resolution is different for each platform. You can configure the target to be Web Worker using the <code>ssr.target</code> set to <code>'webworker'</code>.</p>\n<h2 id=\"ssr-bundle\" tabindex=\"-1\">SSR Bundle </h2>\n<p>In some cases like <code>webworker</code> runtimes, you might want to bundle your SSR build into a single JavaScript file. You can enable this behavior by setting <code>ssr.noExternal</code> to <code>true</code>. This will do two things:</p>\n<ul>\n<li>Treat all dependencies as <code>noExternal</code>\n</li>\n<li>Throw an error if any Node.js built-ins are imported</li>\n</ul>\n<h2 id=\"ssr-resolve-conditions\" tabindex=\"-1\">SSR Resolve Conditions </h2>\n<p>By default package entry resolution will use the conditions set in <a href=\"../config/shared-options#resolve-conditions\"><code>resolve.conditions</code></a> for the SSR build. You can use <a href=\"../config/ssr-options#ssr-resolve-conditions\"><code>ssr.resolve.conditions</code></a> and <a href=\"../config/ssr-options#ssr-resolve-externalconditions\"><code>ssr.resolve.externalConditions</code></a> to customize this behavior.</p>\n<h2 id=\"vite-cli\" tabindex=\"-1\">Vite CLI </h2>\n<p>The CLI commands <code>$ vite dev</code> and <code>$ vite preview</code> can also be used for SSR apps. You can add your SSR middlewares to the development server with <a href=\"api-plugin#configureserver\"><code>configureServer</code></a> and to the preview server with <a href=\"api-plugin#configurepreviewserver\"><code>configurePreviewServer</code></a>.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Note</strong><p>Use a post hook so that your SSR middleware runs <em>after</em> Vite's middlewares.</p>\n</div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/ssr\" class=\"_attribution-link\">https://vite.dev/guide/ssr</a>\n  </p>\n</div>\n","changes/hotupdate-hook":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /changes/hotupdate-hook.md for this page in Markdown format</div>\n<h1 id=\"hmr-hotupdate-plugin-hook\" tabindex=\"-1\">HMR <code>hotUpdate</code> Plugin Hook </h1>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">Feedback</strong><p>Give us feedback at <a href=\"https://github.com/vitejs/vite/discussions/16358\" target=\"_blank\" rel=\"noreferrer\">Environment API feedback discussion</a></p>\n</div>\n<p>We're planning to deprecate the <code>handleHotUpdate</code> plugin hook in favor of <a href=\"../guide/api-environment#the-hotupdate-hook\"><code>hotUpdate</code> hook</a> to be <a href=\"../guide/api-environment\">Environment API</a> aware, and handle additional watch events with <code>create</code> and <code>delete</code>.</p>\n<p>Affected scope: <code>Vite Plugin Authors</code></p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\">Future Deprecation</strong><p><code>hotUpdate</code> was first introduced in <code>v6.0</code>. The deprecation of <code>handleHotUpdate</code> is planned for a future major. We don't recommend moving away from <code>handleHotUpdate</code> yet. If you want to experiment and give us feedback, you can use the <code>future.removePluginHookHandleHotUpdate</code> to <code>\"warn\"</code> in your vite config.</p>\n</div>\n<h2 id=\"motivation\" tabindex=\"-1\">Motivation </h2>\n<p>The <a href=\"../guide/api-plugin#handlehotupdate\"><code>handleHotUpdate</code> hook</a> allows to perform custom HMR update handling. A list of modules to be updated is passed in the <code>HmrContext</code>.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface HmrContext {\n  file: string\n  timestamp: number\n  modules: Array&lt;ModuleNode&gt;\n  read: () =&gt; string | Promise&lt;string&gt;\n  server: ViteDevServer\n}</pre>\n</div>\n<p>This hook is called once for all environments, and the passed modules have mixed information from the Client and SSR environments only. Once frameworks move to custom environments, a new hook that is called for each of them is needed.</p>\n<p>The new <code>hotUpdate</code> hook works in the same way as <code>handleHotUpdate</code> but it is called for each environment and receives a new <code>HotUpdateOptions</code> instance:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">interface HotUpdateOptions {\n  type: 'create' | 'update' | 'delete'\n  file: string\n  timestamp: number\n  modules: Array&lt;EnvironmentModuleNode&gt;\n  read: () =&gt; string | Promise&lt;string&gt;\n  server: ViteDevServer\n}</pre>\n</div>\n<p>The current dev environment can be accessed like in other Plugin hooks with <code>this.environment</code>. The <code>modules</code> list will now be module nodes from the current environment only. Each environment update can define different update strategies.</p>\n<p>This hook is also now called for additional watch events and not only for <code>'update'</code>. Use <code>type</code> to differentiate between them.</p>\n<h2 id=\"migration-guide\" tabindex=\"-1\">Migration Guide </h2>\n<p>Filter and narrow down the affected module list so that the HMR is more accurate.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">handleHotUpdate({ modules }) {\n  return modules.filter(condition)\n}\n\n// Migrate to:\n\nhotUpdate({ modules }) {\n  return modules.filter(condition)\n}</pre>\n</div>\n<p>Return an empty array and perform a full reload:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">handleHotUpdate({ server, modules, timestamp }) {\n  // Invalidate modules manually\n  const invalidatedModules = new Set()\n  for (const mod of modules) {\n    server.moduleGraph.invalidateModule(\n      mod,\n      invalidatedModules,\n      timestamp,\n      true\n    )\n  }\n  server.ws.send({ type: 'full-reload' })\n  return []\n}\n\n// Migrate to:\n\nhotUpdate({ modules, timestamp }) {\n  // Invalidate modules manually\n  const invalidatedModules = new Set()\n  for (const mod of modules) {\n    this.environment.moduleGraph.invalidateModule(\n      mod,\n      invalidatedModules,\n      timestamp,\n      true\n    )\n  }\n  this.environment.hot.send({ type: 'full-reload' })\n  return []\n}</pre>\n</div>\n<p>Return an empty array and perform complete custom HMR handling by sending custom events to the client:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">handleHotUpdate({ server }) {\n  server.ws.send({\n    type: 'custom',\n    event: 'special-update',\n    data: {}\n  })\n  return []\n}\n\n// Migrate to...\n\nhotUpdate() {\n  this.environment.hot.send({\n    type: 'custom',\n    event: 'special-update',\n    data: {}\n  })\n  return []\n}</pre>\n</div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/changes/hotupdate-hook\" class=\"_attribution-link\">https://vite.dev/changes/hotupdate-hook</a>\n  </p>\n</div>\n","guide/features":"<div style=\"display:none;\" hidden=\"true\" aria-hidden=\"true\">Are you an LLM? You can read better optimized documentation at /guide/features.md for this page in Markdown format</div>\n<h1 id=\"features\" tabindex=\"-1\">Features </h1>\n<p>At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.</p>\n<h2 id=\"npm-dependency-resolving-and-pre-bundling\" tabindex=\"-1\">npm Dependency Resolving and Pre-Bundling </h2>\n<p>Native ES imports do not support bare module imports like the following:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { someMethod } from 'my-dep'</pre>\n</div>\n<p>The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:</p>\n<ol>\n<li><p><a href=\"dep-pre-bundling\">Pre-bundle</a> them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with <a href=\"http://esbuild.github.io/\" target=\"_blank\" rel=\"noreferrer\">esbuild</a> and makes Vite's cold start time significantly faster than any JavaScript-based bundler.</p></li>\n<li><p>Rewrite the imports to valid URLs like <code>/node_modules/.vite/deps/my-dep.js?v=f3sf2ebd</code> so that the browser can import them properly.</p></li>\n</ol>\n<p><strong>Dependencies are Strongly Cached</strong></p>\n<p>Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps <a href=\"dep-pre-bundling#browser-cache\">here</a>.</p>\n<h2 id=\"hot-module-replacement\" tabindex=\"-1\">Hot Module Replacement </h2>\n<p>Vite provides an <a href=\"api-hmr\">HMR API</a> over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for <a href=\"https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue\" target=\"_blank\" rel=\"noreferrer\">Vue Single File Components</a> and <a href=\"https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react\" target=\"_blank\" rel=\"noreferrer\">React Fast Refresh</a>. There are also official integrations for Preact via <a href=\"https://github.com/JoviDeCroock/prefresh/tree/main/packages/vite\" target=\"_blank\" rel=\"noreferrer\">@prefresh/vite</a>.</p>\n<p>Note you don't need to manually set these up - when you <a href=\"index\">create an app via <code>create-vite</code></a>, the selected templates would have these pre-configured for you already.</p>\n<h2 id=\"typescript\" tabindex=\"-1\">TypeScript </h2>\n<p>Vite supports importing <code>.ts</code> files out of the box.</p>\n<h3 id=\"transpile-only\" tabindex=\"-1\">Transpile Only </h3>\n<p>Note that Vite only performs transpilation on <code>.ts</code> files and does <strong>NOT</strong> perform type checking. It assumes type checking is taken care of by your IDE and build process.</p>\n<p>The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.</p>\n<p>Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.</p>\n<ul>\n<li><p>For production builds, you can run <code>tsc --noEmit</code> in addition to Vite's build command.</p></li>\n<li><p>During development, if you need more than IDE hints, we recommend running <code>tsc --noEmit --watch</code> in a separate process, or use <a href=\"https://github.com/fi3ework/vite-plugin-checker\" target=\"_blank\" rel=\"noreferrer\">vite-plugin-checker</a> if you prefer having type errors directly reported in the browser.</p></li>\n</ul>\n<p>Vite uses <a href=\"https://github.com/evanw/esbuild\" target=\"_blank\" rel=\"noreferrer\">esbuild</a> to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla <code>tsc</code>, and HMR updates can reflect in the browser in under 50ms.</p>\n<p>Use the <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export\" target=\"_blank\" rel=\"noreferrer\">Type-Only Imports and Export</a> syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import type { T } from 'only/types'\nexport type { T }</pre>\n</div>\n<h3 id=\"typescript-compiler-options\" tabindex=\"-1\">TypeScript Compiler Options </h3>\n<p>Some configuration fields under <code>compilerOptions</code> in <code>tsconfig.json</code> require special attention.</p>\n<h4 id=\"isolatedmodules\" tabindex=\"-1\">\n<code>isolatedModules</code> </h4>\n<ul><li><a href=\"https://www.typescriptlang.org/tsconfig#isolatedModules\" target=\"_blank\" rel=\"noreferrer\">TypeScript documentation</a></li></ul>\n<p>Should be set to <code>true</code>.</p>\n<p>It is because <code>esbuild</code> only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.</p>\n<p>You must set <code>\"isolatedModules\": true</code> in your <code>tsconfig.json</code> under <code>compilerOptions</code>, so that TS will warn you against the features that do not work with isolated transpilation.</p>\n<p>If a dependency doesn't work well with <code>\"isolatedModules\": true</code>. You can use <code>\"skipLibCheck\": true</code> to temporarily suppress the errors until it is fixed upstream.</p>\n<h4 id=\"usedefineforclassfields\" tabindex=\"-1\">\n<code>useDefineForClassFields</code> </h4>\n<ul><li><a href=\"https://www.typescriptlang.org/tsconfig#useDefineForClassFields\" target=\"_blank\" rel=\"noreferrer\">TypeScript documentation</a></li></ul>\n<p>The default value will be <code>true</code> if the TypeScript target is <code>ES2022</code> or newer including <code>ESNext</code>. It is consistent with the <a href=\"https://github.com/microsoft/TypeScript/pull/42663\" target=\"_blank\" rel=\"noreferrer\">behavior of TypeScript 4.3.2+</a>. Other TypeScript targets will default to <code>false</code>.</p>\n<p><code>true</code> is the standard ECMAScript runtime behavior.</p>\n<p>If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it. While most libraries expect <code>\"useDefineForClassFields\": true</code>, you can explicitly set <code>useDefineForClassFields</code> to <code>false</code> if your library doesn't support it.</p>\n<h4 id=\"target\" tabindex=\"-1\">\n<code>target</code> </h4>\n<ul><li><a href=\"https://www.typescriptlang.org/tsconfig#target\" target=\"_blank\" rel=\"noreferrer\">TypeScript documentation</a></li></ul>\n<p>Vite ignores the <code>target</code> value in the <code>tsconfig.json</code>, following the same behavior as <code>esbuild</code>.</p>\n<p>To specify the target in dev, the <a href=\"../config/shared-options#esbuild\"><code>esbuild.target</code></a> option can be used, which defaults to <code>esnext</code> for minimal transpilation. In builds, the <a href=\"../config/build-options#build-target\"><code>build.target</code></a> option takes higher priority over <code>esbuild.target</code> and can also be set if needed.</p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title\"><code>useDefineForClassFields</code></strong><p>If <code>target</code> in <code>tsconfig.json</code> is not <code>ESNext</code> or <code>ES2022</code> or newer, or if there's no <code>tsconfig.json</code> file, <code>useDefineForClassFields</code> will default to <code>false</code> which can be problematic with the default <code>esbuild.target</code> value of <code>esnext</code>. It may transpile to <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility\" target=\"_blank\" rel=\"noreferrer\">static initialization blocks</a> which may not be supported in your browser.</p>\n<p>As such, it is recommended to set <code>target</code> to <code>ESNext</code> or <code>ES2022</code> or newer, or set <code>useDefineForClassFields</code> to <code>true</code> explicitly when configuring <code>tsconfig.json</code>.</p>\n</div>\n<h4 id=\"other-compiler-options-affecting-the-build-result\" tabindex=\"-1\">Other Compiler Options Affecting the Build Result </h4>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#extends\" target=\"_blank\" rel=\"noreferrer\"><code>extends</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues\" target=\"_blank\" rel=\"noreferrer\"><code>importsNotUsedAsValues</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#preserveValueImports\" target=\"_blank\" rel=\"noreferrer\"><code>preserveValueImports</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax\" target=\"_blank\" rel=\"noreferrer\"><code>verbatimModuleSyntax</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#jsx\" target=\"_blank\" rel=\"noreferrer\"><code>jsx</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#jsxFactory\" target=\"_blank\" rel=\"noreferrer\"><code>jsxFactory</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#jsxFragmentFactory\" target=\"_blank\" rel=\"noreferrer\"><code>jsxFragmentFactory</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#jsxImportSource\" target=\"_blank\" rel=\"noreferrer\"><code>jsxImportSource</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#experimentalDecorators\" target=\"_blank\" rel=\"noreferrer\"><code>experimentalDecorators</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#alwaysStrict\" target=\"_blank\" rel=\"noreferrer\"><code>alwaysStrict</code></a></li>\n</ul>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\"><code>skipLibCheck</code></strong><p>Vite starter templates have <code>\"skipLibCheck\": \"true\"</code> by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at <a href=\"https://github.com/vuejs/vue-cli/pull/5688\" target=\"_blank\" rel=\"noreferrer\">vuejs/vue-cli#5688</a>.</p>\n</div>\n<h3 id=\"client-types\" tabindex=\"-1\">Client Types </h3>\n<p>Vite's default types are for its Node.js API. To shim the environment of client-side code in a Vite application, add a <code>d.ts</code> declaration file:</p>\n<div class=\"language-typescript\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">/// &lt;reference types=\"vite/client\" /&gt;</pre>\n</div>\n<div class=\"details custom-block\">\n<summary>Using <code>compilerOptions.types</code></summary><p>Alternatively, you can add <code>vite/client</code> to <code>compilerOptions.types</code> inside <code>tsconfig.json</code>:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"tsconfig.json\">tsconfig.json</span></div>\n<div class=\"language-json\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">{\n  \"compilerOptions\": {\n    \"types\": [\"vite/client\", \"some-other-global-lib\"]\n  }\n}</pre>\n</div>\n</div>\n<p>Note that if <a href=\"https://www.typescriptlang.org/tsconfig#types\" target=\"_blank\" rel=\"noreferrer\"><code>compilerOptions.types</code></a> is specified, only these packages will be included in the global scope (instead of all visible ”@types” packages).</p>\n</div>\n<p><code>vite/client</code> provides the following type shims:</p>\n<ul>\n<li>Asset imports (e.g. importing an <code>.svg</code> file)</li>\n<li>Types for the Vite-injected <a href=\"env-and-mode#env-variables\">constants</a> on <code>import.meta.env</code>\n</li>\n<li>Types for the <a href=\"api-hmr\">HMR API</a> on <code>import.meta.hot</code>\n</li>\n</ul>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">TIP</strong><p>To override the default typing, add a type definition file that contains your typings. Then, add the type reference before <code>vite/client</code>.</p>\n<p>For example, to make the default import of <code>*.svg</code> a React component:</p>\n<ul>\n<li>\n<code>vite-env-override.d.ts</code> (the file that contains your typings):<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">declare module '*.svg' {\n  const content: React.FC&lt;React.SVGProps&lt;SVGElement&gt;&gt;\n  export default content\n}</pre>\n</div>\n</li>\n<li>The file containing the reference to <code>vite/client</code> (normally <code>vite-env.d.ts</code>):<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">/// &lt;reference types=\"./vite-env-override.d.ts\" /&gt;\n/// &lt;reference types=\"vite/client\" /&gt;</pre>\n</div>\n</li>\n</ul>\n</div>\n<h2 id=\"html\" tabindex=\"-1\">HTML </h2>\n<p>HTML files stand <a href=\"index#index-html-and-project-root\">front-and-center</a> of a Vite project, serving as the entry points for your application, making it simple to build single-page and <a href=\"build#multi-page-app\">multi-page applications</a>.</p>\n<p>Any HTML files in your project root can be directly accessed by its respective directory path:</p>\n<ul>\n<li>\n<code>&lt;root&gt;/index.html</code> -&gt; <code>http://localhost:5173/</code>\n</li>\n<li>\n<code>&lt;root&gt;/about.html</code> -&gt; <code>http://localhost:5173/about.html</code>\n</li>\n<li>\n<code>&lt;root&gt;/blog/index.html</code> -&gt; <code>http://localhost:5173/blog/index.html</code>\n</li>\n</ul>\n<p>Assets referenced by HTML elements such as <code>&lt;script type=\"module\" src&gt;</code> and <code>&lt;link href&gt;</code> are processed and bundled as part of the app. The full list of supported elements are as below:</p>\n<ul>\n<li><code>&lt;audio src&gt;</code></li>\n<li><code>&lt;embed src&gt;</code></li>\n<li>\n<code>&lt;img src&gt;</code> and <code>&lt;img srcset&gt;</code>\n</li>\n<li>\n<code>&lt;image href&gt;</code> and <code>&lt;image xlink:href&gt;</code>\n</li>\n<li><code>&lt;input src&gt;</code></li>\n<li>\n<code>&lt;link href&gt;</code> and <code>&lt;link imagesrcset&gt;</code>\n</li>\n<li><code>&lt;object data&gt;</code></li>\n<li><code>&lt;script type=\"module\" src&gt;</code></li>\n<li>\n<code>&lt;source src&gt;</code> and <code>&lt;source srcset&gt;</code>\n</li>\n<li><code>&lt;track src&gt;</code></li>\n<li>\n<code>&lt;use href&gt;</code> and <code>&lt;use xlink:href&gt;</code>\n</li>\n<li>\n<code>&lt;video src&gt;</code> and <code>&lt;video poster&gt;</code>\n</li>\n<li>\n<code>&lt;meta content&gt;</code><ul>\n<li>Only if <code>name</code> attribute matches <code>msapplication-tileimage</code>, <code>msapplication-square70x70logo</code>, <code>msapplication-square150x150logo</code>, <code>msapplication-wide310x150logo</code>, <code>msapplication-square310x310logo</code>, <code>msapplication-config</code>, or <code>twitter:image</code>\n</li>\n<li>Or only if <code>property</code> attribute matches <code>og:image</code>, <code>og:image:url</code>, <code>og:image:secure_url</code>, <code>og:audio</code>, <code>og:audio:secure_url</code>, <code>og:video</code>, or <code>og:video:secure_url</code>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-html\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;link rel=\"icon\" href=\"/favicon.ico\" /&gt;\n    &lt;link rel=\"stylesheet\" href=\"/src/styles.css\" /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"/src/images/logo.svg\" alt=\"logo\" /&gt;\n    &lt;script type=\"module\" src=\"/src/main.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n</div>\n<p>To opt-out of HTML processing on certain elements, you can add the <code>vite-ignore</code> attribute on the element, which can be useful when referencing external assets or CDN.</p>\n<h2 id=\"frameworks\" tabindex=\"-1\">Frameworks </h2>\n<p>All modern frameworks maintain integrations with Vite. Most framework plugins are maintained by each framework team, with the exception of the official Vue and React Vite plugins that are maintained in the vite org:</p>\n<ul>\n<li>Vue support via <a href=\"https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue\" target=\"_blank\" rel=\"noreferrer\">@vitejs/plugin-vue</a>\n</li>\n<li>Vue JSX support via <a href=\"https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx\" target=\"_blank\" rel=\"noreferrer\">@vitejs/plugin-vue-jsx</a>\n</li>\n<li>React support via <a href=\"https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react\" target=\"_blank\" rel=\"noreferrer\">@vitejs/plugin-react</a>\n</li>\n<li>React using SWC support via <a href=\"https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react-swc\" target=\"_blank\" rel=\"noreferrer\">@vitejs/plugin-react-swc</a>\n</li>\n</ul>\n<p>Check out the <a href=\"https://vite.dev/plugins\" target=\"_blank\" rel=\"noreferrer\">Plugins Guide</a> for more information.</p>\n<h2 id=\"jsx\" tabindex=\"-1\">JSX </h2>\n<p><code>.jsx</code> and <code>.tsx</code> files are also supported out of the box. JSX transpilation is also handled via <a href=\"https://esbuild.github.io\" target=\"_blank\" rel=\"noreferrer\">esbuild</a>.</p>\n<p>Your framework of choice will already configure JSX out of the box (for example, Vue users should use the official <a href=\"https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx\" target=\"_blank\" rel=\"noreferrer\">@vitejs/plugin-vue-jsx</a> plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots).</p>\n<p>If using JSX with your own framework, custom <code>jsxFactory</code> and <code>jsxFragment</code> can be configured using the <a href=\"../config/shared-options#esbuild\"><code>esbuild</code> option</a>. For example, the Preact plugin would use:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { defineConfig } from 'vite'\n\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n  },\n})</pre>\n</div>\n</div>\n<p>More details in <a href=\"https://esbuild.github.io/content-types/#jsx\" target=\"_blank\" rel=\"noreferrer\">esbuild docs</a>.</p>\n<p>You can inject the JSX helpers using <code>jsxInject</code> (which is a Vite-only option) to avoid manual imports:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"vite.config.js\">vite.config.js</span></div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import { defineConfig } from 'vite'\n\nexport default defineConfig({\n  esbuild: {\n    jsxInject: `import React from 'react'`,\n  },\n})</pre>\n</div>\n</div>\n<h2 id=\"css\" tabindex=\"-1\">CSS </h2>\n<p>Importing <code>.css</code> files will inject its content to the page via a <code>&lt;style&gt;</code> tag with HMR support.</p>\n<h3 id=\"import-inlining-and-rebasing\" tabindex=\"-1\">\n<code>@import</code> Inlining and Rebasing </h3>\n<p>Vite is pre-configured to support CSS <code>@import</code> inlining via <code>postcss-import</code>. Vite aliases are also respected for CSS <code>@import</code>. In addition, all CSS <code>url()</code> references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.</p>\n<p><code>@import</code> aliases and URL rebasing are also supported for Sass and Less files (see <a href=\"#css-pre-processors\">CSS Pre-processors</a>).</p>\n<h3 id=\"postcss\" tabindex=\"-1\">PostCSS </h3>\n<p>If the project contains valid PostCSS config (any format supported by <a href=\"https://github.com/postcss/postcss-load-config\" target=\"_blank\" rel=\"noreferrer\">postcss-load-config</a>, e.g. <code>postcss.config.js</code>), it will be automatically applied to all imported CSS.</p>\n<p>Note that CSS minification will run after PostCSS and will use <a href=\"../config/build-options#build-csstarget\"><code>build.cssTarget</code></a> option.</p>\n<h3 id=\"css-modules\" tabindex=\"-1\">CSS Modules </h3>\n<p>Any CSS file ending with <code>.module.css</code> is considered a <a href=\"https://github.com/css-modules/css-modules\" target=\"_blank\" rel=\"noreferrer\">CSS modules file</a>. Importing such a file will return the corresponding module object:</p>\n<div class=\"vp-code-block-title\">\n<div class=\"vp-code-block-title-bar\"><span class=\"vp-code-block-title-text\" data-title=\"example.module.css\">example.module.css</span></div>\n<div class=\"language-css\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">.red {\n  color: red;\n}</pre>\n</div>\n</div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import classes from './example.module.css'\ndocument.getElementById('foo').className = classes.red</pre>\n</div>\n<p>CSS modules behavior can be configured via the <a href=\"../config/shared-options#css-modules\"><code>css.modules</code> option</a>.</p>\n<p>If <code>css.modules.localsConvention</code> is set to enable camelCase locals (e.g. <code>localsConvention: 'camelCaseOnly'</code>), you can also use named imports:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// .apply-color -&gt; applyColor\nimport { applyColor } from './example.module.css'\ndocument.getElementById('foo').className = applyColor</pre>\n</div>\n<h3 id=\"css-pre-processors\" tabindex=\"-1\">CSS Pre-processors </h3>\n<p>Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. <a href=\"https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nesting\" target=\"_blank\" rel=\"noreferrer\">postcss-nesting</a>) and author plain, future-standards-compliant CSS.</p>\n<p>That said, Vite does provide built-in support for <code>.scss</code>, <code>.sass</code>, <code>.less</code>, <code>.styl</code> and <code>.stylus</code> files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:</p>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\"># .scss and .sass\nnpm add -D sass-embedded # or sass\n\n# .less\nnpm add -D less\n\n# .styl and .stylus\nnpm add -D stylus</pre>\n</div>\n<p>If using Vue single file components, this also automatically enables <code>&lt;style lang=\"sass\"&gt;</code> et al.</p>\n<p>Vite improves <code>@import</code> resolving for Sass and Less so that Vite aliases are also respected. In addition, relative <code>url()</code> references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness. Rebasing <code>url()</code> references that starts with a variable or a interpolation are not supported due to its API constraints.</p>\n<p><code>@import</code> alias and url rebasing are not supported for Stylus due to its API constraints.</p>\n<p>You can also use CSS modules combined with pre-processors by prepending <code>.module</code> to the file extension, for example <code>style.module.scss</code>.</p>\n<h3 id=\"disabling-css-injection-into-the-page\" tabindex=\"-1\">Disabling CSS injection into the page </h3>\n<p>The automatic injection of CSS contents can be turned off via the <code>?inline</code> query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import './foo.css' // will be injected into the page\nimport otherStyles from './bar.css?inline' // will not be injected</pre>\n</div>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p>Default and named imports from CSS files (e.g <code>import style from './foo.css'</code>) are removed since Vite 5. Use the <code>?inline</code> query instead.</p>\n</div>\n<h3 id=\"lightning-css\" tabindex=\"-1\">Lightning CSS </h3>\n<p>Starting from Vite 4.4, there is experimental support for <a href=\"https://lightningcss.dev/\" target=\"_blank\" rel=\"noreferrer\">Lightning CSS</a>. You can opt into it by adding <a href=\"../config/shared-options#css-transformer\"><code>css.transformer: 'lightningcss'</code></a> to your config file and install the optional <a href=\"https://www.npmjs.com/package/lightningcss\" target=\"_blank\" rel=\"noreferrer\"><code>lightningcss</code></a> dependency:</p>\n<div class=\"language-bash\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">npm add -D lightningcss</pre>\n</div>\n<p>If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the <a href=\"../config/shared-options#css-lightningcss\"><code>css.lightningcss</code></a> config option.</p>\n<p>To configure CSS Modules, you'll use <a href=\"https://lightningcss.dev/css-modules.html\" target=\"_blank\" rel=\"noreferrer\"><code>css.lightningcss.cssModules</code></a> instead of <a href=\"../config/shared-options#css-modules\"><code>css.modules</code></a> (which configures the way PostCSS handles CSS modules).</p>\n<p>By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with <a href=\"../config/build-options#build-cssminify\"><code>build.cssMinify: 'lightningcss'</code></a>.</p>\n<h2 id=\"static-assets\" tabindex=\"-1\">Static Assets </h2>\n<p>Importing a static asset will return the resolved public URL when it is served:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import imgUrl from './img.png'\ndocument.getElementById('hero-img').src = imgUrl</pre>\n</div>\n<p>Special queries can modify how assets are loaded:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// Explicitly load assets as URL (automatically inlined depending on the file size)\nimport assetAsURL from './asset.js?url'</pre>\n</div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// Load assets as strings\nimport assetAsString from './shader.glsl?raw'</pre>\n</div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// Load Web Workers\nimport Worker from './worker.js?worker'</pre>\n</div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// Web Workers inlined as base64 strings at build time\nimport InlineWorker from './worker.js?worker&amp;inline'</pre>\n</div>\n<p>More details in <a href=\"assets\">Static Asset Handling</a>.</p>\n<h2 id=\"json\" tabindex=\"-1\">JSON </h2>\n<p>JSON files can be directly imported - named imports are also supported:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// import the entire object\nimport json from './example.json'\n// import a root field as named exports - helps with tree-shaking!\nimport { field } from './example.json'</pre>\n</div>\n<h2 id=\"glob-import\" tabindex=\"-1\">Glob Import </h2>\n<p>Vite supports importing multiple modules from the file system via the special <code>import.meta.glob</code> function:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const modules = import.meta.glob('./dir/*.js')</pre>\n</div>\n<p>The above will be transformed into the following:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// code produced by vite\nconst modules = {\n  './dir/bar.js': () =&gt; import('./dir/bar.js'),\n  './dir/foo.js': () =&gt; import('./dir/foo.js'),\n}</pre>\n</div>\n<p>You can then iterate over the keys of the <code>modules</code> object to access the corresponding modules:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">for (const path in modules) {\n  modules[path]().then((mod) =&gt; {\n    console.log(path, mod)\n  })\n}</pre>\n</div>\n<p>Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass <code>{ eager: true }</code> as the second argument:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const modules = import.meta.glob('./dir/*.js', { eager: true })</pre>\n</div>\n<p>The above will be transformed into the following:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// code produced by vite\nimport * as __vite_glob_0_0 from './dir/bar.js'\nimport * as __vite_glob_0_1 from './dir/foo.js'\nconst modules = {\n  './dir/bar.js': __vite_glob_0_0,\n  './dir/foo.js': __vite_glob_0_1,\n}</pre>\n</div>\n<h3 id=\"multiple-patterns\" tabindex=\"-1\">Multiple Patterns </h3>\n<p>The first argument can be an array of globs, for example</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const modules = import.meta.glob(['./dir/*.js', './another/*.js'])</pre>\n</div>\n<h3 id=\"negative-patterns\" tabindex=\"-1\">Negative Patterns </h3>\n<p>Negative glob patterns are also supported (prefixed with <code>!</code>). To ignore some files from the result, you can add exclude glob patterns to the first argument:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const modules = import.meta.glob(['./dir/*.js', '!**/bar.js'])</pre>\n</div>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// code produced by vite\nconst modules = {\n  './dir/foo.js': () =&gt; import('./dir/foo.js'),\n}</pre>\n</div>\n<h4 id=\"named-imports\" tabindex=\"-1\">Named Imports </h4>\n<p>It's possible to only import parts of the modules with the <code>import</code> options.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const modules = import.meta.glob('./dir/*.js', { import: 'setup' })</pre>\n</div>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// code produced by vite\nconst modules = {\n  './dir/bar.js': () =&gt; import('./dir/bar.js').then((m) =&gt; m.setup),\n  './dir/foo.js': () =&gt; import('./dir/foo.js').then((m) =&gt; m.setup),\n}</pre>\n</div>\n<p>When combined with <code>eager</code> it's even possible to have tree-shaking enabled for those modules.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const modules = import.meta.glob('./dir/*.js', {\n  import: 'setup',\n  eager: true,\n})</pre>\n</div>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// code produced by vite:\nimport { setup as __vite_glob_0_0 } from './dir/bar.js'\nimport { setup as __vite_glob_0_1 } from './dir/foo.js'\nconst modules = {\n  './dir/bar.js': __vite_glob_0_0,\n  './dir/foo.js': __vite_glob_0_1,\n}</pre>\n</div>\n<p>Set <code>import</code> to <code>default</code> to import the default export.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const modules = import.meta.glob('./dir/*.js', {\n  import: 'default',\n  eager: true,\n})</pre>\n</div>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// code produced by vite:\nimport { default as __vite_glob_0_0 } from './dir/bar.js'\nimport { default as __vite_glob_0_1 } from './dir/foo.js'\nconst modules = {\n  './dir/bar.js': __vite_glob_0_0,\n  './dir/foo.js': __vite_glob_0_1,\n}</pre>\n</div>\n<h4 id=\"custom-queries\" tabindex=\"-1\">Custom Queries </h4>\n<p>You can also use the <code>query</code> option to provide queries to imports, for example, to import assets <a href=\"assets#importing-asset-as-string\" rel=\"noreferrer\" target=\"_blank\">as a string</a> or <a href=\"assets#importing-asset-as-url\" rel=\"noreferrer\" target=\"_blank\">as a url</a>:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const moduleStrings = import.meta.glob('./dir/*.svg', {\n  query: '?raw',\n  import: 'default',\n})\nconst moduleUrls = import.meta.glob('./dir/*.svg', {\n  query: '?url',\n  import: 'default',\n})</pre>\n</div>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// code produced by vite:\nconst moduleStrings = {\n  './dir/bar.svg': () =&gt; import('./dir/bar.svg?raw').then((m) =&gt; m['default']),\n  './dir/foo.svg': () =&gt; import('./dir/foo.svg?raw').then((m) =&gt; m['default']),\n}\nconst moduleUrls = {\n  './dir/bar.svg': () =&gt; import('./dir/bar.svg?url').then((m) =&gt; m['default']),\n  './dir/foo.svg': () =&gt; import('./dir/foo.svg?url').then((m) =&gt; m['default']),\n}</pre>\n</div>\n<p>You can also provide custom queries for other plugins to consume:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const modules = import.meta.glob('./dir/*.js', {\n  query: { foo: 'bar', bar: true },\n})</pre>\n</div>\n<h4 id=\"base-path\" tabindex=\"-1\">Base Path </h4>\n<p>You can also use the <code>base</code> option to provide base path for the imports:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const modulesWithBase = import.meta.glob('./**/*.js', {\n  base: './base',\n})</pre>\n</div>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">// code produced by vite:\nconst modulesWithBase = {\n  './dir/foo.js': () =&gt; import('./base/dir/foo.js'),\n  './dir/bar.js': () =&gt; import('./base/dir/bar.js'),\n}</pre>\n</div>\n<p>The base option can only be a directory path relative to the importer file or absolute against the project root. Aliases and virtual modules aren't supported.</p>\n<p>Only the globs that are relative paths are interpreted as relative to the resolved base.</p>\n<p>All the resulting module keys are modified to be relative to the base if provided.</p>\n<h3 id=\"glob-import-caveats\" tabindex=\"-1\">Glob Import Caveats </h3>\n<p>Note that:</p>\n<ul>\n<li>This is a Vite-only feature and is not a web or ES standard.</li>\n<li>The glob patterns are treated like import specifiers: they must be either relative (start with <code>./</code>) or absolute (start with <code>/</code>, resolved relative to project root) or an alias path (see <a href=\"../config/shared-options#resolve-alias\"><code>resolve.alias</code> option</a>).</li>\n<li>The glob matching is done via <a href=\"https://github.com/SuperchupuDev/tinyglobby\" target=\"_blank\" rel=\"noreferrer\"><code>tinyglobby</code></a>.</li>\n<li>You should also be aware that all the arguments in the <code>import.meta.glob</code> must be <strong>passed as literals</strong>. You can NOT use variables or expressions in them.</li>\n</ul>\n<h2 id=\"dynamic-import\" tabindex=\"-1\">Dynamic Import </h2>\n<p>Similar to <a href=\"#glob-import\">glob import</a>, Vite also supports dynamic import with variables.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const module = await import(`./dir/${file}.js`)</pre>\n</div>\n<p>Note that variables only represent file names one level deep. If <code>file</code> is <code>'foo/bar'</code>, the import would fail. For more advanced usage, you can use the <a href=\"#glob-import\">glob import</a> feature.</p>\n<h2 id=\"webassembly\" tabindex=\"-1\">WebAssembly </h2>\n<p>Pre-compiled <code>.wasm</code> files can be imported with <code>?init</code>. The default export will be an initialization function that returns a Promise of the <a href=\"https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Instance\" target=\"_blank\" rel=\"noreferrer\"><code>WebAssembly.Instance</code></a>:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import init from './example.wasm?init'\n\ninit().then((instance) =&gt; {\n  instance.exports.test()\n})</pre>\n</div>\n<p>The init function can also take an importObject which is passed along to <a href=\"https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiate\" target=\"_blank\" rel=\"noreferrer\"><code>WebAssembly.instantiate</code></a> as its second argument:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">init({\n  imports: {\n    someFunc: () =&gt; {\n      /* ... */\n    },\n  },\n}).then(() =&gt; {\n  /* ... */\n})</pre>\n</div>\n<p>In the production build, <code>.wasm</code> files smaller than <code>assetInlineLimit</code> will be inlined as base64 strings. Otherwise, they will be treated as a <a href=\"assets\">static asset</a> and fetched on-demand.</p>\n<div class=\"tip custom-block\">\n<strong class=\"custom-block-title\">NOTE</strong><p><a href=\"https://github.com/WebAssembly/esm-integration\" target=\"_blank\" rel=\"noreferrer\">ES Module Integration Proposal for WebAssembly</a> is not currently supported. Use <a href=\"https://github.com/Menci/vite-plugin-wasm\" target=\"_blank\" rel=\"noreferrer\"><code>vite-plugin-wasm</code></a> or other community plugins to handle this.</p>\n</div>\n<h3 id=\"accessing-the-webassembly-module\" tabindex=\"-1\">Accessing the WebAssembly Module </h3>\n<p>If you need access to the <code>Module</code> object, e.g. to instantiate it multiple times, use an <a href=\"assets#explicit-url-imports\">explicit URL import</a> to resolve the asset, and then perform the instantiation:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import wasmUrl from 'foo.wasm?url'\n\nconst main = async () =&gt; {\n  const responsePromise = fetch(wasmUrl)\n  const { module, instance } =\n    await WebAssembly.instantiateStreaming(responsePromise)\n  /* ... */\n}\n\nmain()</pre>\n</div>\n<h3 id=\"fetching-the-module-in-node-js\" tabindex=\"-1\">Fetching the module in Node.js </h3>\n<p>In SSR, the <code>fetch()</code> happening as part of the <code>?init</code> import, may fail with <code>TypeError: Invalid URL</code>. See the issue <a href=\"https://github.com/vitejs/vite/issues/8882\" target=\"_blank\" rel=\"noreferrer\">Support wasm in SSR</a>.</p>\n<p>Here is an alternative, assuming the project base is the current directory:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import wasmUrl from 'foo.wasm?url'\nimport { readFile } from 'node:fs/promises'\n\nconst main = async () =&gt; {\n  const resolvedUrl = (await import('./test/boot.test.wasm?url')).default\n  const buffer = await readFile('.' + resolvedUrl)\n  const { instance } = await WebAssembly.instantiate(buffer, {\n    /* ... */\n  })\n  /* ... */\n}\n\nmain()</pre>\n</div>\n<h2 id=\"web-workers\" tabindex=\"-1\">Web Workers </h2>\n<h3 id=\"import-with-constructors\" tabindex=\"-1\">Import with Constructors </h3>\n<p>A web worker script can be imported using <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker\" target=\"_blank\" rel=\"noreferrer\"><code>new Worker()</code></a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker/SharedWorker\" target=\"_blank\" rel=\"noreferrer\"><code>new SharedWorker()</code></a>. Compared to the worker suffixes, this syntax leans closer to the standards and is the <strong>recommended</strong> way to create workers.</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const worker = new Worker(new URL('./worker.js', import.meta.url))</pre>\n</div>\n<p>The worker constructor also accepts options, which can be used to create \"module\" workers:</p>\n<div class=\"language-ts\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">const worker = new Worker(new URL('./worker.js', import.meta.url), {\n  type: 'module',\n})</pre>\n</div>\n<p>The worker detection will only work if the <code>new URL()</code> constructor is used directly inside the <code>new Worker()</code> declaration. Additionally, all options parameters must be static values (i.e. string literals).</p>\n<h3 id=\"import-with-query-suffixes\" tabindex=\"-1\">Import with Query Suffixes </h3>\n<p>A web worker script can be directly imported by appending <code>?worker</code> or <code>?sharedworker</code> to the import request. The default export will be a custom worker constructor:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import MyWorker from './worker?worker'\n\nconst worker = new MyWorker()</pre>\n</div>\n<p>The worker script can also use ESM <code>import</code> statements instead of <code>importScripts()</code>. <strong>Note</strong>: During development this relies on <a href=\"https://caniuse.com/?search=module%20worker\" target=\"_blank\" rel=\"noreferrer\">browser native support</a>, but for the production build it is compiled away.</p>\n<p>By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the <code>inline</code> query:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import MyWorker from './worker?worker&amp;inline'</pre>\n</div>\n<p>If you wish to retrieve the worker as a URL, add the <code>url</code> query:</p>\n<div class=\"language-js\">\n<pre class=\"shiki shiki-themes github-light github-dark twoslash lsp\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">import MyWorker from './worker?worker&amp;url'</pre>\n</div>\n<p>See <a href=\"../config/worker-options\">Worker Options</a> for details on configuring the bundling of all workers.</p>\n<h2 id=\"content-security-policy-csp\" tabindex=\"-1\">Content Security Policy (CSP) </h2>\n<p>To deploy CSP, certain directives or configs must be set due to Vite's internals.</p>\n<h3 id=\"nonce-random\" tabindex=\"-1\">\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#nonce-base64-value\" target=\"_blank\" rel=\"noreferrer\"><code>'nonce-{RANDOM}'</code></a> </h3>\n<p>When <a href=\"../config/shared-options#html-cspnonce\"><code>html.cspNonce</code></a> is set, Vite adds a nonce attribute with the specified value to any <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tags, as well as <code>&lt;link&gt;</code> tags for stylesheets and module preloading. Additionally, when this option is set, Vite will inject a meta tag (<code>&lt;meta property=\"csp-nonce\" nonce=\"PLACEHOLDER\" /&gt;</code>).</p>\n<p>The nonce value of a meta tag with <code>property=\"csp-nonce\"</code> will be used by Vite whenever necessary during both dev and after build.</p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">WARNING</strong><p>Ensure that you replace the placeholder with a unique value for each request. This is important to prevent bypassing a resource's policy, which can otherwise be easily done.</p>\n</div>\n<h3 id=\"data\" tabindex=\"-1\">\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#scheme-source:~:text=schemes%20(not%20recommended).-,data%3A,-Allows%20data%3A\" target=\"_blank\" rel=\"noreferrer\"><code>data:</code></a> </h3>\n<p>By default, during build, Vite inlines small assets as data URIs. Allowing <code>data:</code> for related directives (e.g. <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/img-src\" target=\"_blank\" rel=\"noreferrer\"><code>img-src</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/font-src\" target=\"_blank\" rel=\"noreferrer\"><code>font-src</code></a>), or, disabling it by setting <a href=\"../config/build-options#build-assetsinlinelimit\"><code>build.assetsInlineLimit: 0</code></a> is necessary.</p>\n<div class=\"warning custom-block\">\n<strong class=\"custom-block-title custom-block-title-default\">WARNING</strong><p>Do not allow <code>data:</code> for <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src\" target=\"_blank\" rel=\"noreferrer\"><code>script-src</code></a>. It will allow injection of arbitrary scripts.</p>\n</div>\n<h2 id=\"build-optimizations\" tabindex=\"-1\">Build Optimizations </h2>\n<blockquote><p>Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.</p></blockquote>\n<h3 id=\"css-code-splitting\" tabindex=\"-1\">CSS Code Splitting </h3>\n<p>Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <code>&lt;link&gt;</code> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid <a href=\"https://en.wikipedia.org/wiki/Flash_of_unstyled_content#:~:text=A%20flash%20of%20unstyled%20content,before%20all%20information%20is%20retrieved.\" target=\"_blank\" rel=\"noreferrer\">FOUC</a>.</p>\n<p>If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting <a href=\"../config/build-options#build-csscodesplit\"><code>build.cssCodeSplit</code></a> to <code>false</code>.</p>\n<h3 id=\"preload-directives-generation\" tabindex=\"-1\">Preload Directives Generation </h3>\n<p>Vite automatically generates <code>&lt;link rel=\"modulepreload\"&gt;</code> directives for entry chunks and their direct imports in the built HTML.</p>\n<h3 id=\"async-chunk-loading-optimization\" tabindex=\"-1\">Async Chunk Loading Optimization </h3>\n<p>In real world applications, Rollup often generates \"common\" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:</p>\n<figure class=\"svg-image-root\"><svg viewbox=\"0 0 1440 495\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"40\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"105.5\" y=\"278.545\">Entry</tspan></text>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"40\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"594\" y=\"85.0455\">async chunk A</tspan></text>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"40\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"1091.5\" y=\"254.045\">common chunk C</tspan></text>  <text fill=\"#15505C\" xml:space=\"preserve\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"40\" font-weight=\"600\" letter-spacing=\"0em\"><tspan x=\"595.5\" y=\"439.045\">async chunk B</tspan></text>   <text fill=\"#0B7285\" xml:space=\"preserve\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"35\" letter-spacing=\"0em\"><tspan x=\"172\" y=\"98.7273\">dynamic import</tspan></text> <text fill=\"#1864AB\" xml:space=\"preserve\" style=\"white-space: pre\" font-family=\"Inter\" font-size=\"35\" letter-spacing=\"0em\"><tspan x=\"1013\" y=\"83.7273\">direct import</tspan></text>   </svg> </figure><p>In the non-optimized scenarios, when async chunk <code>A</code> is imported, the browser will have to request and parse <code>A</code> before it can figure out that it also needs the common chunk <code>C</code>. This results in an extra network roundtrip:</p>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">Entry ---&gt; A ---&gt; C</pre>\n</div>\n<p>Vite automatically rewrites code-split dynamic import calls with a preload step so that when <code>A</code> is requested, <code>C</code> is fetched <strong>in parallel</strong>:</p>\n<div class=\"language-\">\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;\" tabindex=\"0\" dir=\"ltr\" data-language=\"javascript\">Entry ---&gt; (A + C)</pre>\n</div>\n<p>It is possible for <code>C</code> to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2019–present, Yuxi (Evan) You and Vite contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vite.dev/guide/features\" class=\"_attribution-link\">https://vite.dev/guide/features</a>\n  </p>\n</div>\n"}